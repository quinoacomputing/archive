<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>How to add a new scheme to Inciter | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="why.html">Why</a></li>
            <li>
              <a href="build.html">Build</a>
              <ol>
                <li><a href="https://quinoacomputing.org/quinoa.github.io/index.html#mainpage_build">Quickstart</a></li>
                <li><a href="git_submodules_subtrees.html">Modules</a></li>
                <li><a href="licenses.html">Libraries</a></li>
                <li><a href="build_system.html">Internals</a></li>
              </ol>
            </li>
            <li>
              <a href="https://quinoacomputing.org/quinoa.github.io/index.html#mainpage_tools">Tools</a>
              <ol>
                <li><a href="walker_main.html">Walker</a></li>
                <li><a href="inciter_main.html">Inciter</a></li>
                <li><a href="rngtest_main.html">RNGTest</a></li>
                <li><a href="unittest_main.html">UnitTest</a></li>
                <li><a href="meshconv_main.html">MeshConv</a></li>
              </ol>
            </li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="7">
            <li>
              <a href="resources.html">Resources</a>
              <ol>
                <li><a href="https://github.com/quinoacomputing/quinoa">GitHub</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/releases">Tarballs</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/blob/master/LICENSE">License</a></li>
                <li><a href="roadmap.html">Roadmap</a></li>
                <li><a href="contributing.html">Contributing</a></li>
                <li><a href="papers.html">Publications</a></li>
                <li><a href="https://quinoa.zulipchat.com">Chat</a></li>
                <li><a href="https://quinoa.groups.io">Email list</a></li>
                <li><a href="coverage.html">Coverage</a></li>
                <li><a href="https://dev.azure.com/quinoacomputing/Quinoa">Azure</a></li>
                <li><a href="http://www.openhub.net/p/quinoacomputing">OpenHub</a></li>
                <li><a href="https://bestpractices.coreinfrastructure.org/projects/2120">Practices</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          How to add a new scheme to Inciter
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#inciter_newscheme_rationale">Rationale and plan</a></li>
            <li>
              <a href="#inciter_newscheme_keyword">1. Add a new keyword</a>
              <ul>
                <li><a href="#inciter_newscheme_keyword_Keywords">Control/Keywords.hpp</a></li>
                <li><a href="#inciter_newscheme_keyword_InputDeck">Control/Inciter/InputDeck/InputDeck.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newscheme_option">2. Add new option switch</a>
              <ul>
                <li><a href="#inciter_newscheme_option_Scheme">Control/Inciter/Options/Scheme.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newscheme_proxy">3. Add new Charm++ chare proxy in Scheme</a>
              <ul>
                <li><a href="#inciter_newscheme_proxy_SchemeBase">Inciter/SchemeBase.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newscheme_chare">4. Add new Charm++ chare array</a>
              <ul>
                <li><a href="#inciter_newscheme_chare_Refiner">Inciter/Refiner.hpp</a></li>
                <li><a href="#inciter_newscheme_chare_CMakeLists">Inciter/CMakeLists.txt</a></li>
                <li>
                  <a href="#inciter_newscheme_chare_alecg">Inciter/alecg.ci</a>
                  <ul>
                    <li><a href="#inciter_newscheme_chare_alecg_headers">Inciter/alecg.ci – External modules and header includes</a></li>
                    <li><a href="#inciter_newscheme_chare_alecg_array">Inciter/alecg.ci – 1D Charm++ chare array</a></li>
                    <li><a href="#inciter_newscheme_chare_alecg_entry">Inciter/alecg.ci – Entry methods</a></li>
                    <li><a href="#inciter_newscheme_chare_alecg_sdag">Inciter/alecg.ci – Structured DAG</a></li>

                  </ul>
                </li>
                <li><a href="#inciter_newscheme_nowarning">NoWarning/alecg.decl.h and NoWarning/alecg.def.h</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newscheme_class">5. New C++ class</a>
              <ul>
                <li><a href="#inciter_newscheme_class_constructor">ALECG::ALECG – Constructor</a></li>
                <li><a href="#inciter_newscheme_class_comfinal">Transporter::comfinal() – Complete communication maps</a></li>
                <li><a href="#inciter_newscheme_class_setup">ALECG::setup() – Start setup</a></li>
                <li><a href="#inciter_newscheme_class_dt">ALECG::start() – Start time step</a></li>
                <li><a href="#inciter_newscheme_class_rhs">ALECG::rhs() &amp; ALECG::comrhs() – Compute and communicate right hand side</a></li>
                <li><a href="#inciter_newscheme_class_solve">ALECG::solve() – Solve</a></li>
                <li><a href="#inciter_newscheme_class_refine">ALECG::refine() – Optionally refine mesh</a></li>
                <li><a href="#inciter_newscheme_class_resize">ALECG::resizePostAMR() – Resize data after mesh refinement</a></li>
                <li><a href="#inciter_newscheme_class_lhs">ALECG::lhs() – Compute LHS</a></li>
                <li><a href="#inciter_newscheme_class_stage">New time step stage</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newscheme_work">6. Making it all work</a>
              <ul>
                <li><a href="#inciter_newscheme_work_inciter_ci">Main/inciter.ci</a></li>
                <li><a href="#inciter_newscheme_work_PDEStack">PDE/PDEStack.cpp</a></li>

              </ul>
            </li>
            <li><a href="#inciter_newscheme_unittest">7. Augment unit tests for Scheme</a></li>
            <li><a href="#inciter_newscheme_regression">8. Add new regression tests</a></li>
          </ul>
        </div>
<p><a href="inciter_main.html" class="m-dox">Inciter</a> supports multiple discretization schemes. This page describes how to add a scheme of your choice by walking through an example of adding a new one. We also discuss the main steps of the execution logic, which, at a high level, is the same for all discretization schemes.</p><section id="inciter_newscheme_rationale"><h2><a href="#inciter_newscheme_rationale">Rationale and plan</a></h2><p>Similar to the existing discretization schemes, <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>, or <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>, the new scheme, <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> (short for Arbitrary Lagrangian-Eulerian Continuous Galerkin), will interact with <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> in a child-base fashion, e.g., will directly access (and reuse) its member data and functions. It will also intereact with <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>, for mesh refinement (<a href="namespace_a_m_r.html" class="m-dox">AMR</a>), and will also be migratable to enable dynamic load balancing. In essence, it will have everything an existing scheme has. However, we will <em>not</em> implement the low-level details of the actual numerical method, only the glue-code necessary to interact with the rest of the code and we make it ready to start implementing the low-level details of a particular discretization, done by a <code>PDE</code> class, held behind a derived class of, e.g., <code><a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a></code> or <code><a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a></code>. For more details on how these classes interact, see also the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page.</p></section><section id="inciter_newscheme_keyword"><h2><a href="#inciter_newscheme_keyword">1. Add a new keyword</a></h2><p>A specific discretization scheme is selected by the user in the control (input) file via the <code>scheme</code> keyword, e.g., <code>scheme diagcg</code>. We add the new keyword, <code>alecg</code>, which then can be recognized by the control file parser, in <code><a href="_keywords_8hpp.html" class="m-dox">src/<wbr />Control/<wbr />Keywords.hpp</a></code> by adding the following code block:</p><section id="inciter_newscheme_keyword_Keywords"><h3><a href="#inciter_newscheme_keyword_Keywords">Control/Keywords.hpp</a></h3><pre class="m-code">$ git diff src/Control/Keywords.hpp
<span class="gh">diff --git a/src/Control/Keywords.hpp b/src/Control/Keywords.hpp</span>
<span class="gh">index 002869cb..c18f193a 100644</span>
<span class="gd">--- a/src/Control/Keywords.hpp</span>
<span class="gi">+++ b/src/Control/Keywords.hpp</span>
<span class="gu">@@ -4607,6 +4607,19 @@ struct diagcg_info {</span>
 };
 using diagcg = keyword&lt; diagcg_info, TAOCPP_PEGTL_STRING(&quot;diagcg&quot;) &gt;;

<span class="gi">+struct alecg_info {</span>
<span class="gi">+  static std::string name() { return &quot;ALE-CG with RK&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return &quot;Select continuous Galerkin &quot;</span>
<span class="gi">+    &quot;with ALE + Runge-Kutta&quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to select the continuous Galerkin finite element</span>
<span class="gi">+    scheme in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined</span>
<span class="gi">+    with Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.hpp</span>
<span class="gi">+    for other valid options.)&quot;; }</span>
<span class="gi">+};</span>
<span class="gi">+using alecg = keyword&lt; alecg_info, TAOCPP_PEGTL_STRING(&quot;alecg&quot;) &gt;;</span>
<span class="gi">+</span>
 struct dg_info {
   static std::string name() { return &quot;DG(P0) + RK&quot;; }
   static std::string shortDescription() { return</pre><p>We also add the new keyword to inciter&#x27;s grammar&#x27;s keywords pool:</p></section><section id="inciter_newscheme_keyword_InputDeck"><h3><a href="#inciter_newscheme_keyword_InputDeck">Control/Inciter/InputDeck/InputDeck.hpp</a></h3><pre class="m-code">$ git diff src/Control/Inciter/InputDeck/InputDeck.hpp
<span class="gh">diff --git a/src/Control/Inciter/InputDeck/InputDeck.hpp b/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gh">index 83572480..20ce8975 100644</span>
<span class="gd">--- a/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gu">@@ -144,6 +144,7 @@ class InputDeck :</span>
                                    kw::scheme,
                                    kw::matcg,
                                    kw::diagcg,
<span class="gi">+                                   kw::alecg,</span>
                                    kw::dg,
                                    kw::dgp1,
                                    kw::flux,</pre><p>This is required so that the compiler can generate a database containing the help for all the keywords in the grammar understood by inciter&#x27;s control file parser. The above changes not only add the keyword but also some documentation that gets displayed when passing the <code>-C</code> or <code>-H</code> command line arguments to the inciter executable, so quick help is available at the user&#x27;s fingertips:</p><pre class="m-console">$ inciter -C
inciter Control File Keywords:
             advdiff     string Specify the advection + diffusion physics configuration for a PDE
           advection     string Specify the advection physics configuration for a PDE
               alecg            Select continuous Galerkin with ALE + Runge-Kutta
           algorithm     string Select mesh partitioning algorithm
               alpha       real Set PDE parameter(s) alpha
...
$ inciter -H alecg
inciter control file keyword &#39;alecg&#39;

   Select continuous Galerkin with ALE + Runge-Kutta (RK)

   This keyword is used to select the continuous Galerkin finite element scheme
   in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined with
   Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.hpp for other
   valid options.</pre></section></section><section id="inciter_newscheme_option"><h2><a href="#inciter_newscheme_option">2. Add new option switch</a></h2><p>Next is to add a new state to the existing <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> option switch. This &quot;option
switch&quot; is really only a fancy enum, used to store the user&#x27;s choice of the discretization scheme after parsing the control file in a type-safe manner. This fancy enum is an option switch because it inherits from <a href="classtk_1_1_toggle.html" class="m-dox">tk::<wbr />Toggle</a>, defined in <a href="_toggle_8hpp.html" class="m-dox">Control/<wbr />Toggle.hpp</a>, which is a generic switch (or option), that helps associating enum values to keywords and querying one based on the other. Extending the existing <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> option switch is done by extending the list of schemes in <code><a href="_control_2_inciter_2_options_2_scheme_8hpp.html" class="m-dox">src/<wbr />Control/<wbr />Inciter/<wbr />Options/<wbr />Scheme.hpp</a></code>:</p><section id="inciter_newscheme_option_Scheme"><h3><a href="#inciter_newscheme_option_Scheme">Control/Inciter/Options/Scheme.hpp</a></h3><pre class="m-code">$ git diff src/Control/Inciter/Options/Scheme.hpp
<span class="gh">diff --git a/src/Inciter/SchemeBase.hpp b/src/Inciter/SchemeBase.hpp</span>
<span class="gh">index 61510d01..0cb3e9e8 100644</span>
<span class="gd">--- a/src/Inciter/SchemeBase.hpp</span>
<span class="gi">+++ b/src/Inciter/SchemeBase.hpp</span>
<span class="gu">@@ -22,6 +22,7 @@</span>

 #include &quot;NoWarning/matcg.decl.h&quot;
 #include &quot;NoWarning/diagcg.decl.h&quot;
<span class="gi">+#include &quot;NoWarning/alecg.decl.h&quot;</span>
 #include &quot;NoWarning/distfct.decl.h&quot;
 #include &quot;NoWarning/dg.decl.h&quot;
 #include &quot;NoWarning/discretization.decl.h&quot;
<span class="gu">@@ -52,8 +53,11 @@ class SchemeBase {</span>
         proxy = static_cast&lt; CProxy_DiagCG &gt;( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
       } else if (scheme == ctr::SchemeType::DG ||
<span class="gd">-                 scheme == ctr::SchemeType::DGP1) {</span>
<span class="gi">+                 scheme == ctr::SchemeType::DGP1)</span>
<span class="gi">+      {</span>
         proxy = static_cast&lt; CProxy_DG &gt;( CProxy_DG::ckNew(m_bound) );
<span class="gi">+      } else if (scheme == ctr::SchemeType::ALECG) {</span>
<span class="gi">+        proxy = static_cast&lt; CProxy_ALECG &gt;( CProxy_ALECG::ckNew(m_bound) );</span>
       } else Throw( &quot;Unknown discretization scheme&quot; );
     }

<span class="gu">@@ -75,11 +79,12 @@ class SchemeBase {</span>
     const CkArrayOptions&amp; arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
<span class="gd">-    using Proxy = boost::variant&lt; CProxy_DiagCG, CProxy_DG &gt;;</span>
<span class="gi">+    using Proxy =</span>
<span class="gi">+      boost::variant&lt; CProxy_DiagCG, CProxy_DG, CProxy_ALECG &gt;;</span>
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant&lt; CProxy_DiagCG::element_t,
<span class="gd">-                      CProxy_DG::element_t &gt;;</span>
<span class="gi">+                      CProxy_DG::element_t, CProxy_ALECG::element_t &gt;;</span>

   protected:
     //! Variant storing one proxy to which this class is configured for</pre></section></section><section id="inciter_newscheme_proxy"><h2><a href="#inciter_newscheme_proxy">3. Add new Charm++ chare proxy in Scheme</a></h2><p><code><a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a></code> is a class that, together with its base, <code>SchemeBase</code>, implements concept-based runtime polymorphism for migratable Charm++ chare arrays using value semantics. Client code, e.g., <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, interacts with <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> and its children via a uniform interface provided by <code><a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a></code>, which dispatches entry method calls to the correct class instance, the base or the child, and is capable of performing broadcasts as well as addressing a particular chare array element. Read more details at <a href="_inciter_2_scheme_8hpp.html" class="m-dox">src/<wbr />Inciter/<wbr />Scheme.hpp</a>. To teach it to dispatch to our new <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> scheme, besides the existing ones, we make the following changes:</p><section id="inciter_newscheme_proxy_SchemeBase"><h3><a href="#inciter_newscheme_proxy_SchemeBase">Inciter/SchemeBase.hpp</a></h3><pre class="m-code">$ git diff src/Inciter/SchemeBase.hpp
<span class="gh">diff --git a/src/Inciter/SchemeBase.hpp b/src/Inciter/SchemeBase.hpp</span>
<span class="gh">index 61510d01..dea3d78a 100644</span>
<span class="gd">--- a/src/Inciter/SchemeBase.hpp</span>
<span class="gi">+++ b/src/Inciter/SchemeBase.hpp</span>
<span class="gu">@@ -22,6 +22,7 @@</span>

 #include &quot;NoWarning/matcg.decl.h&quot;
 #include &quot;NoWarning/diagcg.decl.h&quot;
<span class="gi">+#include &quot;NoWarning/alecg.decl.h&quot;</span>
 #include &quot;NoWarning/distfct.decl.h&quot;
 #include &quot;NoWarning/dg.decl.h&quot;
 #include &quot;NoWarning/discretization.decl.h&quot;
<span class="gu">@@ -51,6 +52,8 @@ class SchemeBase {</span>
       } else if (scheme == ctr::SchemeType::DiagCG) {
         proxy = static_cast&lt; CProxy_DiagCG &gt;( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
<span class="gi">+      } else if (scheme == ctr::SchemeType::ALECG) {</span>
<span class="gi">+        proxy = static_cast&lt; CProxy_ALECG &gt;( CProxy_ALECG::ckNew(m_bound) );</span>
       } else if (scheme == ctr::SchemeType::DG ||
                  scheme == ctr::SchemeType::DGP1) {
         proxy = static_cast&lt; CProxy_DG &gt;( CProxy_DG::ckNew(m_bound) );
<span class="gu">@@ -75,11 +78,12 @@ class SchemeBase {</span>
     const CkArrayOptions&amp; arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
<span class="gd">-    using Proxy = boost::variant&lt; CProxy_DiagCG, CProxy_DG &gt;;</span>
<span class="gi">+    using Proxy =</span>
<span class="gi">+      boost::variant&lt; CProxy_DiagCG, CProxy_ALECG, CProxy_DG &gt;;</span>
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant&lt; CProxy_DiagCG::element_t,
<span class="gd">-                      CProxy_DG::element_t &gt;;</span>
<span class="gi">+                      CProxy_ALECG::element_t, CProxy_DG::element_t &gt;;</span>

   protected:
     //! Variant storing one proxy to which this class is configured for</pre></section></section><section id="inciter_newscheme_chare"><h2><a href="#inciter_newscheme_chare">4. Add new Charm++ chare array</a></h2><p>Next is to add a new class, <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code>, which will serve as the glue between <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>, and <code><a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a></code>. These classes, respectively, are the driver, the mesh refiner, and the polymorphic vector of PDE discretization class objects that hold the low-level details of the numerical implementation of spatial discretizations, dispatching to multiple specific systems of equations, e.g., <code><a href="classinciter_1_1cg_1_1_transport.html" class="m-dox">cg::<wbr />Transport</a></code> or <code><a href="classinciter_1_1cg_1_1_comp_flow.html" class="m-dox">cg::<wbr />CompFlow</a></code>.</p><p>We create the following new files:</p><ul><li><a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a>, Charm++ interface file for <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>,</li><li><a href="alecg_8decl_8h.html" class="m-dox">NoWarning/<wbr />alecg.decl.h</a> and <a href="alecg_8def_8h.html" class="m-dox">NoWarning/<wbr />alecg.def.h</a>, which help ignore compiler warnings in Charm++-generated code, and</li><li><a href="_a_l_e_c_g_8hpp.html" class="m-dox">Inciter/<wbr />ALECG.hpp</a> and <a href="_a_l_e_c_g_8cpp.html" class="m-dox">Inciter/<wbr />ALECG.cpp</a>, header and implementation of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>.</li></ul><p>Before we discuss the details of the above new files, let&#x27;s get a couple of simple things out of the way. We also need to add the new include to <code><a href="_refiner_8hpp.html" class="m-dox">Refiner.hpp</a></code> so, e.g., it can call back to ALECG::resize() after a mesh refinement step:</p><section id="inciter_newscheme_chare_Refiner"><h3><a href="#inciter_newscheme_chare_Refiner">Inciter/Refiner.hpp</a></h3><pre class="m-code">$ git diff src/Inciter/Refiner.hpp
<span class="gh">diff --git a/src/Inciter/Refiner.hpp b/src/Inciter/Refiner.hpp</span>
<span class="gh">index dfcb1ffd..4fe743a4 100644</span>
<span class="gd">--- a/src/Inciter/Refiner.hpp</span>
<span class="gi">+++ b/src/Inciter/Refiner.hpp</span>
<span class="gu">@@ -29,6 +29,7 @@</span>
 #include &quot;SchemeBase.hpp&quot;
 #include &quot;DiagCG.hpp&quot;
<span class="gi">+#include &quot;ALECG.hpp&quot;</span>
 #include &quot;DG.hpp&quot;

 #include &quot;NoWarning/transporter.decl.h&quot;</pre><p>We also tell the build system about our new <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> class and its Charm++ module:</p></section><section id="inciter_newscheme_chare_CMakeLists"><h3><a href="#inciter_newscheme_chare_CMakeLists">Inciter/CMakeLists.txt</a></h3><pre class="m-code">$ gd src/Inciter/CMakeLists.txt
<span class="gh">diff --git a/src/Inciter/CMakeLists.txt b/src/Inciter/CMakeLists.txt</span>
<span class="gh">index 141055ec..e339b65b 100644</span>
<span class="gd">--- a/src/Inciter/CMakeLists.txt</span>
<span class="gi">+++ b/src/Inciter/CMakeLists.txt</span>
<span class="gu">@@ -14,6 +14,7 @@ add_library(Inciter</span>
             Sorter.cpp
             DiagCG.cpp
<span class="gi">+            ALECG.cpp</span>
             DG.cpp
             FluxCorrector.cpp
             DistFCT.cpp
<span class="gu">@@ -74,6 +75,7 @@ addCharmModule( &quot;refiner&quot; &quot;Inciter&quot; )</span>
 addCharmModule( &quot;sorter&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;matcg&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;diagcg&quot; &quot;Inciter&quot; )
<span class="gi">+addCharmModule( &quot;alecg&quot; &quot;Inciter&quot; )</span>
 addCharmModule( &quot;distfct&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;dg&quot; &quot;Inciter&quot; )</pre><p>The <code>addCharmModule</code> cmake macro above, defined in <code>cmake/charm.cmake</code>, ensures that build target <code>Inciter</code> will properly depend on our new <code>alecg</code> Charm++ module, defined in <code><a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a></code>. The macro also tells cmake how the two files, <code><a href="alecg_8decl_8h.html" class="m-dox">alecg.decl.h</a></code> and <code><a href="alecg_8def_8h.html" class="m-dox">alecg.def.h</a></code>, are generated from <code><a href="alecg_8ci.html" class="m-dox">alecg.ci</a></code>: using <code>charmc</code>, a compiler wrapper that generates Charm++-code to make the <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> from an ordinary C++ class into a Charm++ chare array, with <em>entry</em> methods callable across the network, make it migratable, enable its structured DAGger, etc. See also the <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">Charm++ manual</a>.</p><p>Now to the new files. First is the new Charm++ interface file, <a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a>:</p></section><section id="inciter_newscheme_chare_alecg"><h3><a href="#inciter_newscheme_chare_alecg">Inciter/alecg.ci</a></h3><p>This is the file that is parsed by Charm++&#x27;s compiler which then generates additional code that makes <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> a Charm++ chare array, makes it migratable, etc. The full listing is at <a href="inciter_newscheme_alecg_ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a> some of whose details are discussed below.</p><section id="inciter_newscheme_chare_alecg_headers"><h4><a href="#inciter_newscheme_chare_alecg_headers">Inciter/alecg.ci – External modules and header includes</a></h4><pre class="m-code">  <span class="k">extern</span> <span class="k">module</span> <span class="nc">transporter</span><span class="p">;</span>
  <span class="k">extern</span> <span class="k">module</span> <span class="nc">discretization</span><span class="p">;</span>

  <span class="n">include</span> <span class="s">&quot;UnsMesh.hpp&quot;</span><span class="p">;</span>
  <span class="n">include</span> <span class="s">&quot;PUPUtil.hpp&quot;</span><span class="p">;</span></pre><p>First we declare some external Charm++ modules that <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> needs to interact with and thus from where we need type information. The <code>extern module</code> statements are followed by some usual C++ <code>include</code>s (without the <code>#</code>): these are in the Charm++ interface file because the Charm++ code below requires type information from them.</p></section><section id="inciter_newscheme_chare_alecg_array"><h4><a href="#inciter_newscheme_chare_alecg_array">Inciter/alecg.ci – 1D Charm++ chare array</a></h4><pre class="m-code">    <span class="k">array</span> <span class="p">[</span><span class="mi">1</span><span class="n">D</span><span class="p">]</span> <span class="n">ALECG</span> <span class="p">{</span></pre><p>Next comes the specification of the <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ chare array. This is a 1D array whose elements at runtime will be distributed across the available processing elements and compute nodes. If load balancing is enabled, the array elements (C++ objects) are migrated to homogenize load across a simulation. Because the array is 1D, we use a single integer index to address a particular array element. Charm++ also allows multi-dimensional arrays which can be useful if the problem naturally maps to a multi-dimensional notion, e.g., partitioning a 3D Cartesian mesh, so index calculations to address array elements (and thus work-units) become cleaner.</p></section><section id="inciter_newscheme_chare_alecg_entry"><h4><a href="#inciter_newscheme_chare_alecg_entry">Inciter/alecg.ci – Entry methods</a></h4><pre class="m-code">      <span class="k">entry</span> <span class="nf">ALECG</span><span class="p">(</span> <span class="k">const</span> <span class="n">CProxy_Discretization</span><span class="o">&amp;</span> <span class="n">disc</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span> <span class="p">);</span>
      <span class="k">initnode</span> <span class="kt">void</span> <span class="n">registerReducers</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">setup</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">box</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="n">v</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">resizeComm</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">nodeNeighSetup</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">start</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">refine</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;&amp;</span> <span class="n">l2ref</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="p">[</span><span class="k">reductiontarget</span><span class="p">]</span> <span class="kt">void</span> <span class="n">advance</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="n">newdt</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comdfnorm</span><span class="p">(</span>
              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edge</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="k">array</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;</span><span class="p">,</span>
              <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Hash</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Eq</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">dfnorm</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comnorm</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
       <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="k">array</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">innorm</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comChBndGrad</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">gid</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">G</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comrhs</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">gid</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">R</span> <span class="p">);</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">resized</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">meshveldone</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">lhs</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">step</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">next</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">stage</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">evalLB</span><span class="p">(</span> <span class="kt">int</span> <span class="n">nrestart</span> <span class="p">);</span></pre><p>We simply list those member functions of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> as <em>entry</em> methods, e.g., <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a> or <a href="classinciter_1_1_a_l_e_c_g.html#a5ff6f124c00f5ac180fc5c84d8531717" class="m-dox">ALECG::<wbr />dt()</a>, that we need to be able to call externally, potentially across the network, from another processing element (PE). Entry methods are always <em>public</em> in the C++ object-oriented programming (OOP) sense. Note that there can be other member functions of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>. These are simple C++ class member functions and are usually not <em>public</em> but <em>private</em>, such as <code><a href="classinciter_1_1_a_l_e_c_g.html#a416249274fefe5745c419388e786cda2" class="m-dox">ALECG::<wbr />rhs()</a></code>. Note also that there is an <code>initnode</code> entry method, <code><a href="classinciter_1_1_a_l_e_c_g.html#ae1c431a552a76e269a3b35081557a70f" class="m-dox">ALECG::<wbr />registerReducers()</a></code> which is a special member function that is also declared as <em>static</em> in the C++ sense (see <a href="_a_l_e_c_g_8hpp.html" class="m-dox">ALECG.hpp</a>). This is static because the runtime system must be able to call this function without creating an object and a lot earlier than the actual <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> chare array elements are created. This is how <em>custom reducers</em> can be associated in Charm++ to a chare array. Such custom reducers are an excellent way to rely on the asynchronous, tree-based implementation of parallel reductions in Charm++ yet still do it on custom, arbitrarily complex data types, e.g., a hash-map that holds vectors, as long as one defines how aggregation is to be performed when merging such data. Such an example is given in <a href="_diag_reducer_8cpp.html" class="m-dox">Inciter/<wbr />DiagReducer.cpp</a>.</p></section><section id="inciter_newscheme_chare_alecg_sdag"><h4><a href="#inciter_newscheme_chare_alecg_sdag">Inciter/alecg.ci – Structured DAG</a></h4><pre class="m-code">      <span class="k">entry</span> <span class="kt">void</span> <span class="n">wait4norm</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">when</span> <span class="nf">ownnorm_complete</span><span class="p">(),</span> <span class="n">comnorm_complete</span><span class="p">(),</span>
             <span class="n">owndfnorm_complete</span><span class="p">(),</span> <span class="n">comdfnorm_complete</span><span class="p">(),</span>
             <span class="n">transfer_complete</span><span class="p">()</span> <span class="n">serial</span> <span class="s">&quot;norm&quot;</span> <span class="p">{</span> <span class="n">mergelhs</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span>

      <span class="k">entry</span> <span class="kt">void</span> <span class="n">wait4grad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">when</span> <span class="nf">owngrad_complete</span><span class="p">(),</span> <span class="n">comgrad_complete</span><span class="p">()</span> <span class="n">serial</span> <span class="s">&quot;grad&quot;</span> <span class="p">{</span> <span class="n">rhs</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span>

      <span class="k">entry</span> <span class="kt">void</span> <span class="n">wait4rhs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">when</span> <span class="nf">ownrhs_complete</span><span class="p">(),</span> <span class="n">comrhs_complete</span><span class="p">()</span> <span class="n">serial</span> <span class="s">&quot;rhs&quot;</span> <span class="p">{</span> <span class="n">solve</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span>

      <span class="k">entry</span> <span class="kt">void</span> <span class="n">wait4mesh</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">when</span> <span class="nf">norm_complete</span><span class="p">(),</span> <span class="n">resize_complete</span><span class="p">()</span> <span class="n">serial</span> <span class="s">&quot;trans&quot;</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">m_newmesh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">meshvelstart</span><span class="p">();</span> <span class="k">else</span> <span class="n">transfer</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span>

      <span class="k">entry</span> <span class="kt">void</span> <span class="n">ownnorm_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comnorm_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">owndfnorm_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comdfnorm_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">transfer_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">ownrhs_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comrhs_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">owngrad_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">comgrad_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">norm_complete</span><span class="p">();</span>
      <span class="k">entry</span> <span class="kt">void</span> <span class="n">resize_complete</span><span class="p">();</span></pre><p>The entry methods, defined in the <code>.ci</code> file and with <code>when</code> keywords, form a structured directed acyclic graph (DAG). These specify logical relations among tasks and execution logic within the class. For example, <code>wait4grad</code> tells the runtime system that only when <code>owngrad_complete()</code> <em>and</em> <code>comgrad_complete()</code> are both done will <code>rhs()</code> be called. In this case, this construct ensures that the runtime system will call a member function that requires the assembled right-hand side, when both the local and external contributions are complete. Note that this logic only relates to a given array element, say with index 2. Another one, say index 3, may perform this operation at a very different time and independently, thus computation and communication can overlap. The entry methods listed at the bottom, e.g., <code>owngrad_complete()</code> can be thought of as &quot;labels&quot; to the runtime system that help define the task logic. These labels are functions that the runtime system defines and we call them when the given task is complete. Note that the construct we used here, when <strong>A</strong> <em>and</em> <strong>B</strong> are both complete <em>then</em> do <strong>C</strong>, is probably the simplest task-logic Charm++ allows prescribing. There are many more advanced ways of expressing such logic, e.g., using loops. For more details, see Section <em>Structured Control Flow: Structured Dagger</em> in the <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">Charm++ manual</a>.</p></section></section><section id="inciter_newscheme_nowarning"><h3><a href="#inciter_newscheme_nowarning">NoWarning/alecg.decl.h and NoWarning/alecg.def.h</a></h3><p>The newly added files to the <code>NoWarning/</code> directory simply include the Charm++-generated <code><a href="alecg_8decl_8h.html" class="m-dox">alecg.decl.h</a></code> and <code><a href="alecg_8def_8h.html" class="m-dox">alecg.def.h</a></code> files and locally, around the include, turn off specific compiler warnings for various compilers &ndash; we will not discuss them here further. Full listings are at <a href="inciter_newscheme_nowarning_page.html" class="m-dox">NoWarning/alecg.decl.h and NoWarning/alecg.def.h</a>.</p></section></section><section id="inciter_newscheme_class"><h2><a href="#inciter_newscheme_class">5. New C++ class</a></h2><p>Next are the newly added <a href="_a_l_e_c_g_8hpp.html" class="m-dox">Inciter/<wbr />ALECG.hpp</a> and <a href="_a_l_e_c_g_8cpp.html" class="m-dox">Inciter/<wbr />ALECG.cpp</a>, header and implementation of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>. The full listings are at <a href="inciter_newscheme_header_page.html" class="m-dox">Inciter/<wbr />ALECG.hpp</a> and <a href="inciter_newscheme_class_page.html" class="m-dox">Inciter/<wbr />ALECG.cpp</a>, some of whose details are discussed below, rougly in order of execution.</p><section id="inciter_newscheme_class_constructor"><h3><a href="#inciter_newscheme_class_constructor">ALECG::ALECG – Constructor</a></h3><pre class="m-code"><span class="p">{</span>
  <span class="n">usesAtSync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>    <span class="c1">// enable migration at AtSync</span>

  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="c1">// Perform optional operator-access-pattern mesh node reordering</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">operator_reorder</span> <span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

    <span class="c1">// Create new local ids based on access pattern of PDE operators</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">m_u</span><span class="p">.</span><span class="n">nunk</span><span class="p">();</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// for each point p</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="n">map</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">tk</span><span class="o">::</span><span class="n">Around</span><span class="p">(</span><span class="n">m_psup</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>     <span class="c1">// for each edge p-q</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="n">map</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Assert</span><span class="p">(</span> <span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Gid</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Map size mismatch&quot;</span> <span class="p">);</span>

    <span class="c1">// Remap data in bound Discretization object</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">remap</span><span class="p">(</span> <span class="n">map</span> <span class="p">);</span>
    <span class="c1">// Recompute elements surrounding points</span>
    <span class="n">m_esup</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsup</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Inpoel</span><span class="p">(),</span> <span class="mi">4</span> <span class="p">);</span>
    <span class="c1">// Recompute points surrounding points</span>
    <span class="n">m_psup</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genPsup</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Inpoel</span><span class="p">(),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">m_esup</span> <span class="p">);</span>
    <span class="c1">// Remap boundary triangle face connectivity</span>
    <span class="n">tk</span><span class="o">::</span><span class="n">remap</span><span class="p">(</span> <span class="n">m_triinpoel</span><span class="p">,</span> <span class="n">map</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Query/update boundary-conditions-related data structures from user input</span>
  <span class="n">queryBnd</span><span class="p">();</span>

  <span class="c1">// Activate SDAG wait for initially computing normals</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4norm</span><span class="p">();</span>

  <span class="c1">// Generate callbacks for solution transfers we are involved in</span>

  <span class="c1">// Always add a callback to be used when we are not involved in any transfers</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">CkCallback</span> <span class="o">&gt;</span> <span class="n">cb</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkIndex_ALECG</span><span class="o">::</span><span class="n">transfer_complete</span><span class="p">(),</span> <span class="n">thisProxy</span><span class="p">[</span><span class="n">thisIndex</span><span class="p">]);</span>
  <span class="n">cb</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>

  <span class="c1">// Generate a callback for each transfer we are involved in (either as a</span>
  <span class="c1">// source or a destination)</span>
  <span class="k">auto</span> <span class="n">meshid</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">MeshId</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Transfers</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meshid</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="n">src</span> <span class="o">||</span> <span class="n">meshid</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="n">dst</span><span class="p">)</span>
      <span class="n">cb</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>

  <span class="c1">// Send callbacks to base</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">transferCallback</span><span class="p">(</span> <span class="n">cb</span> <span class="p">);</span>
<span class="p">}</span></pre><p>As discussed in Section <a href="inciter_design.html#inciter_create" class="m-dox">Creating workers</a> on the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page, the worker chare array elements, such as <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, are created using Charm++&#x27;s dynamic array insertion feature. This is an asynchronous call, issued from <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a>, and it signals the runtime system that it is time to start calling individual constructors of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, passing them the appropriate data, required for each of them to initialize and operate on a mesh partition each is assigned (held by their companion <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a> &quot;base&quot; class). Thus running <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a> eventually triggers calling <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>&#x27;s constructors distributed across the whole problem and available PEs.</p><p>In the constructor&#x27;s body, listed above, various initialization steps are executed, including enabling migration for the class. Mesh-to-mesh solution transfer is also configured, calling member functions of <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, which then eventually signals the runtime system that <em>extra</em> communication buffers (other than those alrady stored in <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>), specific to this particular <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> scheme, have been created. This is a reduction call, issued by all array elements, eventually calling the reduction target <code><a href="classinciter_1_1_transporter.html#a5a29629d824a461d0ed76a457970df82" class="m-dox">Transporter::<wbr />comfinal()</a></code> a single time.</p><aside class="m-note m-info"><h4>Note</h4><p>By default, there are no extra communication buffers needed to be setup in <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, because the symmetric mesh-node communication maps have already been setup and stored in <a href="classinciter_1_1_discretization.html#af11bb07974762156f979c7fc1e8af366" class="m-dox">Discretization::<wbr />m_nodeCommMap</a>, discussed in Section <a href="inciter_design.html#inciter_reorder" class="m-dox">Optional PE-locality mesh node reordering</a> on the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page. This node communication map is made available to all discretization schemes by default. A counter-example to <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> is <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a> which, in this stage, sets up face communication and ghost element data structures, required only by the cell-centered DG-style discretization. These <em>extra</em> communication data structures are stored in <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, i.e., locally in that class, but <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, just like <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> (and all other schemes) are expected to signal the end of such <em>extra</em> communication maps by issuing the reduction targeting <code><a href="classinciter_1_1_transporter.html#a5a29629d824a461d0ed76a457970df82" class="m-dox">Transporter::<wbr />comfinal()</a></code>.</p></aside></section><section id="inciter_newscheme_class_comfinal"><h3><a href="#inciter_newscheme_class_comfinal">Transporter::comfinal() – Complete communication maps</a></h3><pre class="m-code"><span class="p">{</span>
  <span class="k">auto</span> <span class="n">meshid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">m_meshid</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">summeshid</span><span class="p">)</span> <span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">initial</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_scheme</span><span class="p">[</span><span class="n">meshid</span><span class="p">].</span><span class="n">bcast</span><span class="o">&lt;</span> <span class="n">Scheme</span><span class="o">::</span><span class="n">setup</span> <span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// Turn on automatic load balancing</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_ncom</span> <span class="o">==</span> <span class="n">m_nelem</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// all worker arrays have finished</span>
      <span class="n">m_ncom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">print</span> <span class="o">=</span> <span class="n">printer</span><span class="p">();</span>
      <span class="n">m_progWork</span><span class="p">.</span><span class="n">end</span><span class="p">(</span> <span class="n">print</span> <span class="p">);</span>
      <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_LBSwitch</span><span class="o">::</span><span class="n">ckNew</span><span class="p">();</span>
      <span class="n">print</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span> <span class="s">&quot;Load balancing on (if enabled in Charm++)&quot;</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">m_scheme</span><span class="p">[</span><span class="n">meshid</span><span class="p">].</span><span class="n">bcast</span><span class="o">&lt;</span> <span class="n">Scheme</span><span class="o">::</span><span class="n">lhs</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>Though asynchronously executed, the reduction operation targeting <code><a href="classinciter_1_1_transporter.html#a5a29629d824a461d0ed76a457970df82" class="m-dox">Transporter::<wbr />comfinal()</a></code> is a global synchronization point: all chares arrive in that function body, synchronized, and all continue from there again by calling <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a>.</p><aside class="m-note m-info"><h4>Note</h4><p>The call to <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a> is hidden behind Scheme::setup(). In an OOP sense this is equivalent to calling a virtual member function on a reference or a pointer of the base class, <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, which then dispatches down to the child class member function <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a>.</p><p>Also note that the call to <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a>, does <em>not</em> address any particular chare array element, but goes through <a href="classinciter_1_1_scheme.html#a49f2ca0b8aeb37bc00cadb337ce28345" class="m-dox">Scheme::<wbr />bcast()</a>, which means that it addresses <em>all</em> array elements. Its argument is sent to all elements (across the network) in a broadcast fashion.</p></aside><p><a href="classinciter_1_1_transporter.html#a5a29629d824a461d0ed76a457970df82" class="m-dox">Transporter::<wbr />comfinal()</a> is a global synchronization point because <em>all</em> worker chares must finish resizing and/or constructing their communication maps before their <code>setup()</code> member function can be invoked. This is because <code>setup()</code> is allowed to start using those communication maps that have been constructed <em>before</em> calling setup().</p></section><section id="inciter_newscheme_class_setup"><h3><a href="#inciter_newscheme_class_setup">ALECG::setup() – Start setup</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">setup</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// Start setup for solution</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="c1">// Determine nodes inside user-defined IC box</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span> <span class="n">eq</span><span class="p">.</span><span class="n">IcBoxNodes</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Coord</span><span class="p">(),</span> <span class="n">m_boxnodes</span> <span class="p">);</span>

  <span class="c1">// Compute volume of user-defined box IC</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">boxvol</span><span class="p">(</span> <span class="n">m_boxnodes</span> <span class="p">);</span>

  <span class="c1">// Query time history field output labels from all PDEs integrated</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">hist_points</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">history</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">point</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hist_points</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">histnames</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">eq</span><span class="p">.</span><span class="n">histNames</span><span class="p">();</span>
      <span class="n">histnames</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">end</span><span class="p">(</span><span class="n">histnames</span><span class="p">),</span> <span class="n">begin</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">histheader</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">histnames</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>In the <a href="classinciter_1_1_a_l_e_c_g.html#a08580c19f39310f066721609d9e4bcd3" class="m-dox">ALECG::<wbr />setup()</a> code snippet above the various setup steps are started. What they are may change as we develop this further, so we don&#x27;t go into detail here, the current listing is above.</p><p>The current DAG in <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a> should be consulted for the task logic. When the setup phase is done, <a href="classinciter_1_1_a_l_e_c_g.html#a95226f468e03957134e16ac0857d32dd" class="m-dox">ALECG::<wbr />start()</a> is called, which starts time stepping.</p></section><section id="inciter_newscheme_class_dt"><h3><a href="#inciter_newscheme_class_dt">ALECG::start() – Start time step</a></h3><p>Eventually called by <a href="classinciter_1_1_a_l_e_c_g.html#a95226f468e03957134e16ac0857d32dd" class="m-dox">ALECG::<wbr />start()</a>, <a href="classinciter_1_1_a_l_e_c_g.html#a5ff6f124c00f5ac180fc5c84d8531717" class="m-dox">ALECG::<wbr />dt()</a> starts computing the smallest-size <code>dt</code> allowed in the give time step across the whole problem:</p><pre class="m-code">    <span class="n">conserved</span><span class="p">(</span> <span class="n">m_u</span><span class="p">,</span> <span class="n">Disc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Vol</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">steady_state</span> <span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

      <span class="c1">// compute new dt for each mesh point</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span>
        <span class="n">eq</span><span class="p">.</span><span class="n">dt</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">It</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Vol</span><span class="p">(),</span> <span class="n">m_u</span><span class="p">,</span> <span class="n">m_dtp</span> <span class="p">);</span>

      <span class="c1">// find the smallest dt of all nodes on this chare</span>
      <span class="n">mindt</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">m_dtp</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">m_dtp</span><span class="p">)</span> <span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// compute new dt for this chare</span>

      <span class="c1">// find the smallest dt of all equations on this chare</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">eqdt</span> <span class="o">=</span> <span class="n">eq</span><span class="p">.</span><span class="n">dt</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Coord</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Inpoel</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">T</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Dtn</span><span class="p">(),</span> <span class="n">m_u</span><span class="p">,</span>
                           <span class="n">d</span><span class="o">-&gt;</span><span class="n">Vol</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Voln</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eqdt</span> <span class="o">&lt;</span> <span class="n">mindt</span><span class="p">)</span> <span class="n">mindt</span> <span class="o">=</span> <span class="n">eqdt</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="p">}</span>
    <span class="n">volumetric</span><span class="p">(</span> <span class="n">m_u</span><span class="p">,</span> <span class="n">Disc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Vol</span><span class="p">()</span> <span class="p">);</span></pre><p>The above code snippet shows a <code>for</code> loop that calls the the <code>dt()</code> member function of all types of PDEs configured by the user and finds the minimum size of the next time step.</p><pre class="m-code">  <span class="c1">// Actiavate SDAG waits for next time step stage</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4grad</span><span class="p">();</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4rhs</span><span class="p">();</span>

  <span class="c1">// Contribute to minimum dt across all chares and advance to next step</span>
  <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tk</span><span class="o">::</span><span class="n">real</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mindt</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">min_double</span><span class="p">,</span>
              <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkReductionTarget</span><span class="p">(</span><span class="n">ALECG</span><span class="p">,</span><span class="n">advance</span><span class="p">),</span> <span class="n">thisProxy</span><span class="p">)</span> <span class="p">);</span></pre><p>Once we have the time step size, we enable a couple of SDAG waits to get ready for some communication steps and issue a reduction to <a href="classinciter_1_1_a_l_e_c_g.html#a8471053d9f3da3a7a692876e3294f7fe" class="m-dox">ALECG::<wbr />advance()</a> which yields the global minimum of the <code>dt</code> across all chares. <code>advance()</code> saves the new time step in <code><a href="classinciter_1_1_discretization.html#ae72466ca58faefcd7876523b54782061" class="m-dox">Discretization::<wbr />m_dt</a></code>, which is its <em>master</em> copy, then starts computing the right hand sides of all PDEs integrated, which requires the primitive variable gradients first (requiring its own communication step).</p></section><section id="inciter_newscheme_class_rhs"><h3><a href="#inciter_newscheme_class_rhs">ALECG::rhs() &amp; ALECG::comrhs() – Compute and communicate right hand side</a></h3><p>When both the own and communicated contributions are complete on a chare, the runtime system continues as described in the DAG in <a href="alecg_8ci.html" class="m-dox">alecg.ci</a>. <a href="classinciter_1_1_a_l_e_c_g.html#a778e4351bfc35c4a7c2943901c61830e" class="m-dox">ALECG::<wbr />solve()</a>, first combines the own and received contributions then advances all equations using a Runge-Kutta method.</p></section><section id="inciter_newscheme_class_solve"><h3><a href="#inciter_newscheme_class_solve">ALECG::solve() – Solve</a></h3><pre class="m-code">  <span class="c1">// Recompute mesh volumes if ALE is enabled</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">ale</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">ale</span> <span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

    <span class="n">transfer_complete</span><span class="p">();</span>
    <span class="c1">// Save nodal volumes at previous time step stage</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">Voln</span><span class="p">()</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Vol</span><span class="p">();</span>
    <span class="c1">// Prepare for recomputing the nodal volumes</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">startvol</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">meshid</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">MeshId</span><span class="p">();</span>
    <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
                <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkReductionTarget</span><span class="p">(</span><span class="n">Transporter</span><span class="p">,</span><span class="n">resized</span><span class="p">),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Tr</span><span class="p">())</span> <span class="p">);</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="n">norm_complete</span><span class="p">();</span>
    <span class="n">resized</span><span class="p">();</span>

  <span class="p">}</span></pre><p>The above code snippet shows what happens immediately after advancing the solution on a chare. If <a href="classinciter_1_1_a_l_e.html" class="m-dox">ALE</a> mesh movement is enabled, the mesh nodes have been moved in physical space, so the nodal volumes need to be recomputed so we get ready for this. This is followed by optionally computing <em>diagnostics</em>, which is a catch-all phrase for various norms and integral quantities, see <a href="_node_diagnostics_8cpp.html" class="m-dox">Inciter/<wbr />NodeDiagnostics.cpp</a> for details. Note that computing diagnostics only happens every few time step, depending on user configuration. If <code>m_diag.compute()</code> returns true, diagnostics have been computed in this time step. If diagnostics have been computed, their correct values require global reduction operations, performing different aggregation operations depending on the value. As almost all reductions, diagnostics are also collected by <a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a>, this time in target <code><a href="classinciter_1_1_transporter.html#af0591f0f12756bf1e55ff667b15135a1" class="m-dox">Transporter::<wbr />diagnostics()</a></code>, which calls back, via a broadcast, to <a href="classinciter_1_1_a_l_e_c_g.html#aea0413abbbb9139a38dacd24e3adf484" class="m-dox">ALECG::<wbr />refine()</a>, which performs an optional mesh refinement step.</p></section><section id="inciter_newscheme_class_refine"><h3><a href="#inciter_newscheme_class_refine">ALECG::refine() – Optionally refine mesh</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">refine</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;&amp;</span> <span class="n">l2res</span> <span class="p">)</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// Optionally refine/derefine mesh</span>
<span class="c1">//! \param[in] l2res L2-norms of the residual for each scalar component</span>
<span class="c1">//!   computed across the whole problem</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">steady</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">steady_state</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">residual</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">residual</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">rescomp</span> <span class="o">&gt;</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">steady</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// this is the last time step if max time of max number of time steps</span>
    <span class="c1">// reached or the residual has reached its convergence criterion</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">()</span> <span class="n">or</span> <span class="n">l2res</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">residual</span><span class="p">)</span> <span class="n">m_finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="c1">// this is the last time step if max time or max iterations reached</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">())</span> <span class="n">m_finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">dtref</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">amr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">dtref</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">dtfreq</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">amr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">dtfreq</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Activate SDAG waits for re-computing the normals</span>
  <span class="n">m_newmesh</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// recompute normals after AMR (if enabled)</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4norm</span><span class="p">();</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4mesh</span><span class="p">();</span>

  <span class="c1">// if t&gt;0 refinement enabled and we hit the frequency</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dtref</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">It</span><span class="p">()</span> <span class="o">%</span> <span class="n">dtfreq</span><span class="p">))</span> <span class="p">{</span>   <span class="c1">// refine</span>

    <span class="n">d</span><span class="o">-&gt;</span><span class="n">startvol</span><span class="p">();</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">dtref</span><span class="p">(</span> <span class="p">{},</span> <span class="n">m_bnode</span><span class="p">,</span> <span class="p">{}</span> <span class="p">);</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">refined</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// do not refine</span>

    <span class="n">d</span><span class="o">-&gt;</span><span class="n">refined</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">norm_complete</span><span class="p">();</span>
    <span class="n">resized</span><span class="p">();</span>

  <span class="p">}</span>
<span class="p">}</span></pre><p>The above snippet shows that mesh refinement happens only at every few time step with its frequency configured by the user. If the mesh is <em>not</em> refined, we simply enable the SDAG waits associated to the tasks of the mesh refinement step. If the mesh <em>is</em> refined, we call a member function of the mesh refiner object held by <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, <a href="classinciter_1_1_refiner.html#af7b03046d71c7b0ad79d8a31b7ce8392" class="m-dox">Refiner::<wbr />dtref()</a>, which when done, eventually calls back to <a href="classinciter_1_1_a_l_e_c_g.html#a1ccfab472fbfa7eed3f21ec5775a1859" class="m-dox">ALECG::<wbr />resizePostAMR()</a>, passing back the new mesh and associated data structures.</p></section><section id="inciter_newscheme_class_resize"><h3><a href="#inciter_newscheme_class_resize">ALECG::resizePostAMR() – Resize data after mesh refinement</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">resizePostAMR</span><span class="p">(</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="cm">/*ginpoel*/</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Chunk</span><span class="o">&amp;</span> <span class="n">chunk</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coords</span><span class="o">&amp;</span> <span class="n">coord</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edge</span> <span class="o">&gt;&amp;</span> <span class="n">addedNodes</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="cm">/*addedTets*/</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">removedNodes</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">NodeCommMap</span><span class="o">&amp;</span> <span class="n">nodeCommMap</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span> <span class="p">)</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">//  Receive new mesh from Refiner</span>
<span class="c1">//! \param[in] ginpoel Mesh connectivity with global node ids</span>
<span class="c1">//! \param[in] chunk New mesh chunk (connectivity and global&lt;-&gt;local id maps)</span>
<span class="c1">//! \param[in] coord New mesh node coordinates</span>
<span class="c1">//! \param[in] addedNodes Newly added mesh nodes and their parents (local ids)</span>
<span class="c1">//! \param[in] addedTets Newly added mesh cells and their parents (local ids)</span>
<span class="c1">//! \param[in] removedNodes Newly removed mesh nodes (local ids)</span>
<span class="c1">//! \param[in] nodeCommMap New node communication map</span>
<span class="c1">//! \param[in] bface Boundary-faces mapped to side set ids</span>
<span class="c1">//! \param[in] bnode Boundary-node lists mapped to side set ids</span>
<span class="c1">//! \param[in] triinpoel Boundary-face connectivity</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="n">d</span><span class="o">-&gt;</span><span class="n">Itf</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Zero field output iteration count if AMR</span>
  <span class="o">++</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">Itr</span><span class="p">();</span>    <span class="c1">// Increase number of iterations with a change in the mesh</span>

  <span class="c1">// Resize mesh data structures after mesh refinement</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">resizePostAMR</span><span class="p">(</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">nodeCommMap</span> <span class="p">);</span>

  <span class="c1">// Remove newly removed nodes from solution vectors</span>
  <span class="n">m_u</span><span class="p">.</span><span class="n">rm</span><span class="p">(</span><span class="n">removedNodes</span><span class="p">);</span>
  <span class="n">m_un</span><span class="p">.</span><span class="n">rm</span><span class="p">(</span><span class="n">removedNodes</span><span class="p">);</span>
  <span class="n">m_rhs</span><span class="p">.</span><span class="n">rm</span><span class="p">(</span><span class="n">removedNodes</span><span class="p">);</span>

  <span class="c1">// Resize auxiliary solution vectors</span>
  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">nprop</span> <span class="o">=</span> <span class="n">m_u</span><span class="p">.</span><span class="n">nprop</span><span class="p">();</span>
  <span class="n">m_u</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span> <span class="p">);</span>
  <span class="n">m_un</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span> <span class="p">);</span>
  <span class="n">m_rhs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span> <span class="p">);</span>
  <span class="n">m_chBndGrad</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Bid</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

  <span class="c1">// Update solution on new mesh</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">addedNodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">nprop</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span>
      <span class="n">m_u</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_u</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">m_u</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>

  <span class="c1">// Update physical-boundary node-, face-, and element lists</span>
  <span class="n">m_bnode</span> <span class="o">=</span> <span class="n">bnode</span><span class="p">;</span>
  <span class="n">m_bface</span> <span class="o">=</span> <span class="n">bface</span><span class="p">;</span>
  <span class="n">m_triinpoel</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">remap</span><span class="p">(</span> <span class="n">triinpoel</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Lid</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">auto</span> <span class="n">meshid</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">MeshId</span><span class="p">();</span>
  <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
              <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkReductionTarget</span><span class="p">(</span><span class="n">Transporter</span><span class="p">,</span><span class="n">resized</span><span class="p">),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Tr</span><span class="p">())</span> <span class="p">);</span>
<span class="p">}</span></pre><p>The above snippet shows the function that is called by <a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a> when it finished mesh refinement. Besides resizing the mesh-related data held locally by <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, e.g., <a href="classinciter_1_1_a_l_e_c_g.html#a8540cc3072f34976097cb58b7d7b1c1f" class="m-dox">ALECG::<wbr />m_u</a>, etc., we also resize all mesh-related data structures in <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>. In addition nodal volumes must also be recomputed after mesh refinement. The control flow in all <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> chares eventually end up with a global synchronization by calling <a href="classinciter_1_1_transporter.html#a4535c4dca981e06d17fa043e003de23f" class="m-dox">Transporter::<wbr />resized()</a> - once again if <a href="classinciter_1_1_a_l_e.html" class="m-dox">ALE</a> was enabled and mesh refinement has also happened in this time step. The value of <a href="classinciter_1_1_a_l_e_c_g.html#a5b3135e114b321d72374e831f65da74f" class="m-dox">ALECG::<wbr />m_newmesh</a> differentiates what step calls <a href="classinciter_1_1_transporter.html#a4535c4dca981e06d17fa043e003de23f" class="m-dox">Transporter::<wbr />resized()</a> (after <a href="classinciter_1_1_a_l_e.html" class="m-dox">ALE</a> or after <a href="namespace_a_m_r.html" class="m-dox">AMR</a>). <a href="classinciter_1_1_transporter.html#a4535c4dca981e06d17fa043e003de23f" class="m-dox">Transporter::<wbr />resized()</a> then starts recomputing the volumes and recomputing the left-hand side (LHS).</p></section><section id="inciter_newscheme_class_lhs"><h3><a href="#inciter_newscheme_class_lhs">ALECG::lhs() – Compute LHS</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">lhs</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// Compute the left-hand side of transport equations</span>
<span class="c1">//! \details Also (re-)compute all data structures if the mesh changed.</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="c1">// No need for LHS in ALECG</span>

  <span class="c1">// (Re-)compute boundary point-, and dual-face normals</span>
  <span class="n">norm</span><span class="p">();</span>
<span class="p">}</span></pre><p>As the above <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a> code snippet shows, there is no need to compute the left-hand side (LHS) in <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>. This is because the unknowns stored are the same as the <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> algorithm solves for, so there is no matrix (not even a diagonal one) on the left-hand side of the system that is solved. However, the function is still called <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a> because this is an entry point in all schemes, returning from, e.g., an adaptive mesh refinement step. Also, there are other tasks started from <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a>: these are (1) the recomputation of the <a href="classinciter_1_1_a_l_e.html" class="m-dox">ALE</a> mesh velocity and (2) the recomputation of the boundary point-, and dual-face normals, due to moving and/or changing the topology of the mesh. (If there was a LHS, it would change if the mesh moved or the topology changed.) These two tasks are independent and so they happen on indepent execution threads. Both threads of execution progress through a series of steps also involving communication. When all tasks are complete, the runtime system continues execution of the chare as specified in the DAG in <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a>, in ALECG::merge():</p><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">mergelhs</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// The own and communication portion of the left-hand side is complete</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="c1">// Combine own and communicated contributions of normals</span>
  <span class="n">normfinal</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Disc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Initial</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Output initial conditions to file</span>
    <span class="n">writeFields</span><span class="p">(</span> <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkIndex_ALECG</span><span class="o">::</span><span class="n">start</span><span class="p">(),</span> <span class="n">thisProxy</span><span class="p">[</span><span class="n">thisIndex</span><span class="p">])</span> <span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">norm_complete</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>The own and communication contributions to the normal vectors are combined in <a href="classinciter_1_1_a_l_e_c_g.html#afd489606acd59f99f39326d31a66c89a" class="m-dox">ALECG::<wbr />normfinal()</a>. If ALECG::merge() is called during the initial setup, we first output the initial conditions into files then continue to starting the time stepping. If ALECG::merge() is called during time stepping, we wait for yet another thread of execution to complete, as indicated in <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a>, in <code>wait4mesh</code>, which resizes the data structures that change after a mesh refinement step.</p></section><section id="inciter_newscheme_class_stage"><h3><a href="#inciter_newscheme_class_stage">New time step stage</a></h3><p>When all of all necessary data structures have been recomputed after the optional <a href="namespace_a_m_r.html" class="m-dox">AMR</a> step, execution continues in <a href="classinciter_1_1_a_l_e_c_g.html#a603abfa2427e70b053d010e5d9675b4b" class="m-dox">ALECG::<wbr />stage()</a>, which starts a new time step stage if it is not the last Runge-Kutta stage.</p><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">stage</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// Evaluate whether to continue with next time step stage</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="c1">// Increment Runge-Kutta stage counter</span>
  <span class="o">++</span><span class="n">m_stage</span><span class="p">;</span>

  <span class="c1">// if not all Runge-Kutta stages complete, continue to next time stage,</span>
  <span class="c1">// otherwise output field data to file(s)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_stage</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="n">chBndGrad</span><span class="p">();</span> <span class="k">else</span> <span class="nf">out</span><span class="p">();</span>
<span class="p">}</span></pre><p>If it is the last Runge-Kutta stage, we optionally output results to file then continue to the next time step calling <a href="classinciter_1_1_a_l_e_c_g.html#a9145ab458253f1e45837d5f795d60d85" class="m-dox">ALECG::<wbr />next()</a>. Before continuing to a new time step, we optionally perform load balancing as well as saving a checkpoint, then test for the exit condition to see if time stepping is to be continued.</p></section></section><section id="inciter_newscheme_work"><h2><a href="#inciter_newscheme_work">6. Making it all work</a></h2><p>Only a couple of minor, but important, steps remain. First we add the new Charm++ module as an external module in inciter&#x27;s Charm++ module. This is required so that all Charm++ code that references the new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ chare array is visible and can correctly interact with Inciter&#x27;s main charm chare.</p><section id="inciter_newscheme_work_inciter_ci"><h3><a href="#inciter_newscheme_work_inciter_ci">Main/inciter.ci</a></h3><pre class="m-code">$ git diff src/Main/inciter.ci
<span class="gh">diff --git a/src/Main/inciter.ci b/src/Main/inciter.ci</span>
<span class="gh">index bf7eac98..e9b114b6 100644</span>
<span class="gd">--- a/src/Main/inciter.ci</span>
<span class="gi">+++ b/src/Main/inciter.ci</span>
<span class="gu">@@ -14,6 +14,7 @@ mainmodule inciter {</span>
   extern module partitioner;
   extern module matcg;
   extern module diagcg;
<span class="gi">+  extern module alecg;</span>
   extern module dg;
   extern module charestatecollector;</pre><p>The second, and final, step is to enable triggering the instantiation of specialized <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> class objects for our new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> scheme when the system of systems is instantiated. This associates the type of generic PDE systems that is used to instantiate the PDE classes, selected by user configuration. Since <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> will be a node-centered scheme, we assign it to use the <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> polymorphic interface (instead of <a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a>, which is tailored for cell-centered discretizations).</p></section><section id="inciter_newscheme_work_PDEStack"><h3><a href="#inciter_newscheme_work_PDEStack">PDE/PDEStack.cpp</a></h3><pre class="m-code">$ git diff src/PDE/PDEStack.cpp
<span class="gh">diff --git a/src/PDE/PDEStack.cpp b/src/PDE/PDEStack.cpp</span>
<span class="gh">index 438cb5e3..9b2e14e7 100644</span>
<span class="gd">--- a/src/PDE/PDEStack.cpp</span>
<span class="gi">+++ b/src/PDE/PDEStack.cpp</span>
<span class="gu">@@ -108,7 +108,9 @@ PDEStack::selectedCG() const</span>
   std::vector&lt; CGPDE &gt; pdes;                // will store instantiated PDEs

   const auto sch = g_inputdeck.get&lt; tag::discr, tag::scheme &gt;();
<span class="gd">-  if (sch == ctr::SchemeType::DiagCG) {</span>
<span class="gi">+  if (sch == ctr::SchemeType::DiagCG || sch == ctr::SchemeType::ALECG) {</span>

     for (const auto&amp; d : g_inputdeck.get&lt; tag::selected, tag::pde &gt;()) {
       if (d == ctr::PDEType::TRANSPORT)
         pdes.push_back( createCG&lt; tag::transport &gt;( d, cnt ) );
       else if (d == ctr::PDEType::COMPFLOW)
         pdes.push_back( createCG&lt; tag::compflow &gt;( d, cnt ) );
       else Throw( &quot;Can&#39;t find selected CGPDE&quot; );
     }

   }</pre></section></section><section id="inciter_newscheme_unittest"><h2><a href="#inciter_newscheme_unittest">7. Augment unit tests for Scheme</a></h2><p>Though this is not strictly necessary, we also augment the unit tests of <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> exercising our new discretization scheme:</p><pre class="m-code">$ git diff develop src/UnitTest/TUTSuite.hpp src/UnitTest/tests/Inciter/TestScheme.cpp
<span class="gh">diff --git a/src/UnitTest/TUTSuite.hpp b/src/UnitTest/TUTSuite.hpp</span>
<span class="gh">index 191b3972..dd904b02 100644</span>
<span class="gd">--- a/src/UnitTest/TUTSuite.hpp</span>
<span class="gi">+++ b/src/UnitTest/TUTSuite.hpp</span>
<span class="gu">@@ -61,7 +61,7 @@ class TUTSuite : public CBase_TUTSuite {</span>
         { &quot;Base/Factory&quot;, 2 }
       , { &quot;Base/PUPUtil&quot;, 14 }
       , { &quot;Base/Timer&quot;, 1 }
<span class="gd">-      , { &quot;Inciter/Scheme&quot;, 3 }</span>
<span class="gi">+      , { &quot;Inciter/Scheme&quot;, 4 }</span>
     };

     // Tests that must be run on PE 0
<span class="gh">diff --git a/src/UnitTest/tests/Inciter/TestScheme.cpp b/src/UnitTest/tests/Inciter/TestScheme.cpp</span>
<span class="gh">index 6dc48c75..e4acfce4 100644</span>
<span class="gd">--- a/src/UnitTest/tests/Inciter/TestScheme.cpp</span>
<span class="gi">+++ b/src/UnitTest/tests/Inciter/TestScheme.cpp</span>
<span class="gu">@@ -84,6 +84,8 @@ void Scheme_object::test&lt; 1 &gt;() {</span>
   ensure_equals( &quot;Underlying type&quot;, c.which(), 1 );
   inciter::Scheme d( inciter::ctr::SchemeType::DG );
   ensure_equals( &quot;Underlying type&quot;, d.which(), 2 );
<span class="gi">+  inciter::Scheme a( inciter::ctr::SchemeType::ALECG );</span>
<span class="gi">+  ensure_equals( &quot;Underlying type&quot;, a.which(), 3 );</span>
 }

 //! Test if operator[] returns the correct underlying type
<span class="gu">@@ -97,6 +99,8 @@ void Scheme_object::test&lt; 2 &gt;() {</span>
   ensure_equals( &quot;Underlying element type&quot;, c.which_element(), 1 );
   inciter::Scheme d( inciter::ctr::SchemeType::DG );
   ensure_equals( &quot;Underlying element type&quot;, d.which_element(), 2 );
<span class="gi">+  inciter::Scheme a( inciter::ctr::SchemeType::ALECG );</span>
<span class="gi">+  ensure_equals( &quot;Underlying element type&quot;, a.which_element(), 3 );</span>
 }

<span class="gu">@@ -162,6 +166,27 @@ void Scheme_object::test&lt; 5 &gt;() {</span>
     inciter::Scheme( inciter::ctr::SchemeType::DG ), 2, &quot;DG&quot; );
 }

<span class="gi">+//! Test Pack/Unpack of Scheme holding CProxy_AELCG</span>
<span class="gi">+//! \details Every Charm++ migration test, such as this one, consists of two</span>
<span class="gi">+//!   unit tests: one for send and one for receive. Both trigger a TUT test,</span>
<span class="gi">+//!   but the receive side is created manually, i.e., without the awareness of</span>
<span class="gi">+//!   the TUT library. Unfortunately thus, there is no good way to count up</span>
<span class="gi">+//!   these additional tests, and thus if a test such as this is added to the</span>
<span class="gi">+//!   suite this number must be updated in UnitTest/TUTSuite.hpp in</span>
<span class="gi">+//!   unittest::TUTSuite::m_migrations.</span>
<span class="gi">+template&lt;&gt; template&lt;&gt;</span>
<span class="gi">+void Scheme_object::test&lt; 6 &gt;() {</span>
<span class="gi">+  // This test spawns a new Charm++ chare. The &quot;1&quot; at the end of the test name</span>
<span class="gi">+  // signals that this is only the first part of this test: the part up to</span>
<span class="gi">+  // firing up an asynchronous Charm++ chare. The second part creates a new test</span>
<span class="gi">+  // result, sending it back to the suite if successful. If that chare never</span>
<span class="gi">+  // executes, the suite will hang waiting for that chare to call back.</span>
<span class="gi">+  set_test_name( &quot;Charm:migrate Scheme(ALECG) 1&quot; );</span>
<span class="gi">+</span>
<span class="gi">+  CProxy_Receiver::ckNew(</span>
<span class="gi">+    inciter::Scheme( inciter::ctr::SchemeType::ALECG ), 3, &quot;ALECG&quot; );</span>
<span class="gi">+}</span></pre><p>Now that we will test <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> using the unit test harness, <a href="unittest_main.html" class="m-dox">UnitTest</a>, we also have to make the UnitTest build target depend on the new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ module:</p><pre class="m-code">$ git diff src/UnitTest/CMakeLists.txt
<span class="gh">diff --git a/src/UnitTest/CMakeLists.txt b/src/UnitTest/CMakeLists.txt</span>
<span class="gh">index bb740285..e0ea47fe 100644</span>
<span class="gd">--- a/src/UnitTest/CMakeLists.txt</span>
<span class="gi">+++ b/src/UnitTest/CMakeLists.txt</span>
<span class="gu">@@ -48,6 +48,7 @@ add_dependencies(&quot;UnitTest&quot; &quot;unittestCharmModule&quot;)</span>
 if (ENABLE_INCITER)
   add_dependencies(&quot;UnitTest&quot; &quot;matcgCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;diagcgCharmModule&quot;)
<span class="gi">+  add_dependencies(&quot;UnitTest&quot; &quot;alecgCharmModule&quot;)</span>
   add_dependencies(&quot;UnitTest&quot; &quot;distfctCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;dgCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;discretizationCharmModule&quot;)</pre></section><section id="inciter_newscheme_regression"><h2><a href="#inciter_newscheme_regression">8. Add new regression tests</a></h2><p>Finally, we also add a bunch of new regression tests that stress-test the asynchronous logic in the discretization scheme classes:</p><pre class="m-code">$ git diff tests/regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt
<span class="gh">index b54a207d..62732129 100644</span>
<span class="gd">--- a/tests/regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt</span>
<span class="gi">+++ b/tests/regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt</span>
<span class="gu">@@ -1,7 +1,7 @@</span>
 # See cmake/add_regression_test.cmake for documentation on the arguments to
 # add_regression_test().

<span class="gd">-foreach(scheme matcg diagcg dg)</span>
<span class="gi">+foreach(scheme matcg diagcg dg alecg)</span>
   foreach(virt 0.0 0.5 0.9)
     foreach(npes RANGE 1 8)
       add_regression_test(asynclogic_${scheme}_${virt} ${INCITER_EXECUTABLE}</pre></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.org/quinoa.github.io+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.org/quinoa.github.io+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="http://quinoacomputing.org/quinoa.github.io/">Quinoa project</a>. Copyright © J. Bakosi 2012&ndash;2015, Los Alamos National Security, LLC, 2016&ndash;2018, <a href="https://www.triadns.org/">Triad National Security, LLC,</a> 2019-2021. Generated on Tuesday, Nov 23, 2021 based on <a href="https://github.com/quinoacomputing/quinoa/commit/7dc367005">7dc367005</a> by <a href="http://doxygen.org/">Doxygen</a> and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/">GitHub</a>, <a href="https://groups.io/g/quinoa">Email</a> or <a href="https://quinoa.zulipchat.com">Chat</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>