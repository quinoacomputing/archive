<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>How to add a new scheme to Inciter | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="5">
            <li>
              <a href="https://github.com/quinoacomputing/quinoa">GitHub</a>
              <ol>
                <li><a href="papers.html">Papers</a></li>
                <li><a href="coverage.html">Coverage</a></li>
                <li><a href="https://hub.docker.com/r/quinoacomputing/quinoa">Docker</a></li>
                <li><a href="https://travis-ci.org/quinoacomputing/quinoa/builds">Travis</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          How to add a new scheme to Inciter
        </h1>
<p><a href="inciter_main.html" class="m-dox">Inciter</a> supports multiple discretization schemes. This page describes how to add a scheme of your choice by walking through an example of adding a new one. We also discuss the main steps of the execution logic, which, at a high level, is the same for all discretization schemes.</p><section id="inciter_newscheme_rationale"><h2><a href="#inciter_newscheme_rationale">Rationale and plan</a></h2><p>Similar to the existing discretization schemes, <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>, <code><a href="classinciter_1_1_mat_c_g.html" class="m-dox">MatCG</a></code>, or <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>, the new scheme, <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> (short for Arbitrary Lagrangian-Eulerian Continuous Galerkin), will interact with <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> in a child-base fashion, e.g., will directly access (and reuse) its member data and functions. It will also intereact with <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>, for mesh refinement, and will also be migratable to enable dynamic load balancing. In essence, it will have everything an existing scheme has. However, we will <em>not</em> implement the low-level details of the actual numerical method, only the glue-code necessary to interact with the rest of the code and we make it ready to start implementing the low-level details of a particular discretization, done by a <code>PDE</code> class, held behind a derived class of, e.g., <code><a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a></code> or <code><a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a></code>. For more details on how these classes interact, see also the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page.</p></section><section id="inciter_newscheme_keyword"><h2><a href="#inciter_newscheme_keyword">1. Add a new keyword</a></h2><p>A specific discretization scheme is selected by the user in the control (input) file via the <code>scheme</code> keyword, e.g., <code>scheme diagcg</code>. We add the new keyword, <code>alecg</code>, which then can be recognized by the control file parser, in <code><a href="_keywords_8h.html" class="m-dox">src/<wbr />Control/<wbr />Keywords.h</a></code> by adding the following code block:</p><section id="inciter_newscheme_keyword_Keywords"><h3><a href="#inciter_newscheme_keyword_Keywords">Control/Keywords.h</a></h3><pre class="m-code">$ git diff src/Control/Keywords.h
<span class="gh">diff --git a/src/Control/Keywords.h b/src/Control/Keywords.h</span>
<span class="gh">index 002869cb..c18f193a 100644</span>
<span class="gd">--- a/src/Control/Keywords.h</span>
<span class="gi">+++ b/src/Control/Keywords.h</span>
<span class="gu">@@ -4607,6 +4607,19 @@ struct diagcg_info {</span>
 };
 using diagcg = keyword&lt; diagcg_info, TAOCPP_PEGTL_STRING(&quot;diagcg&quot;) &gt;;

<span class="gi">+struct alecg_info {</span>
<span class="gi">+  static std::string name() { return &quot;ALE-CG with RK&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return &quot;Select continuous Galerkin &quot;</span>
<span class="gi">+    &quot;with ALE + Runge-Kutta&quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to select the continuous Galerkin finite element</span>
<span class="gi">+    scheme in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined</span>
<span class="gi">+    with Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h</span>
<span class="gi">+    for other valid options.)&quot;; }</span>
<span class="gi">+};</span>
<span class="gi">+using alecg = keyword&lt; alecg_info, TAOCPP_PEGTL_STRING(&quot;alecg&quot;) &gt;;</span>
<span class="gi">+</span>
 struct dg_info {
   static std::string name() { return &quot;DG(P0) + RK&quot;; }
   static std::string shortDescription() { return</pre><p>We also add the new keyword to inciter&#x27;s grammar&#x27;s keywords pool:</p></section><section id="inciter_newscheme_keyword_InputDeck"><h3><a href="#inciter_newscheme_keyword_InputDeck">Control/Inciter/InputDeck/InputDeck.h</a></h3><pre class="m-code">$ git diff src/Control/Inciter/InputDeck/InputDeck.h
<span class="gh">diff --git a/src/Control/Inciter/InputDeck/InputDeck.h b/src/Control/Inciter/InputDeck/InputDeck.h</span>
<span class="gh">index 83572480..20ce8975 100644</span>
<span class="gd">--- a/src/Control/Inciter/InputDeck/InputDeck.h</span>
<span class="gi">+++ b/src/Control/Inciter/InputDeck/InputDeck.h</span>
<span class="gu">@@ -144,6 +144,7 @@ class InputDeck :</span>
                                    kw::scheme,
                                    kw::matcg,
                                    kw::diagcg,
<span class="gi">+                                   kw::alecg,</span>
                                    kw::dg,
                                    kw::dgp1,
                                    kw::flux,</pre><p>This is required so that the compiler can generate a database containing the help for all the keywords in the grammar understood by inciter&#x27;s control file parser. The above changes not only add the keyword but also some documentation that gets displayed when passing the <code>-C</code> or <code>-H</code> command line arguments to the inciter executable, so quick help is available at the user&#x27;s fingertips:</p><pre class="m-console">$ inciter -C
inciter Control File Keywords:
             advdiff     string Specify the advection + diffusion physics configuration for a PDE
           advection     string Specify the advection physics configuration for a PDE
               alecg            Select continuous Galerkin with ALE + Runge-Kutta
           algorithm     string Select mesh partitioning algorithm
               alpha       real Set PDE parameter(s) alpha
...
$ inciter -H alecg
inciter control file keyword &#39;alecg&#39;

   Select continuous Galerkin with ALE + Runge-Kutta (RK)

   This keyword is used to select the continuous Galerkin finite element scheme
   in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined with
   Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h for other
   valid options.</pre></section></section><section id="inciter_newscheme_option"><h2><a href="#inciter_newscheme_option">2. Add new option switch</a></h2><p>Next is to add a new state to the existing <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> option switch. This &quot;option
switch&quot; is really only a fancy enum, used to store the user&#x27;s choice of the discretization scheme after parsing the control file in a type-safe manner. This fancy enum is an option switch because it inherits from <a href="classtk_1_1_toggle.html" class="m-dox">tk::<wbr />Toggle</a>, defined in <a href="_toggle_8h.html" class="m-dox">Control/<wbr />Toggle.h</a>, which is a generic switch (or option), that helps associating enum values to keywords and querying one based on the other. Extending the existing <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> option switch is done by extending the list of schemes in <code><a href="_control_2_inciter_2_options_2_scheme_8h.html" class="m-dox">src/<wbr />Control/<wbr />Inciter/<wbr />Options/<wbr />Scheme.h</a></code>:</p><section id="inciter_newscheme_option_Scheme"><h3><a href="#inciter_newscheme_option_Scheme">Control/Inciter/Options/Scheme.h</a></h3><pre class="m-code">$ git diff src/Control/Inciter/Options/Scheme.h
<span class="gh">diff --git a/src/Inciter/SchemeBase.h b/src/Inciter/SchemeBase.h</span>
<span class="gh">index 61510d01..0cb3e9e8 100644</span>
<span class="gd">--- a/src/Inciter/SchemeBase.h</span>
<span class="gi">+++ b/src/Inciter/SchemeBase.h</span>
<span class="gu">@@ -22,6 +22,7 @@</span>

 #include &quot;NoWarning/matcg.decl.h&quot;
 #include &quot;NoWarning/diagcg.decl.h&quot;
<span class="gi">+#include &quot;NoWarning/alecg.decl.h&quot;</span>
 #include &quot;NoWarning/distfct.decl.h&quot;
 #include &quot;NoWarning/dg.decl.h&quot;
 #include &quot;NoWarning/discretization.decl.h&quot;
<span class="gu">@@ -52,8 +53,11 @@ class SchemeBase {</span>
         proxy = static_cast&lt; CProxy_DiagCG &gt;( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
       } else if (scheme == ctr::SchemeType::DG ||
<span class="gd">-                 scheme == ctr::SchemeType::DGP1) {</span>
<span class="gi">+                 scheme == ctr::SchemeType::DGP1)</span>
<span class="gi">+      {</span>
         proxy = static_cast&lt; CProxy_DG &gt;( CProxy_DG::ckNew(m_bound) );
<span class="gi">+      } else if (scheme == ctr::SchemeType::ALECG) {</span>
<span class="gi">+        proxy = static_cast&lt; CProxy_ALECG &gt;( CProxy_ALECG::ckNew(m_bound) );</span>
       } else Throw( &quot;Unknown discretization scheme&quot; );
     }

<span class="gu">@@ -75,11 +79,12 @@ class SchemeBase {</span>
     const CkArrayOptions&amp; arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
<span class="gd">-    using Proxy = boost::variant&lt; CProxy_MatCG, CProxy_DiagCG, CProxy_DG &gt;;</span>
<span class="gi">+    using Proxy =</span>
<span class="gi">+      boost::variant&lt; CProxy_MatCG, CProxy_DiagCG, CProxy_DG, CProxy_ALECG &gt;;</span>
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant&lt; CProxy_MatCG::element_t, CProxy_DiagCG::element_t,
<span class="gd">-                      CProxy_DG::element_t &gt;;</span>
<span class="gi">+                      CProxy_DG::element_t, CProxy_ALECG::element_t &gt;;</span>

   protected:
     //! Variant storing one proxy to which this class is configured for</pre></section></section><section id="inciter_newscheme_proxy"><h2><a href="#inciter_newscheme_proxy">3. Add new Charm++ chare proxy in Scheme</a></h2><p><code><a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a></code> is a class that, together with its base, <code><a href="classinciter_1_1_scheme_base.html" class="m-dox">SchemeBase</a></code>, implements concept-based runtime polymorphism for migratable Charm++ chare arrays using value semantics. Client code, e.g., <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, interacts with <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> and its children via a uniform interface provided by <code><a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a></code>, which dispatches entry method calls to the correct class instance, the base or the child, and is capable of performing broadcasts as well as addressing a particular chare array element. Read more details at <a href="_inciter_2_scheme_8h.html" class="m-dox">src/<wbr />Inciter/<wbr />Scheme.h</a>. To teach it to dispatch to our new <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> scheme, besides the existing ones, we make the following changes:</p><section id="inciter_newscheme_proxy_SchemeBase"><h3><a href="#inciter_newscheme_proxy_SchemeBase">Inciter/SchemeBase.h</a></h3><pre class="m-code">$ git diff src/Inciter/SchemeBase.h
<span class="gh">diff --git a/src/Inciter/SchemeBase.h b/src/Inciter/SchemeBase.h</span>
<span class="gh">index 61510d01..dea3d78a 100644</span>
<span class="gd">--- a/src/Inciter/SchemeBase.h</span>
<span class="gi">+++ b/src/Inciter/SchemeBase.h</span>
<span class="gu">@@ -22,6 +22,7 @@</span>

 #include &quot;NoWarning/matcg.decl.h&quot;
 #include &quot;NoWarning/diagcg.decl.h&quot;
<span class="gi">+#include &quot;NoWarning/alecg.decl.h&quot;</span>
 #include &quot;NoWarning/distfct.decl.h&quot;
 #include &quot;NoWarning/dg.decl.h&quot;
 #include &quot;NoWarning/discretization.decl.h&quot;
<span class="gu">@@ -51,6 +52,8 @@ class SchemeBase {</span>
       } else if (scheme == ctr::SchemeType::DiagCG) {
         proxy = static_cast&lt; CProxy_DiagCG &gt;( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
<span class="gi">+      } else if (scheme == ctr::SchemeType::ALECG) {</span>
<span class="gi">+        proxy = static_cast&lt; CProxy_ALECG &gt;( CProxy_ALECG::ckNew(m_bound) );</span>
       } else if (scheme == ctr::SchemeType::DG ||
                  scheme == ctr::SchemeType::DGP1) {
         proxy = static_cast&lt; CProxy_DG &gt;( CProxy_DG::ckNew(m_bound) );
<span class="gu">@@ -75,11 +78,12 @@ class SchemeBase {</span>
     const CkArrayOptions&amp; arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
<span class="gd">-    using Proxy = boost::variant&lt; CProxy_MatCG, CProxy_DiagCG, CProxy_DG &gt;;</span>
<span class="gi">+    using Proxy =</span>
<span class="gi">+      boost::variant&lt; CProxy_MatCG, CProxy_DiagCG, CProxy_ALECG, CProxy_DG &gt;;</span>
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant&lt; CProxy_MatCG::element_t, CProxy_DiagCG::element_t,
<span class="gd">-                      CProxy_DG::element_t &gt;;</span>
<span class="gi">+                      CProxy_ALECG::element_t, CProxy_DG::element_t &gt;;</span>

   protected:
     //! Variant storing one proxy to which this class is configured for</pre></section></section><section id="inciter_newscheme_chare"><h2><a href="#inciter_newscheme_chare">4. Add new Charm++ chare array</a></h2><p>Next is to add a new class, <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code>, which will serve as the glue between <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>, and <code><a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a></code>. These classes, respectively, are the driver, the mesh refiner, and the polymorphic vector of PDE discretization class objects that hold the low-level details of the numerical implementation of spatial discretizations, dispatching to multiple specific systems of equations, e.g., <code><a href="classinciter_1_1cg_1_1_transport.html" class="m-dox">cg::<wbr />Transport</a></code> or <code><a href="classinciter_1_1cg_1_1_comp_flow.html" class="m-dox">cg::<wbr />CompFlow</a></code>.</p><p>We create the following new files:</p><ul><li><a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a>, Charm++ interface file for <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>,</li><li><a href="alecg_8decl_8h.html" class="m-dox">NoWarning/<wbr />alecg.decl.h</a> and <a href="alecg_8def_8h.html" class="m-dox">NoWarning/<wbr />alecg.def.h</a>, which help ignore compiler warnings in Charm++-generated code, and</li><li><a href="_a_l_e_c_g_8h.html" class="m-dox">Inciter/<wbr />ALECG.h</a> and <a href="_a_l_e_c_g_8_c.html" class="m-dox">Inciter/<wbr />ALECG.C</a>, header and implementation of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>.</li></ul><p>Before we discuss the details of the above new files, let&#x27;s get a couple of simple things out of the way. We also need to add the new include to <code><a href="_refiner_8h.html" class="m-dox">Refiner.h</a></code> so, e.g., it can call back to <a href="classinciter_1_1_a_l_e_c_g.html#a6b7360cfb68a39d1414fc9f9ca1ae803" class="m-dox">ALECG::<wbr />resize()</a> after a mesh refinement step:</p><section id="inciter_newscheme_chare_Refiner"><h3><a href="#inciter_newscheme_chare_Refiner">Inciter/Refiner.h</a></h3><pre class="m-code">$ git diff src/Inciter/Refiner.h
<span class="gh">diff --git a/src/Inciter/Refiner.h b/src/Inciter/Refiner.h</span>
<span class="gh">index dfcb1ffd..4fe743a4 100644</span>
<span class="gd">--- a/src/Inciter/Refiner.h</span>
<span class="gi">+++ b/src/Inciter/Refiner.h</span>
<span class="gu">@@ -29,6 +29,7 @@</span>
 #include &quot;SchemeBase.h&quot;
 #include &quot;MatCG.h&quot;
 #include &quot;DiagCG.h&quot;
<span class="gi">+#include &quot;ALECG.h&quot;</span>
 #include &quot;DG.h&quot;

 #include &quot;NoWarning/transporter.decl.h&quot;</pre><p>We also tell the build system about our new <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> class and its Charm++ module:</p></section><section id="inciter_newscheme_chare_CMakeLists"><h3><a href="#inciter_newscheme_chare_CMakeLists">Inciter/CMakeLists.txt</a></h3><pre class="m-code">$ gd src/Inciter/CMakeLists.txt
<span class="gh">diff --git a/src/Inciter/CMakeLists.txt b/src/Inciter/CMakeLists.txt</span>
<span class="gh">index 141055ec..e339b65b 100644</span>
<span class="gd">--- a/src/Inciter/CMakeLists.txt</span>
<span class="gi">+++ b/src/Inciter/CMakeLists.txt</span>
<span class="gu">@@ -14,6 +14,7 @@ add_library(Inciter</span>
             Sorter.C
             MatCG.C
             DiagCG.C
<span class="gi">+            ALECG.C</span>
             DG.C
             FluxCorrector.C
             DistFCT.C
<span class="gu">@@ -74,6 +75,7 @@ addCharmModule( &quot;refiner&quot; &quot;Inciter&quot; )</span>
 addCharmModule( &quot;sorter&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;matcg&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;diagcg&quot; &quot;Inciter&quot; )
<span class="gi">+addCharmModule( &quot;alecg&quot; &quot;Inciter&quot; )</span>
 addCharmModule( &quot;distfct&quot; &quot;Inciter&quot; )
 addCharmModule( &quot;dg&quot; &quot;Inciter&quot; )</pre><p>The <code>addCharmModule</code> cmake macro above, defined in <code>cmake/charm.cmake</code>, ensures that build target <code>Inciter</code> will properly depend on our new <code>alecg</code> Charm++ module, defined in <code><a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a></code>. The macro also tells cmake how the two files, <code><a href="alecg_8decl_8h.html" class="m-dox">alecg.decl.h</a></code> and <code><a href="alecg_8def_8h.html" class="m-dox">alecg.def.h</a></code>, are generated from <code><a href="alecg_8ci.html" class="m-dox">alecg.ci</a></code>: using <code>charmc</code>, a compiler wrapper that generates Charm++-code to make the <code><a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a></code> from an ordinary C++ class into a Charm++ chare array, with <em>entry</em> methods callable across the network, make it migratable, enable its structured DAGger, etc. See also the <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">Charm++ manual</a>.</p><p>Now to the new files. First is the new Charm++ interface file, <a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a>:</p></section><section id="inciter_newscheme_chare_alecg"><h3><a href="#inciter_newscheme_chare_alecg">Inciter/alecg.ci</a></h3><p>This is the file that is parsed by Charm++&#x27;s compiler which then generates additional code that makes <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> a Charm++ chare array, makes it migratable, etc. The full listing is at <a href="inciter_newscheme_alecg_ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a> some of whose details are discussed below.</p><section id="inciter_newscheme_chare_alecg_headers"><h4><a href="#inciter_newscheme_chare_alecg_headers">Inciter/alecg.ci – External modules and header includes</a></h4><pre class="m-code">  extern module transporter;
  extern module discretization;

  include &quot;UnsMesh.h&quot;;
  include &quot;PUPUtil.h&quot;;
  include &quot;FaceData.h&quot;;</pre><p>First we declare some external Charm++ modules that <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> needs to interact with and thus from where we need type information. The <code>extern module</code> statements are followed by some usual C++ <code>include</code>s (without the <code>#</code>): these are in the Charm++ interface file because the Charm++ code below requires type information from them.</p></section><section id="inciter_newscheme_chare_alecg_array"><h4><a href="#inciter_newscheme_chare_alecg_array">Inciter/alecg.ci – 1D Charm++ chare array</a></h4><pre class="m-code">    array [1D] ALECG {</pre><p>Next comes the specification of the <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ chare array. This is a 1D array whose elements at runtime will be distributed across the available processing elements and compute nodes. If load balancing is enabled, the array elements (C++ objects) are migrated to homogenize load across a simulation. Because the array is 1D, we use a single integer index to address a particular array element. Charm++ also allows multi-dimensional arrays which can be useful if the problem naturally maps to a multi-dimensional notion, e.g., partitioning a 3D Cartesian mesh, so index calculations to address array elements (and thus work-units) become cleaner.</p></section><section id="inciter_newscheme_chare_alecg_entry"><h4><a href="#inciter_newscheme_chare_alecg_entry">Inciter/alecg.ci – Entry methods</a></h4><pre class="m-code">      entry ALECG( const CProxy_Discretization&amp; disc,
                   const tk::CProxy_Solver&amp; solver,
                   const FaceData&amp; fd );
      initnode void registerReducers();
      entry void setup( tk::real v );
      entry void dt();
      entry void diag();
      entry [reductiontarget] void advance( tk::real newdt );
      entry void comlhs( const std::vector&lt; std::size_t &gt;&amp; gid,
                         const std::vector&lt; std::vector&lt; tk::real &gt; &gt;&amp; L );
      entry void comrhs( const std::vector&lt; std::size_t &gt;&amp; gid,
                         const std::vector&lt; std::vector&lt; tk::real &gt; &gt;&amp; R );
      entry void resized();
      entry void lhs();</pre><p>We simply list those member functions of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> as <em>entry</em> methods, e.g., <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a> or <a href="classinciter_1_1_a_l_e_c_g.html#a5ff6f124c00f5ac180fc5c84d8531717" class="m-dox">ALECG::<wbr />dt()</a>, that we need to be able to call externally, potentially across the network, from another processing element (PE). Entry methods are always <em>public</em> in the C++ object-oriented programming (OOP) sense. Note that there can be other member functions of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>. These are simple C++ class member functions and are usually not <em>public</em> but <em>private</em>, such as <code><a href="classinciter_1_1_a_l_e_c_g.html#a416249274fefe5745c419388e786cda2" class="m-dox">ALECG::<wbr />rhs()</a></code>. Note also that there are <code>[reductiontarget]</code> entry methods, e.g., <code><a href="classinciter_1_1_a_l_e_c_g.html#a8471053d9f3da3a7a692876e3294f7fe" class="m-dox">ALECG::<wbr />advance()</a></code> which can be designated as the <em>target</em> entry method of a reduction operation across the chare array elements. There is also an <code>initnode</code> entry method, <code><a href="classinciter_1_1_a_l_e_c_g.html#ae1c431a552a76e269a3b35081557a70f" class="m-dox">ALECG::<wbr />registerReducers()</a></code> which is a special member function that is also declared as <em>static</em> in the C++ sense (see <a href="_a_l_e_c_g_8h.html" class="m-dox">ALECG.h</a>). This is static because the runtime system must be able to call this function without creating an object and a lot earlier than the actual <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> chare array elements are created. This is how <em>custom reducers</em> can be associated in Charm++ to a chare array. Such custom reducers are an excellent way to rely on the asynchronous, tree-based implementation of parallel reductions in Charm++ yet still do it on custom, arbitrarily complex data types, e.g., a hash-map that holds vectors, as long as one defines how aggregation is to be performed when merging such data. Such an example is given in <a href="_diag_reducer_8_c.html" class="m-dox">Inciter/<wbr />DiagReducer.C</a>.</p></section><section id="inciter_newscheme_chare_alecg_sdag"><h4><a href="#inciter_newscheme_chare_alecg_sdag">Inciter/alecg.ci – Structured DAG</a></h4><pre class="m-code">      entry void wait4lhs() {
        when ownlhs_complete(), comlhs_complete() serial &quot;lhs&quot; { lhsmerge(); } };

      entry void wait4rhs() {
        when ownrhs_complete(), comrhs_complete() serial &quot;rhs&quot; { solve(); } };

      entry void wait4eval() {
        when diag_complete(), ref_complete(), lhs_complete(),
             resize_complete() serial &quot;eval&quot; { eval(); } };

      entry void ownlhs_complete();
      entry void ownrhs_complete();
      entry void comlhs_complete();
      entry void comrhs_complete();
      entry void diag_complete();
      entry void ref_complete();
      entry void lhs_complete();
      entry void resize_complete();</pre><p>The entry methods, defined in the <code>.ci</code> file and with <code>when</code> keywords, form a structured directed acyclic graph (DAG). These specify logical relations among tasks and execution logic within the class. For example, <code>wait4lhs</code> tells the runtime system that only when <code>ownlhs_complete()</code> <em>and</em> <code>comlhs_complete()</code> are both done will <code>lhsmerge()</code> be called. In this case, this construct ensures that the runtime system will call a member function that operates on the left-hand side matrix, when both the local and external contributions are complete. Note that this logic only relates to a given array element, say with index 2. Another one, say index 3, may perform this operation at a very different time and independently, thus computation and communication can overlap. The entry methods listed at the bottom, e.g., <code>ownlhs_complete()</code> can be thought of as &quot;labels&quot; to the runtime systems that help define the task logic. These labels are functions that the runtime system defines and we call them when the given task is complete. Note that the construct we used here, when <strong>A</strong> <em>and</em> <strong>B</strong> are both complete <em>then</em> do <strong>C</strong>, is probably the simplest task-logic Charm++ allows prescribing. There are many more advanced ways of expressing such logic, e.g., using loops. For more details, see Section <em>Structured Control Flow: Structured Dagger</em> in the <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">Charm++ manual</a>.</p></section></section><section id="inciter_newscheme_nowarning"><h3><a href="#inciter_newscheme_nowarning">NoWarning/alecg.decl.h and NoWarning/alecg.def.h</a></h3><p>The newly added files to the <code>NoWarning/</code> directory simply include the Charm++-generated <code><a href="alecg_8decl_8h.html" class="m-dox">alecg.decl.h</a></code> and <code><a href="alecg_8def_8h.html" class="m-dox">alecg.def.h</a></code> files and locally, around the include, turn off specific compiler warnings for various compilers &ndash; we will not discuss them here further. Full listings are at <a href="inciter_newscheme_nowarning_page.html" class="m-dox">NoWarning/alecg.decl.h and NoWarning/alecg.def.h</a>.</p></section></section><section id="inciter_newscheme_class"><h2><a href="#inciter_newscheme_class">5. New C++ class</a></h2><p>Next are the newly added <a href="_a_l_e_c_g_8h.html" class="m-dox">Inciter/<wbr />ALECG.h</a> and <a href="_a_l_e_c_g_8_c.html" class="m-dox">Inciter/<wbr />ALECG.C</a>, header and implementation of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>. The full listings are at <a href="inciter_newscheme_header_page.html" class="m-dox">Inciter/<wbr />ALECG.h</a> and <a href="inciter_newscheme_class_page.html" class="m-dox">Inciter/<wbr />ALECG.C</a>, some of whose details are discussed below, rougly in order of execution.</p><section id="inciter_newscheme_class_constructor"><h3><a href="#inciter_newscheme_class_constructor">ALECG::ALECG – Constructor</a></h3><pre class="m-code"><span class="p">{</span>
  <span class="c1">//! Enable migration at AtSync</span>
  <span class="n">usesAtSync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Size communication buffers</span>
  <span class="n">resizeComm</span><span class="p">();</span>

  <span class="c1">// Signal the runtime system that the workers have been created</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">ckLocalBranch</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">created</span><span class="p">();</span>
<span class="p">}</span></pre><p>As discussed in Section <a href="inciter_design.html#inciter_create" class="m-dox">Creating workers</a> on the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page, the worker chare array elements, such as <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, are created using Charm++&#x27;s dynamic array insertion feature. This is an asynchronous call, issued from <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a>, and it signals the runtime system that it is time to start calling individual constructors of <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, passing them the appropriate data, required for each of them to initialize and operate on a mesh partition each is assigned (held by their companion <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a> &quot;base&quot; class). Thus running <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a> eventually triggers calling <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>&#x27;s constructors distributed across the whole problem and available PEs.</p><p>In the constructor&#x27;s body, listed above, we first enable migration for the class, then the local communication buffers are initialized by sizing them for the first time. Finally, we signal the runtime system that <em>extra</em> communication buffers, specific to this particular discretization scheme, have been created. This is a reduction call, issued by all array elements, eventually calling the reduction target <code><a href="classinciter_1_1_transporter.html#a4cf32a4f12fa595cda64a18bc59555f9" class="m-dox">Transporter::<wbr />comfinal()</a></code> a single time.</p><aside class="m-note m-info"><h4>Note</h4><p>By default, there are no extra communication buffers needed to be setup in <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, because the symmetric mesh-node communication maps have already been setup and stored in <a href="classinciter_1_1_discretization.html#a224467ec02477bcf1abc634fab1c7d90" class="m-dox">Discretization::<wbr />m_msum</a>, discussed in Section <a href="inciter_design.html#inciter_reorder" class="m-dox">Optional PE-locality mesh node reordering</a> on the <a href="inciter_design.html" class="m-dox">Inciter software design</a> page. This node communication map is made available to all discretization schemes by default. A counter-example to <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> is <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a> which, in this stage, sets up face communication and ghost element data structures, required only by the cell-centered <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>-style discretization. These <em>extra</em> communication data structures are stored in <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, i.e., locally in that class, but <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, just like <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> (and all other schemes) are expected to signal the end of such <em>extra</em> communication maps by issuing the reduction targeting <code><a href="classinciter_1_1_transporter.html#a4cf32a4f12fa595cda64a18bc59555f9" class="m-dox">Transporter::<wbr />comfinal()</a></code>.</p></aside></section><section id="inciter_newscheme_class_comfinal"><h3><a href="#inciter_newscheme_class_comfinal">Transporter::comfinal() – Complete communication maps</a></h3><pre class="m-code"><span class="p">{</span>
  <span class="n">CkStartLB</span><span class="p">();</span>  <span class="c1">// start load balancing</span>
  <span class="n">m_progWork</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="n">m_scheme</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span> <span class="n">m_V</span> <span class="p">);</span>
<span class="p">}</span></pre><p>Though asynchronously executed, the reduction operation targeting <code><a href="classinciter_1_1_transporter.html#a4cf32a4f12fa595cda64a18bc59555f9" class="m-dox">Transporter::<wbr />comfinal()</a></code> is a global synchronization point: all chares arrive in that function body, synchronized, and all continue from there again by calling <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a>.</p><aside class="m-note m-info"><h4>Note</h4><p>The call to <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a> is hidden behind <a href="classinciter_1_1_scheme.html#ad68802739cb0d487ff75a9575b20a644" class="m-dox">Scheme::<wbr />setup()</a>. In an OOP sense this is equivalent to calling a virtual member function on a reference or a pointer of the base class, <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, which then dispatches down to the child class member function <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a>.</p><p>Also note that the call to <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a>, <code>m_scheme.setup(m_V)</code>, does <em>not</em> address any particular chare array element, which means that it addresses <em>all</em> array elements. Its argument is sent to all elements (across the network) in a broadcast fashion.</p></aside><p><a href="classinciter_1_1_transporter.html#a4cf32a4f12fa595cda64a18bc59555f9" class="m-dox">Transporter::<wbr />comfinal()</a> is a global synchronization point because <em>all</em> worker chares must finish resizing and/or constructing their communication maps before their <code>setup()</code> member function can be invoked. This is because <code>setup()</code> starts using those communication maps, e.g., when it starts computing and assembling the left hand side matrix or vector. When a chare receives data from others this data must be correctly sized and ready on all chares before these data containers can be used. If a global synchronization point did not precede <code>setup()</code>, chares that finish their constructor early might go ahead all the way to calling <a href="classinciter_1_1_a_l_e_c_g.html#ae853fe4dab912c55febdaf0635a1b28d" class="m-dox">ALECG::<wbr />comlhs()</a>, which then will attempt to write to a communication buffer on the receiving side, which would lead to corrupt data and errors.</p></section><section id="inciter_newscheme_class_setup"><h3><a href="#inciter_newscheme_class_setup">ALECG::setup() – Set initial conditions and compute the left hand side</a></h3><pre class="m-code">  <span class="c1">// Activate SDAG waits for computing the left-hand side</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4lhs</span><span class="p">();</span>

  <span class="c1">// Compute left-hand side of PDEs</span>
  <span class="n">lhs</span><span class="p">();</span>

  <span class="c1">// Set initial conditions for all PDEs</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span> <span class="n">eq</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Coord</span><span class="p">(),</span> <span class="n">m_u</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">T</span><span class="p">()</span> <span class="p">);</span></pre><p>In the <a href="classinciter_1_1_a_l_e_c_g.html#af513c2c5df0c348b9334140a3a2b6203" class="m-dox">ALECG::<wbr />setup()</a> code snippet above we first tell the runtime system to start listening for the completion of tasks leading to computing the left-hand side (lhs). This is done by the call <code>wait4lhs()</code>, which activates the relevant part of the DAG, discussed above in Section <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a>. Then we call <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a> which starts by computing the own contribution of the lhs followed by sending out contributions to those chares the given chare shares at least a single mesh node with.</p></section><section id="inciter_newscheme_class_lhs"><h3><a href="#inciter_newscheme_class_lhs">ALECG::lhs() – Compute own and send lhs on chare-boundary</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">lhs</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// Compute the left-hand side of transport equations</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="c1">// Compute own portion of the lhs</span>
  <span class="c1">// m_lhs = ...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">Msum</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span>        <span class="c1">// in serial we are done</span>
    <span class="n">comlhs_complete</span><span class="p">();</span>
  <span class="k">else</span> <span class="c1">// send contributions of lhs to chare-boundary nodes to fellow chares</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Msum</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">n</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">m_lhs</span><span class="p">[</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">Lid</span><span class="p">(),</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="p">);</span>
      <span class="n">thisProxy</span><span class="p">[</span> <span class="n">n</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">comlhs</span><span class="p">(</span> <span class="n">n</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">l</span> <span class="p">);</span>
    <span class="p">}</span>

  <span class="n">ownlhs_complete</span><span class="p">();</span>
<span class="p">}</span></pre><p>As the above <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a> code snippet shows, to communicate the lhs first we check if the node communication map is empty. If so, we are running in serial and the communication part is a no-op &ndash; we call <code>comlhs_complete()</code> right away. If the map is not empty, we loop through the map and for each chare the given chare shares a node (or multiple nodes) with we collect the values of the lhs in those nodes into a vector and send it to the given destination chare. The send is done via the entry method function call <code>thisProxy[n.first].comlhs()</code>, which sends its arguments to chare id <code>n.first</code> in a point-point fashion.</p></section><section id="inciter_newscheme_class_comlhs"><h3><a href="#inciter_newscheme_class_comlhs">ALECG::comlhs() – Receive left hand side on chare boundary</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">comlhs</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">gid</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">L</span> <span class="p">)</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">//  Receive contributions to left-hand side diagonal matrix on chare-boundaries</span>
<span class="c1">//! \param[in] gid Global mesh node IDs at which we receive LHS contributions</span>
<span class="c1">//! \param[in] L Partial contributions of LHS to chare-boundary nodes</span>
<span class="c1">//! \details This function receives contributions to m_lhs, which stores the</span>
<span class="c1">//!   diagonal (lumped) mass matrix at mesh nodes. While m_lhs stores</span>
<span class="c1">//!   own contributions, m_lhsc collects the neighbor chare contributions during</span>
<span class="c1">//!   communication. This way work on m_lhs and m_lhsc is overlapped. The two</span>
<span class="c1">//!   are combined in lhsmerge().</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="n">Assert</span><span class="p">(</span> <span class="n">L</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">gid</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Size mismatch&quot;</span> <span class="p">);</span>

  <span class="k">using</span> <span class="n">tk</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">gid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">bid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Bid</span><span class="p">(),</span> <span class="n">gid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">Assert</span><span class="p">(</span> <span class="n">bid</span> <span class="o">&lt;</span> <span class="n">m_lhsc</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Indexing out of bounds&quot;</span> <span class="p">);</span>
    <span class="n">m_lhsc</span><span class="p">[</span> <span class="n">bid</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// When we have heard from all chares we communicate with, this chare is done</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_nlhs</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Msum</span><span class="p">().</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">m_nlhs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">comlhs_complete</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>The above code snippet from <a href="classinciter_1_1_a_l_e_c_g.html#ae853fe4dab912c55febdaf0635a1b28d" class="m-dox">ALECG::<wbr />comlhs()</a> shows the implementation of the receive side of the lhs communication step. The function receives two vectors: in <code>gid</code> the list of global node IDs and in <code>L</code> the list of lhs values, one for each scalar component of the number of equations solved (in a system of systems). The sizes of the two vectors must equal &ndash; this is the number of nodes we receive data for from one other chare. Then we loop over all incoming data, find the local IDs for the global IDs and store them by <em>adding</em> their contributions at each node received. As the comment says, when this chare has received all contributions it supposed to receive, we tell the runtime system that on this chare communication of the lhs is finished by calling <code>comlhs_cmplete()</code>. The completion condition is implemented via a counter, whose value is incremented upon each call to this function and testing its equality with the size of the symmetric node communication map (<a href="classinciter_1_1_discretization.html#a224467ec02477bcf1abc634fab1c7d90" class="m-dox">Discretization::<wbr />m_msum</a>), which has data for as many chares as many other chare a given chare must communicate with. As discussed in <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a>, when both own and communicated parts of the lhs are complete, the runtime system calls <code>lhsmerge</code>().</p></section><section id="inciter_newscheme_class_lhsmerge"><h3><a href="#inciter_newscheme_class_lhsmerge">ALECG::lhsmerge() – Merge left hand side and continue</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">lhsmerge</span><span class="p">()</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">// The own and communication portion of the left-hand side is complete</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="c1">// Combine own and communicated contributions to left hand side</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="c1">// Combine own and communicated contributions to LHS and ICs</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Bid</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Lid</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">blhsc</span> <span class="o">=</span> <span class="n">m_lhsc</span><span class="p">[</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span> <span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ncomp_t</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">c</span><span class="o">&lt;</span><span class="n">m_lhs</span><span class="p">.</span><span class="n">nprop</span><span class="p">();</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="n">m_lhs</span><span class="p">(</span><span class="n">lid</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="n">blhsc</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// Zero communication buffers for next time step</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">m_rhsc</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mf">0.0</span> <span class="p">);</span>

  <span class="c1">// Continue after lhs is complete</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_initial</span><span class="p">)</span> <span class="n">start</span><span class="p">();</span> <span class="k">else</span> <span class="nf">lhs_complete</span><span class="p">();</span>
<span class="p">}</span></pre><p>When the own and communicated contributions to the lhs are in place, the communication buffer for the lhs, <code><a href="classinciter_1_1_a_l_e_c_g.html#a8dbb06626fdc446cb92d05e9d54ae042" class="m-dox">ALECG::<wbr />m_lhsc</a></code>, is merged into <code><a href="classinciter_1_1_a_l_e_c_g.html#aa6b7b77764cbde2e472585526376876c" class="m-dox">ALECG::<wbr />m_lhs</a></code>. As the above code snippet of <a href="classinciter_1_1_a_l_e_c_g.html#a82ce412c9141edc2e322b3b3b00921f6" class="m-dox">ALECG::<wbr />lhsmerge()</a> shows, we loop through the global IDs of all chare-boundary nodes and add the received contributions to the lhs. After preparing (zeroing) the communication buffers for the right hand side (rhs), at the end of <a href="classinciter_1_1_a_l_e_c_g.html#a82ce412c9141edc2e322b3b3b00921f6" class="m-dox">ALECG::<wbr />lhsmerge()</a> we continue in different directions depending on whether this is the first step or we are during time stepping. If <code>lhsmerge()</code> was called during the first step, we call <a href="classinciter_1_1_a_l_e_c_g.html#a95226f468e03957134e16ac0857d32dd" class="m-dox">ALECG::<wbr />start()</a> but if it was called during time stepping, we just tell the runtime system that the lhs is complete. (This latter happens after a mesh refinement step, in which case we need to regenerate the lhs, and in that case, completing the lhs is only part of a DAG, <code>wait4eval</code>, waiting for multiple overlapping tasks, required for continuing.) <a href="classinciter_1_1_a_l_e_c_g.html#a95226f468e03957134e16ac0857d32dd" class="m-dox">ALECG::<wbr />start()</a> calls <a href="classinciter_1_1_a_l_e_c_g.html#a5ff6f124c00f5ac180fc5c84d8531717" class="m-dox">ALECG::<wbr />dt()</a>, which is the first step in a time step.</p></section><section id="inciter_newscheme_class_dt"><h3><a href="#inciter_newscheme_class_dt">ALECG::dt() – Start time step</a></h3><pre class="m-code">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">eq</span> <span class="p">:</span> <span class="n">g_cgpde</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">eqdt</span> <span class="o">=</span> <span class="n">eq</span><span class="p">.</span><span class="n">dt</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Coord</span><span class="p">(),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Inpoel</span><span class="p">(),</span> <span class="n">m_u</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">eqdt</span> <span class="o">&lt;</span> <span class="n">mindt</span><span class="p">)</span> <span class="n">mindt</span> <span class="o">=</span> <span class="n">eqdt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Scale smallest dt with CFL coefficient</span>
    <span class="n">mindt</span> <span class="o">*=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">cfl</span> <span class="o">&gt;</span><span class="p">();</span></pre><p>The above code snippet from <a href="classinciter_1_1_a_l_e_c_g.html#a5ff6f124c00f5ac180fc5c84d8531717" class="m-dox">ALECG::<wbr />dt()</a> shows a <code>for</code> loop that calls the the <code>dt()</code> member function of all types of PDEs configured by the user and finds the minimum size of the time step.</p><pre class="m-code">  <span class="c1">// Actiavate SDAG waits for time step</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4rhs</span><span class="p">();</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4eval</span><span class="p">();</span>

  <span class="c1">// Contribute to minimum dt across all chares the advance to next step</span>
  <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tk</span><span class="o">::</span><span class="n">real</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mindt</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">min_double</span><span class="p">,</span>
              <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkReductionTarget</span><span class="p">(</span><span class="n">Transporter</span><span class="p">,</span><span class="n">advance</span><span class="p">),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Tr</span><span class="p">())</span> <span class="p">);</span></pre><p>Once we have the time step size, we enable a couple of SDAG waits and issue a reduction to <a href="classinciter_1_1_transporter.html#a23be2074b17969fda70ebf9854920739" class="m-dox">Transporter::<wbr />advance()</a> which yields the global minimum across all chares then issues a broadcast to <a href="classinciter_1_1_a_l_e_c_g.html#a8471053d9f3da3a7a692876e3294f7fe" class="m-dox">ALECG::<wbr />advance()</a>. <code>advance()</code> saves the new time step in <code><a href="classinciter_1_1_discretization.html#ae72466ca58faefcd7876523b54782061" class="m-dox">Discretization::<wbr />m_dt</a></code>, which is the <em>master</em> copy, then calls <code><a href="classinciter_1_1_a_l_e_c_g.html#a416249274fefe5745c419388e786cda2" class="m-dox">ALECG::<wbr />rhs()</a></code>, which starts computing the right hand sides of all PDEs integrated.</p></section><section id="inciter_newscheme_class_rhs"><h3><a href="#inciter_newscheme_class_rhs">ALECG::rhs() &amp; ALECG::comrhs() – Compute and communicate right hand side</a></h3><p>Computing the right hand sides (rhs) of all PDE operators and communicating the rhs values in chare boundary nodes look exactly the same as the analogous functions for the lhs. When both the own and communicated contributions are complete on a chare, the runtime system calls <a href="classinciter_1_1_a_l_e_c_g.html#a778e4351bfc35c4a7c2943901c61830e" class="m-dox">ALECG::<wbr />solve()</a>, which first combines the own and received contributions then solves the system.</p></section><section id="inciter_newscheme_class_solve"><h3><a href="#inciter_newscheme_class_solve">ALECG::solve() – Solve, diagnostics, refine</a></h3><pre class="m-code">  <span class="c1">// Compute diagnostics, e.g., residuals</span>
  <span class="k">auto</span> <span class="n">diag_computed</span> <span class="o">=</span> <span class="n">m_diag</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">m_u</span> <span class="p">);</span>
  <span class="c1">// Increase number of iterations and physical time</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
  <span class="c1">// Signal that diagnostics have been computed (or in this case, skipped)</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diag_computed</span><span class="p">)</span> <span class="n">diag</span><span class="p">();</span>
  <span class="c1">// Optionally refine mesh</span>
  <span class="n">refine</span><span class="p">();</span></pre><p>The above code snippet shows what happens immediately after solving the linear system on a chare. First we compute <em>diagnostics</em>, which is a catch-all phrase for various norms and integral quantities, see <a href="_node_diagnostics_8_c.html" class="m-dox">Inciter/<wbr />NodeDiagnostics.C</a> for details. Note that computing diagnostics only happens every few time step, depending on user configuration. If <code>m_diag.compute()</code> returns true, diagnostics have been computed in this time step. If diagnostics have been computed, their correct values require global reduction operations, performing different aggregation operations depending on the value. As all reductions, diagnostics are also collected by <a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a>, this time in target <code><a href="classinciter_1_1_transporter.html#af0591f0f12756bf1e55ff667b15135a1" class="m-dox">Transporter::<wbr />diagnostics()</a></code>, which calls back, via a broadcast, to <a href="classinciter_1_1_a_l_e_c_g.html#a89ad70b670cf3f5a02a838a8dc5e0a0f" class="m-dox">ALECG::<wbr />diag()</a>, which signals, on the <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> chare, that diagnostics have been computed. If diagnostics have not been computed in this time step, we call <a href="classinciter_1_1_a_l_e_c_g.html#a89ad70b670cf3f5a02a838a8dc5e0a0f" class="m-dox">ALECG::<wbr />diag()</a> right away. Next we increase the number of iterations taken and update physical time on the master copies, <a href="classinciter_1_1_discretization.html#ad2dcf80e7e92dfb6e3d0c2e65cddce6d" class="m-dox">Discretization::<wbr />m_it</a> and <a href="classinciter_1_1_discretization.html#a458e3fe79e649e137936c4f393a4a9ba" class="m-dox">Discretization::<wbr />m_t</a>. This is followed by (optionally) refining the mesh, calling <a href="classinciter_1_1_a_l_e_c_g.html#a93854d65f466800cf4640608b11b7737" class="m-dox">ALECG::<wbr />refine()</a>.</p></section><section id="inciter_newscheme_class_refine"><h3><a href="#inciter_newscheme_class_refine">ALECG::refine() – Optionally refine mesh</a></h3><pre class="m-code">  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">dtref</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">amr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">dtref</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">dtfreq</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">amr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">dtfreq</span> <span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// if t&gt;0 refinement enabled and we hit the frequency</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dtref</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">It</span><span class="p">()</span> <span class="o">%</span> <span class="n">dtfreq</span><span class="p">))</span> <span class="p">{</span>   <span class="c1">// refine</span>

    <span class="n">d</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">dtref</span><span class="p">(</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">T</span><span class="p">(),</span> <span class="n">thisProxy</span><span class="p">,</span> <span class="n">m_fd</span><span class="p">.</span><span class="n">Bnode</span><span class="p">()</span> <span class="p">);</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">// do not refine</span>

    <span class="n">ref_complete</span><span class="p">();</span>
    <span class="n">lhs_complete</span><span class="p">();</span>
    <span class="n">resize_complete</span><span class="p">();</span>

  <span class="p">}</span></pre><p>The above snippet shows that mesh refinement happens only at every few time step with its frequency configured by the user. If the mesh is <em>not</em> refined, we simply enable the SDAG waits associated to the tasks of the mesh refinement step. If the mesh <em>is</em> refined, we call a member function of the mesh refiner object held by <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, <a href="classinciter_1_1_refiner.html#a8f113848bc8095d48d7af8ab40fdd4c5" class="m-dox">Refiner::<wbr />dtref()</a>, which when done, eventually calls back to <a href="classinciter_1_1_a_l_e_c_g.html#a6b7360cfb68a39d1414fc9f9ca1ae803" class="m-dox">ALECG::<wbr />resize()</a>, passing back the new mesh and associated data structures.</p></section><section id="inciter_newscheme_class_resize"><h3><a href="#inciter_newscheme_class_resize">ALECG::resize() – Resize data after mesh refinement</a></h3><pre class="m-code"><span class="kt">void</span>
<span class="n">ALECG</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span> <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Chunk</span><span class="o">&amp;</span> <span class="n">chunk</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coords</span><span class="o">&amp;</span> <span class="n">coord</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">Fields</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">msum</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span> <span class="p">)</span>
<span class="c1">// *****************************************************************************</span>
<span class="c1">//  Receive new mesh from Refiner</span>
<span class="c1">//! \param[in] chunk New mesh chunk (connectivity and global&lt;-&gt;local id maps)</span>
<span class="c1">//! \param[in] coord New mesh node coordinates</span>
<span class="c1">//! \param[in] u New solution on new mesh</span>
<span class="c1">//! \param[in] msum New node communication map</span>
<span class="c1">//! \param[in] bnode Map of boundary-node lists mapped to corresponding</span>
<span class="c1">//!   side set ids for this mesh chunk</span>
<span class="c1">// *****************************************************************************</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Disc</span><span class="p">();</span>

  <span class="c1">// Set flag that indicates that we are during time stepping</span>
  <span class="n">m_initial</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// Zero field output iteration count between two mesh refinement steps</span>
  <span class="n">m_itf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Increase number of iterations with mesh refinement</span>
  <span class="o">++</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">Itr</span><span class="p">();</span>

  <span class="c1">// Resize mesh data structures</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">resize</span><span class="p">(</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">msum</span> <span class="p">);</span>

  <span class="c1">// Update (resize) solution on new mesh</span>
  <span class="n">m_u</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>

  <span class="c1">// Resize auxiliary solution vectors</span>
  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">nprop</span> <span class="o">=</span> <span class="n">m_u</span><span class="p">.</span><span class="n">nprop</span><span class="p">();</span>
  <span class="n">m_du</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="n">nprop</span> <span class="p">);</span>
  <span class="n">m_lhs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="n">nprop</span> <span class="p">);</span>
  <span class="n">m_rhs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="n">nprop</span> <span class="p">);</span>

  <span class="c1">// Update physical-boundary node lists</span>
  <span class="n">m_fd</span><span class="p">.</span><span class="n">Bnode</span><span class="p">()</span> <span class="o">=</span> <span class="n">bnode</span><span class="p">;</span>

  <span class="c1">// Resize communication buffers</span>
  <span class="n">resizeComm</span><span class="p">();</span>

  <span class="c1">// Activate SDAG waits for re-computing the left-hand side</span>
  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4lhs</span><span class="p">();</span>

  <span class="n">ref_complete</span><span class="p">();</span>

  <span class="n">contribute</span><span class="p">(</span> <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkReductionTarget</span><span class="p">(</span><span class="n">Transporter</span><span class="p">,</span><span class="n">workresized</span><span class="p">),</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">Tr</span><span class="p">())</span> <span class="p">);</span>
<span class="p">}</span></pre><p>The above snippet shows <a href="classinciter_1_1_a_l_e_c_g.html#a6b7360cfb68a39d1414fc9f9ca1ae803" class="m-dox">ALECG::<wbr />resize()</a> called by <a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a> when it finished mesh refinement. Besides resizing the mesh-related data held locally by <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a>, e.g., <a href="classinciter_1_1_a_l_e_c_g.html#a8540cc3072f34976097cb58b7d7b1c1f" class="m-dox">ALECG::<wbr />m_u</a>, <a href="classinciter_1_1_a_l_e_c_g.html#a8f2a4307cbd0fe991fdeee665652c057" class="m-dox">ALECG::<wbr />m_du</a>, etc., as well as the communication buffers in <a href="classinciter_1_1_a_l_e_c_g.html#abd73f195a04d3796a1c7de6224fd336d" class="m-dox">ALECG::<wbr />resizeComm()</a>, we also call <a href="classinciter_1_1_discretization.html#a82e2e5232ee1b5ffdf43d2f07d6dd2a3" class="m-dox">Discretization::<wbr />resize()</a>, which resizes all mesh-related data structures in <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>. We also prepare for recomputing the lhs on the new mesh by enabling its SDAG wait, <code>wait4lhs()</code>. When all of this is done, we issue a reduction to <a href="classinciter_1_1_transporter.html#ae08121362d8b2e6d282e16a536022bf4" class="m-dox">Transporter::<wbr />workresized()</a>, which when called will mean that all workers have resized their data after mesh refinement. However, this is only one concurrent (asynchronous) thread of execution. Another one is started within <code>d-&gt;resize()</code>, which calls <a href="classinciter_1_1_discretization.html#a82e2e5232ee1b5ffdf43d2f07d6dd2a3" class="m-dox">Discretization::<wbr />resize()</a>, which eventually reduces to <a href="classinciter_1_1_transporter.html#a7a8464bc10e697c15ef8c91cc2857d3f" class="m-dox">Transporter::<wbr />discresized()</a>. When both of these independent threads finished, <a href="classinciter_1_1_transporter.html#ae109db4ea8f7f41d8ad6ed9e43df8206" class="m-dox">Transporter::<wbr />resized()</a> is called, see <code>Transporter::wait4resize()</code>. <a href="classinciter_1_1_transporter.html#ae109db4ea8f7f41d8ad6ed9e43df8206" class="m-dox">Transporter::<wbr />resized()</a> then starts two new asynchronous threads, issuing two broadcasts: one to <a href="classinciter_1_1_discretization.html#a9d7bd561b8e5fb137be128f0fea731b1" class="m-dox">Discretization::<wbr />vol()</a> and another one to <a href="classinciter_1_1_a_l_e_c_g.html#afd553a3a909e3c29e19108fc7ed3d00b" class="m-dox">ALECG::<wbr />lhs()</a>. The former recomputes the nodal volumes, stored in <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, while the latter recomputes the lhs stored in <a href="classinciter_1_1_a_l_e_c_g.html#aa6b7b77764cbde2e472585526376876c" class="m-dox">ALECG::<wbr />m_lhs</a>. Both of these threads require multiple steps and involve communication, but they are independent and thus we let the runtime system schedule them arbitrarily. The first thread, doing communication in parallel and going through <a href="classinciter_1_1_transporter.html#ae87bb2babf60c96fb7f73a47e89ce805" class="m-dox">Transporter::<wbr />vol()</a>, ends up in <a href="classinciter_1_1_transporter.html#ae365c2bbc1df40e0430f32194410a631" class="m-dox">Transporter::<wbr />totalvol()</a>. The second one, after recomputing and communicating the chare-boundary values of the lhs, ends up in <a href="classinciter_1_1_a_l_e_c_g.html#a82ce412c9141edc2e322b3b3b00921f6" class="m-dox">ALECG::<wbr />lhsmerge()</a>. Note that execution can arrive at both end-points, <a href="classinciter_1_1_transporter.html#ae365c2bbc1df40e0430f32194410a631" class="m-dox">Transporter::<wbr />totalvol()</a> and <a href="classinciter_1_1_a_l_e_c_g.html#a82ce412c9141edc2e322b3b3b00921f6" class="m-dox">ALECG::<wbr />lhsmerge()</a>, during setup, i.e., before time stepping, or during time stepping, due to code reuse. Thus both of these end-points check whether execution is before or during time stepping, indicated by the booleans <a href="classinciter_1_1_a_l_e_c_g.html#aabad82c7fbfdd2acde2a45d9b31a5d8b" class="m-dox">ALECG::<wbr />m_initial</a> and the one appearing as the function argument of <a href="classinciter_1_1_transporter.html#ae365c2bbc1df40e0430f32194410a631" class="m-dox">Transporter::<wbr />totalvol()</a>. During time stepping these bools are false, and <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> enables <code>lhs_complete()</code>, while <a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a> calls <a href="classinciter_1_1_a_l_e_c_g.html#a29637575b556dbecaa16189d4dad0f80" class="m-dox">ALECG::<wbr />resized()</a> which enables <code>resize_complete()</code>.</p><p>When all the end-of-time-step, independent threads have finished, we call <a href="classinciter_1_1_a_l_e_c_g.html#a9a1ee68ca2449612365db5e475406957" class="m-dox">ALECG::<wbr />eval()</a>, which decides whether we start a new time step or call <a href="classinciter_1_1_transporter.html#a28c19c72c7f603b49d32a6a05a0eedc6" class="m-dox">Transporter::<wbr />finish()</a> for terminating at the end of time stepping. These end-of-time-step threads are (1) computing diagnostics, discussed above, (2) mesh refinement (and resizing of <em>some</em> of the mesh data structures), (3) resized (complete resize of mesh data structures, i.e., also those that require communication, e.g., nodal volumes), and (4) recomputing the lhs. The code-snippet on <a href="alecg_8ci.html" class="m-dox">Inciter/<wbr />alecg.ci</a> in Section <a href="inciter_newscheme.html#inciter_newscheme_chare_alecg_sdag" class="m-dox">Inciter/alecg.ci &ndash; Structured DAG</a>, above shows the DAG that tells the runtime system this logic, involving the four tasks.</p></section></section><section id="inciter_newscheme_work"><h2><a href="#inciter_newscheme_work">6. Making it all work</a></h2><p>Only a couple of minor, but important, steps remain. First we add the new Charm++ module as an external module in inciter&#x27;s Charm++ module. This is required so that all Charm++ code that references the new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ chare array is visible and can correctly interact with Inciter&#x27;s main charm chare.</p><section id="inciter_newscheme_work_inciter_ci"><h3><a href="#inciter_newscheme_work_inciter_ci">Main/inciter.ci</a></h3><pre class="m-code">$ git diff src/Main/inciter.ci
<span class="gh">diff --git a/src/Main/inciter.ci b/src/Main/inciter.ci</span>
<span class="gh">index bf7eac98..e9b114b6 100644</span>
<span class="gd">--- a/src/Main/inciter.ci</span>
<span class="gi">+++ b/src/Main/inciter.ci</span>
<span class="gu">@@ -14,6 +14,7 @@ mainmodule inciter {</span>
   extern module partitioner;
   extern module matcg;
   extern module diagcg;
<span class="gi">+  extern module alecg;</span>
   extern module dg;
   extern module charestatecollector;</pre><p>The second, and final, step is to enable triggering the instantiation of specialized <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> class objects for our new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> scheme when the system of systems is instantiated. This associates the type of generic PDE systems that is used to instantiate the PDE classes, selected by user configuration. Since <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> will be a node-centered scheme, we assign it to use the <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> polymorphic interface (instead of <a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a>, which is tailored for cell-centered discretizations).</p></section><section id="inciter_newscheme_work_PDEStack"><h3><a href="#inciter_newscheme_work_PDEStack">PDE/PDEStack.C</a></h3><pre class="m-code">$ git diff src/PDE/PDEStack.C
<span class="gh">diff --git a/src/PDE/PDEStack.C b/src/PDE/PDEStack.C</span>
<span class="gh">index 438cb5e3..9b2e14e7 100644</span>
<span class="gd">--- a/src/PDE/PDEStack.C</span>
<span class="gi">+++ b/src/PDE/PDEStack.C</span>
<span class="gu">@@ -108,7 +108,9 @@ PDEStack::selectedCG() const</span>
   std::vector&lt; CGPDE &gt; pdes;                // will store instantiated PDEs

   const auto sch = g_inputdeck.get&lt; tag::discr, tag::scheme &gt;();
<span class="gd">-  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG) {</span>
<span class="gi">+  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG ||</span>
<span class="gi">+      sch == ctr::SchemeType::ALECG)</span>
<span class="gi">+  {</span>

     for (const auto&amp; d : g_inputdeck.get&lt; tag::selected, tag::pde &gt;()) {
       if (d == ctr::PDEType::TRANSPORT)
         pdes.push_back( createCG&lt; tag::transport &gt;( d, cnt ) );
       else if (d == ctr::PDEType::COMPFLOW)
         pdes.push_back( createCG&lt; tag::compflow &gt;( d, cnt ) );
       else Throw( &quot;Can&#39;t find selected CGPDE&quot; );
     }

   }</pre></section></section><section id="inciter_newscheme_unittest"><h2><a href="#inciter_newscheme_unittest">7. Augment unit tests for Scheme</a></h2><p>Though this is not strictly necessary, we also augment the unit tests of <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a> exercising our new discretization scheme:</p><pre class="m-code">$ git diff develop src/UnitTest/TUTSuite.h src/UnitTest/tests/Inciter/TestScheme.C
<span class="gh">diff --git a/src/UnitTest/TUTSuite.h b/src/UnitTest/TUTSuite.h</span>
<span class="gh">index 191b3972..dd904b02 100644</span>
<span class="gd">--- a/src/UnitTest/TUTSuite.h</span>
<span class="gi">+++ b/src/UnitTest/TUTSuite.h</span>
<span class="gu">@@ -61,7 +61,7 @@ class TUTSuite : public CBase_TUTSuite {</span>
         { &quot;Base/Factory&quot;, 2 }
       , { &quot;Base/PUPUtil&quot;, 14 }
       , { &quot;Base/Timer&quot;, 1 }
<span class="gd">-      , { &quot;Inciter/Scheme&quot;, 3 }</span>
<span class="gi">+      , { &quot;Inciter/Scheme&quot;, 4 }</span>
     };

     // Tests that must be run on PE 0
<span class="gh">diff --git a/src/UnitTest/tests/Inciter/TestScheme.C b/src/UnitTest/tests/Inciter/TestScheme.C</span>
<span class="gh">index 6dc48c75..e4acfce4 100644</span>
<span class="gd">--- a/src/UnitTest/tests/Inciter/TestScheme.C</span>
<span class="gi">+++ b/src/UnitTest/tests/Inciter/TestScheme.C</span>
<span class="gu">@@ -84,6 +84,8 @@ void Scheme_object::test&lt; 1 &gt;() {</span>
   ensure_equals( &quot;Underlying type&quot;, c.which(), 1 );
   inciter::Scheme d( inciter::ctr::SchemeType::DG );
   ensure_equals( &quot;Underlying type&quot;, d.which(), 2 );
<span class="gi">+  inciter::Scheme a( inciter::ctr::SchemeType::ALECG );</span>
<span class="gi">+  ensure_equals( &quot;Underlying type&quot;, a.which(), 3 );</span>
 }

 //! Test if operator[] returns the correct underlying type
<span class="gu">@@ -97,6 +99,8 @@ void Scheme_object::test&lt; 2 &gt;() {</span>
   ensure_equals( &quot;Underlying element type&quot;, c.which_element(), 1 );
   inciter::Scheme d( inciter::ctr::SchemeType::DG );
   ensure_equals( &quot;Underlying element type&quot;, d.which_element(), 2 );
<span class="gi">+  inciter::Scheme a( inciter::ctr::SchemeType::ALECG );</span>
<span class="gi">+  ensure_equals( &quot;Underlying element type&quot;, a.which_element(), 3 );</span>
 }

 //! Test Pack/Unpack of Scheme holding CProxy_MatCG
<span class="gu">@@ -162,6 +166,27 @@ void Scheme_object::test&lt; 5 &gt;() {</span>
     inciter::Scheme( inciter::ctr::SchemeType::DG ), 2, &quot;DG&quot; );
 }

<span class="gi">+//! Test Pack/Unpack of Scheme holding CProxy_AELCG</span>
<span class="gi">+//! \details Every Charm++ migration test, such as this one, consists of two</span>
<span class="gi">+//!   unit tests: one for send and one for receive. Both trigger a TUT test,</span>
<span class="gi">+//!   but the receive side is created manually, i.e., without the awareness of</span>
<span class="gi">+//!   the TUT library. Unfortunately thus, there is no good way to count up</span>
<span class="gi">+//!   these additional tests, and thus if a test such as this is added to the</span>
<span class="gi">+//!   suite this number must be updated in UnitTest/TUTSuite.h in</span>
<span class="gi">+//!   unittest::TUTSuite::m_migrations.</span>
<span class="gi">+template&lt;&gt; template&lt;&gt;</span>
<span class="gi">+void Scheme_object::test&lt; 6 &gt;() {</span>
<span class="gi">+  // This test spawns a new Charm++ chare. The &quot;1&quot; at the end of the test name</span>
<span class="gi">+  // signals that this is only the first part of this test: the part up to</span>
<span class="gi">+  // firing up an asynchronous Charm++ chare. The second part creates a new test</span>
<span class="gi">+  // result, sending it back to the suite if successful. If that chare never</span>
<span class="gi">+  // executes, the suite will hang waiting for that chare to call back.</span>
<span class="gi">+  set_test_name( &quot;Charm:migrate Scheme(ALECG) 1&quot; );</span>
<span class="gi">+</span>
<span class="gi">+  CProxy_Receiver::ckNew(</span>
<span class="gi">+    inciter::Scheme( inciter::ctr::SchemeType::ALECG ), 3, &quot;ALECG&quot; );</span>
<span class="gi">+}</span></pre><p>Now that we will test <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> using the unit test harness, <a href="unittest_main.html" class="m-dox">UnitTest</a>, we also have to make the UnitTest build target depend on the new <a href="classinciter_1_1_a_l_e_c_g.html" class="m-dox">ALECG</a> Charm++ module:</p><pre class="m-code">$ git diff src/UnitTest/CMakeLists.txt
<span class="gh">diff --git a/src/UnitTest/CMakeLists.txt b/src/UnitTest/CMakeLists.txt</span>
<span class="gh">index bb740285..e0ea47fe 100644</span>
<span class="gd">--- a/src/UnitTest/CMakeLists.txt</span>
<span class="gi">+++ b/src/UnitTest/CMakeLists.txt</span>
<span class="gu">@@ -48,6 +48,7 @@ add_dependencies(&quot;UnitTest&quot; &quot;unittestCharmModule&quot;)</span>
 if (ENABLE_INCITER)
   add_dependencies(&quot;UnitTest&quot; &quot;matcgCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;diagcgCharmModule&quot;)
<span class="gi">+  add_dependencies(&quot;UnitTest&quot; &quot;alecgCharmModule&quot;)</span>
   add_dependencies(&quot;UnitTest&quot; &quot;distfctCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;dgCharmModule&quot;)
   add_dependencies(&quot;UnitTest&quot; &quot;discretizationCharmModule&quot;)</pre></section><section id="inciter_newscheme_regression"><h2><a href="#inciter_newscheme_regression">8. Add new regression tests</a></h2><p>We also add a bunch of new regression tests that stress-test the asynchronous logic in the discretization scheme classes:</p><pre class="m-code">$ git diff regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt
<span class="gh">index b54a207d..62732129 100644</span>
<span class="gd">--- a/regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt</span>
<span class="gi">+++ b/regression/inciter/transport/SlotCyl/asynclogic/CMakeLists.txt</span>
<span class="gu">@@ -1,7 +1,7 @@</span>
 # See cmake/add_regression_test.cmake for documentation on the arguments to
 # add_regression_test().

<span class="gd">-foreach(scheme matcg diagcg dg)</span>
<span class="gi">+foreach(scheme matcg diagcg dg alecg)</span>
   foreach(virt 0.0 0.5 0.9)
     foreach(npes RANGE 1 8)
       add_regression_test(asynclogic_${scheme}_${virt} ${INCITER_EXECUTABLE}</pre></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="http://quinoacomputing.org/">Quinoa project</a>. Copyright © J. Bakosi 2012&ndash;2015, <a href="http://www.lansllc.com/">Los Alamos National Security, LLC,</a> 2016&ndash;2018.<br />Generated on Friday, Nov 23, 2018 based on <a href="https://github.com/quinoacomputing/quinoa/commit/b58e08c">b58e08c</a> by <a href="http://doxygen.org/">Doxygen</a> 1.8.15 and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/">GitHub</a>, <a href="mailto:quinoa@lanl.gov">Email</a> or <a href="https://gitter.im/quinoacomputing/quinoa">Gitter</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>