<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/Partitioner.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_606df7a4664720c111e6e5b0e11c4e03.html">Inciter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Partitioner.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Charm++ chare partitioner group used to perform mesh partitioning.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &quot;<a class="el" href="_exodus_i_i_mesh_reader_8h_source.html">ExodusIIMeshReader.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_zoltan_inter_op_8h_source.html">ZoltanInterOp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_inciter_2_input_deck_2_input_deck_8h_source.html">Inciter/InputDeck/InputDeck.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_partitioning_algorithm_8h_source.html">Options/PartitioningAlgorithm.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_solver_8h_source.html">Solver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_derived_data_8h_source.html">DerivedData.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_uns_mesh_8h_source.html">UnsMesh.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mesh__adapter_8h_source.html">AMR/mesh_adapter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_face_data_8h_source.html">FaceData.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="partitioner_8decl_8h_source.html">NoWarning/partitioner.decl.h</a>&quot;</code><br />
</div>
<p><a href="_partitioner_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_partitioner.html">inciter::Partitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinciter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinciter.html">inciter</a></td></tr>
<tr class="memdesc:namespaceinciter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inciter declarations and definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Charm++ chare partitioner group used to perform mesh partitioning. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.</dd></dl>
<p>Charm++ chare partitioner group used to perform mesh partitioning.</p>
<p>The implementation uses the Charm++ runtime system and is fully asynchronous, overlapping computation, communication as well as I/O. The algorithm utilizes the structured dagger (SDAG) Charm++ functionality. The high-level overview of the algorithm structure and how it interfaces with Charm++ is discussed in the Charm++ interface file <a class="el" href="partitioner_8ci.html">src/Inciter/partitioner.ci</a>.</p>
<h4>Call graph</h4>
<p>The following is a directed acyclic graph (DAG) that outlines the asynchronous algorithm implemented in this class The detailed discussion of the algorithm is given in the Charm++ interface file <a class="el" href="partitioner_8ci.html">partitioner.ci</a>, which also repeats the graph below using ASCII graphics. On the DAG orange fills denote global synchronization points, orange frames with white fill are partial synchronization points that overlap with other tasks, and dashed lines are potential shortcuts that allow jumping over some of the task-graph under some circumstances. See the detailed discussion in <a class="el" href="partitioner_8ci.html">partitioner.ci</a>. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="563" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
 <div class="fragment"><div class="line">// *****************************************************************************</div><div class="line">/*!</div><div class="line">  \file      src/Inciter/partitioner.ci</div><div class="line">  \copyright 2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.</div><div class="line">  \brief     Charm++ module interface file for the chare partitioner group</div><div class="line">  \details   Charm++ module interface file for the chare partitioner group used</div><div class="line">             to perform mesh partitioning.</div><div class="line">*/</div><div class="line">// *****************************************************************************</div><div class="line"></div><div class="line">module partitioner {</div><div class="line"></div><div class="line">  include &quot;Types.h&quot;;</div><div class="line">  include &quot;UnsMesh.h&quot;;</div><div class="line">  include &quot;Scheme.h&quot;;</div><div class="line">  include &quot;FaceData.h&quot;;</div><div class="line"></div><div class="line">  extern module transporter;</div><div class="line"></div><div class="line">  namespace inciter {</div><div class="line"></div><div class="line">    group Partitioner {</div><div class="line">      entry Partitioner(</div><div class="line">        const std::vector&lt; CkCallback &gt;&amp; cb,</div><div class="line">        const CProxy_Transporter&amp; host,</div><div class="line">        const tk::CProxy_Solver&amp; solver,</div><div class="line">        const CProxy_BoundaryConditions&amp; bc,</div><div class="line">        const Scheme&amp; scheme,</div><div class="line">        std::size_t nbfac,</div><div class="line">        const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt;&amp; bface,</div><div class="line">        const std::vector&lt; std::size_t &gt;&amp; triinpoel );</div><div class="line">      entry void partition( int nchare );</div><div class="line">      entry void add( int frompe,</div><div class="line">            const std::unordered_map&lt; int, std::vector&lt; std::size_t &gt; &gt;&amp; elem );</div><div class="line">      entry void recv();</div><div class="line">      entry void flatten();</div><div class="line">      entry void offset( int pe, std::size_t u );</div><div class="line">      entry void request( int pe, const std::unordered_set&lt; std::size_t &gt;&amp; nd );</div><div class="line">      entry void request( int pe, const tk::UnsMesh::Edges&amp; ed );</div><div class="line">      entry void neworder(</div><div class="line">                   const std::unordered_map&lt; std::size_t, std::size_t &gt;&amp; nd );</div><div class="line">      entry void neworder( const tk::UnsMesh::EdgeNodes&amp; ed );</div><div class="line">      entry void lower( std::size_t low );</div><div class="line">      entry void stdCost( tk::real av );</div><div class="line">      entry void gather();</div><div class="line">      entry void query( int pe,</div><div class="line">                        const std::set&lt; std::size_t &gt;&amp; nodes,</div><div class="line">                        const tk::UnsMesh::Edges&amp; edges );</div><div class="line">      entry void mask( int pe,</div><div class="line">                       const std::unordered_map&lt; std::size_t,</div><div class="line">                                                 std::vector&lt; int &gt; &gt;&amp; cn,</div><div class="line">                       tk::UnsMesh::EdgeChares&amp; ce );</div><div class="line">      entry void createWorkers();</div><div class="line"></div><div class="line">      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/</div><div class="line">      // charm++/manual.html, Sec. &quot;Structured Control Flow: Structured Dagger&quot;.</div><div class="line"></div><div class="line">      // High-level overview of the dependency and asynchronous call structure</div><div class="line">      // ---------------------------------------------------------------------</div><div class="line">      //</div><div class="line">      // Directed Acyclic Graph (DAG):        DAG legend:</div><div class="line">      // -----------------------------          Own - Owned nodes reordered</div><div class="line">      //                                        Req - Node IDs requested</div><div class="line">      // Own --  Pre -- Ord -- Low ---  Cre     Pre - Start preparing nodes IDs</div><div class="line">      //       /         | \           /  |     Ord - Nodes reordered</div><div class="line">      // Req -           |   -- Upp ---  /      Low - Lower bound received</div><div class="line">      //                  \             /       Upp - Upper bound computed</div><div class="line">      //                    -- Par ----         Cre - Create workers</div><div class="line">      //                                        Par - Partitioners participated</div><div class="line">      //</div><div class="line">      // Interpretation of the above DAG</div><div class="line">      // -------------------------------</div><div class="line">      // Control flow is from left to right and top to bottom. As the above</div><div class="line">      // graph shows, we wait for both Own and Req conditions to be complete</div><div class="line">      // before we start preparing node IDs for the requestor.</div><div class="line">      //</div><div class="line">      // Reordering of node IDs consists of two main parts: (1) Reordering those</div><div class="line">      // nodes that are unique on our PE, i.e., do not exist on any other PE.</div><div class="line">      // These nodes can be assigned a new node ID without any communication.</div><div class="line">      // (2) Reordering those nodes that connect to mesh cells on other PEs.</div><div class="line">      // Assignment of new node IDs, i.e., reordering, must be handled in a way</div><div class="line">      // that the same new node IDs will be assigned to the nodes that are</div><div class="line">      // physically the same but happen to exist on other PEs as well as on</div><div class="line">      // ours.</div><div class="line">      //</div><div class="line">      // Accordingly, reordering starts with the owned, i.e., independently</div><div class="line">      // reordered nodes, on each PE. When that is done, Own is triggered,</div><div class="line">      // signaling that the new order for the owned nodes are ready to be</div><div class="line">      // queried. On another path, every PE immediately sends out requests to</div><div class="line">      // fellow PEs for nodes that they cannot reorder by themselves. However,</div><div class="line">      // those can only be sent back when the PE they are requested from has</div><div class="line">      // finished reordering (i.e., assigning new IDs to) them, so we wait until</div><div class="line">      // Own is satisfied on that PE. Req is triggered when a PE has received a</div><div class="line">      // request. Only when Own and Req are both satisfied do we need to prepare</div><div class="line">      // a set of new node IDs for a requestor, hence the above logic in the</div><div class="line">      // SDAG. Since there can be multiple requests arriving before any (or some</div><div class="line">      // or all) of them can be satisfied, the requests are queued into a vector</div><div class="line">      // and when the runtime system calls prepare(), we fullfill all requests,</div><div class="line">      // clear the queue, and automatically re-enable the trigger for Own, i.e.,</div><div class="line">      // wait only for Req, i.e., new requests.</div><div class="line">      //</div><div class="line">      // The second part of the graph, only happens after reordering is done,</div><div class="line">      // after the mesh reordering has been completed, and started by a call to</div><div class="line">      // bounds() inside reordered(). Ord is a partial synchronization point,</div><div class="line">      // because it happens at different times on different PEs.</div><div class="line"></div><div class="line">      // First the upper bounds of the node IDs are computed on each PE, and</div><div class="line">      // once that is done the lower bounds are communicated among the fellow</div><div class="line">      // Partitioner branches, since the lower bound of PE n is the upper bound</div><div class="line">      // of PE n-1. Only when both upper and lower bounds have been stored on a</div><div class="line">      // PE, can worker chare array elements be inserted, done in create().</div><div class="line">      // Initiation of estimating the average and standard deviation of the</div><div class="line">      // communication cost of merging the linear system is done in the</div><div class="line">      // beginning of create(), which starts two reductions, which must be done</div><div class="line">      // after each other: the first one accumulates the sum of the cost from</div><div class="line">      // each PE, and once the average is available on Transporter, a second</div><div class="line">      // round accumulates the variances back to Transporter.</div><div class="line">      //</div><div class="line">      // While the tasks carried out as described in the previous paragraph lead</div><div class="line">      // to correct results, there is an additional trigger, _participated_,</div><div class="line">      // denoted by Par, that needs to be enabled before create() is called. The</div><div class="line">      // role of Par is to make sure that all PEs participate in the</div><div class="line">      // distribution of new (reordered) mesh node IDs during reordering. In</div><div class="line">      // particular, since PE 0 has nothing to receive from others, if this</div><div class="line">      // trigger is not in place, PE 0 goes ahead of every other PE and calls</div><div class="line">      // create() which calls Worker constructors, a potentially heavy function.</div><div class="line">      // This is undesired at this point since PE 0 will surely need to answer</div><div class="line">      // to requests from other PEs with new node IDs, which can only be done</div><div class="line">      // (if the participated trigger is not in place) when the Workers have</div><div class="line">      // been created. This introduces unnecessary delays and load imbalance</div><div class="line">      // during reordering. Thus requiring participated_complete() in addition</div><div class="line">      // to lower and upper, delays creating of Workers. As a result, PE 0 is</div><div class="line">      // ready for requests from other PEs for new node IDs earlier than without</div><div class="line">      // the participate trigger, which yields a lot tighter CPU utilization</div><div class="line">      // during reordering. The participated trigger is enabled in two places:</div><div class="line">      // (1) in prepare(), i.e., if a PE had to prepare some of its new node IDs</div><div class="line">      // for others, and (2) in neworder(), i.e., if a PE had to receive new</div><div class="line">      // node IDs from others. Thus node reordering is only considered complete</div><div class="line">      // if every PE has participated in communication of the new node IDs.</div><div class="line">      //</div><div class="line">      // Note that Pre, Ord, and Cre are partial synchronization points: while</div><div class="line">      // Pre always happens before Ord, and Cre on the same PE, they happen at</div><div class="line">      // different times on different PEs, so these are not considered global</div><div class="line">      // synchronization points.</div><div class="line">      //</div><div class="line">      // Note that the above logic changes very little if initial uniform mesh</div><div class="line">      // refinement is performed. That happens in flatten(), which is always</div><div class="line">      // after the the initial mesh partitioning but before global distributed</div><div class="line">      // mesh node reordering. When nodes are to be sent during reordering,</div><div class="line">      // edge-nodes are also sent and while edge-nodes are stored in different</div><div class="line">      // data structures, the logic remains the same as used for the</div><div class="line">      // communication of nodes.</div><div class="line"></div><div class="line">      entry void wait4prep() {</div><div class="line">        when reorderowned_complete(), nodes_requested_complete()</div><div class="line">        serial &quot;prepare&quot; { prepare(); }</div><div class="line">      };</div><div class="line"></div><div class="line">      entry void wait4reorder() {</div><div class="line">        when nodesreorder_complete(), edgesreorder_complete()</div><div class="line">        serial &quot;reordered&quot; { reordered(); }</div><div class="line">      };</div><div class="line"></div><div class="line">      entry void wait4bounds() {</div><div class="line">        when lower_complete(), upper_complete(), participated_complete()</div><div class="line">        serial &quot;create&quot; { create(); }</div><div class="line">      };</div><div class="line"></div><div class="line">      entry void reorderowned_complete();</div><div class="line">      entry void nodes_requested_complete();</div><div class="line">      entry void nodesreorder_complete();</div><div class="line">      entry void edgesreorder_complete();</div><div class="line">      entry void lower_complete();</div><div class="line">      entry void upper_complete();</div><div class="line">      entry void participated_complete();</div><div class="line">    };</div><div class="line"></div><div class="line">  } // inciter::</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="_partitioner_8h_source.html">Partitioner.h</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 2 2018 13:52:01 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
