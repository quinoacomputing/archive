<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/q/quinoa/src/Inciter/Partitioner.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_606df7a4664720c111e6e5b0e11c4e03.html">Inciter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Partitioner.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Charm++ chare partitioner group used to perform mesh partitioning.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &quot;<a class="el" href="_exodus_i_i_mesh_reader_8h_source.html">ExodusIIMeshReader.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_zoltan_inter_op_8h_source.html">ZoltanInterOp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_inciter_2_input_deck_2_input_deck_8h_source.html">Inciter/InputDeck/InputDeck.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_partitioning_algorithm_8h_source.html">Options/PartitioningAlgorithm.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_lin_sys_merger_8h_source.html">LinSysMerger.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="partitioner_8def_8h_source.html">NoWarning/partitioner.def.h</a>&quot;</code><br />
</div>
<p><a href="_partitioner_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_partitioner.html">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinciter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinciter.html">inciter</a></td></tr>
<tr class="memdesc:namespaceinciter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inciter declarations and definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_partitioner_8h.html#a6ec0c67374eb34a66c0f5ca4ecd7d163">CK_TEMPLATES_ONLY</a></td></tr>
<tr class="separator:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a831588920575901dd740e226351ddd03"><td class="memItemLeft" align="right" valign="top">CkReduction::reducerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinciter.html#a831588920575901dd740e226351ddd03">inciter::NodesMerger</a></td></tr>
<tr class="separator:a831588920575901dd740e226351ddd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Charm++ chare partitioner group used to perform mesh partitioning. </p>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mon 06 Feb 2017 11:55:50 AM MST </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</dd></dl>
<p>Charm++ chare partitioner group used to perform mesh partitioning. The implementation uses the Charm++ runtime system and is fully asynchronous, overlapping computation, communication as well as I/O. The algorithm utilizes the structured dagger (SDAG) Charm++ functionality. The high-level overview of the algorithm structure and how it interfaces with Charm++ is discussed in the Charm++ interface file <a class="el" href="partitioner_8ci.html">src/Inciter/partitioner.ci</a>.</p>
<h4>Call graph</h4>
<p>The following is a directed acyclic graph (DAG) that outlines the asynchronous algorithm implemented in this class The detailed discussion of the algorithm is given in the Charm++ interface file <a class="el" href="partitioner_8ci.html">partitioner.ci</a>, which also repeats the graph below using ASCII graphics. On the DAG orange fills denote global synchronization points, orange frames with white fill are partial synchronization points that overlap with other tasks, and dashed lines are potential shortcuts that allow jumping over some of the task-graph under some circumstances. See the detailed discussion in <a class="el" href="partitioner_8ci.html">partitioner.ci</a>. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="563" height="207"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
 <div class="fragment"><div class="line">// *****************************************************************************</div><div class="line">/*!</div><div class="line">  \file      src/Inciter/partitioner.ci</div><div class="line">  \author    J. Bakosi</div><div class="line">  \date      Thu 06 Oct 2016 12:51:38 PM MDT</div><div class="line">  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</div><div class="line">  \brief     Charm++ module interface file for the chare partitioner group</div><div class="line">  \details   Charm++ module interface file for the chare partitioner group used</div><div class="line">             to perform mesh partitioning.</div><div class="line">*/</div><div class="line">// *****************************************************************************</div><div class="line"></div><div class="line">module partitioner {</div><div class="line"></div><div class="line">  include &quot;unordered_set&quot;;</div><div class="line">  include &quot;unordered_map&quot;;</div><div class="line">  include &quot;Types.h&quot;;</div><div class="line"></div><div class="line">  namespace inciter {</div><div class="line"></div><div class="line">    chare Partitioner&lt; CProxy_Transporter,</div><div class="line">                       CProxy_Carrier,</div><div class="line">                       tk::CProxy_LinSysMerger&lt; CProxy_Transporter,</div><div class="line">                                                CProxy_Carrier,</div><div class="line">                                                AuxSolverLumpMassDiff &gt;,</div><div class="line">                       tk::CProxy_ParticleWriter&lt; CProxy_Transporter &gt; &gt;;</div><div class="line"></div><div class="line">    template&lt; class HostProxy, class WorkerProxy, class LinSysMergerProxy,</div><div class="line">              class ParticleWriterProxy &gt;</div><div class="line">    group Partitioner {</div><div class="line">      entry Partitioner( const HostProxy&amp; host,</div><div class="line">                         const WorkerProxy&amp; worker,</div><div class="line">                         const LinSysMergerProxy&amp; lsm,</div><div class="line">                         const ParticleWriterProxy&amp; pw );</div><div class="line">      entry void partition( int nchare );</div><div class="line">      entry void add( int frompe,</div><div class="line">            const std::unordered_map&lt; int, std::vector&lt; std::size_t &gt; &gt;&amp; elem );</div><div class="line">      entry void recv();</div><div class="line">      entry void flatten();</div><div class="line">      entry void offset( int pe, std::size_t u );</div><div class="line">      entry void request( int pe, const std::unordered_set&lt; std::size_t &gt;&amp; id );</div><div class="line">      entry void neworder(</div><div class="line">                   const std::unordered_map&lt; std::size_t, std::size_t &gt;&amp; id );</div><div class="line">      entry void lower( std::size_t low );</div><div class="line">      entry void stdCost( tk::real av );</div><div class="line">      entry void gather();</div><div class="line">      entry void query( int pe, const std::set&lt; std::size_t &gt;&amp; id );</div><div class="line">      entry void mask( int pe, const std::unordered_map&lt; std::size_t,</div><div class="line">                                       std::vector&lt; int &gt; &gt;&amp; ch );</div><div class="line"></div><div class="line">      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/</div><div class="line">      // charm++/manual.html, Sec. &quot;Structured Control Flow: Structured Dagger&quot;.</div><div class="line"></div><div class="line">      // High-level overview of the dependency and asynchronous call structure</div><div class="line">      // ---------------------------------------------------------------------</div><div class="line">      //</div><div class="line">      // Directed Acyclic Graph (DAG):        DAG legend:</div><div class="line">      // -----------------------------          Own - Owned nodes reordered</div><div class="line">      //                                        Req - Node IDs requested</div><div class="line">      // Own --  Pre -- Ord -- Low ---  Cre     Pre - Start preparing nodes IDs</div><div class="line">      //       /         | \           /  |     Ord - Nodes reordered</div><div class="line">      // Req -           |   -- Upp ---  /      Low - Lower bound received</div><div class="line">      //                  \             /       Upp - Upper bound computed</div><div class="line">      //                    -- Par ----         Cre - Create workers</div><div class="line">      //                                        Par - Partitioners participated</div><div class="line">      //</div><div class="line">      // Interpretation of the above DAG</div><div class="line">      // -------------------------------</div><div class="line">      // Control flow is from left to right and top to bottom. As the above</div><div class="line">      // graph shows, we wait for both Own and Req conditions to be complete</div><div class="line">      // before we start preparing node IDs for the requestor.</div><div class="line">      //</div><div class="line">      // Reordering of node IDs consists of two main parts: (1) Reordering those</div><div class="line">      // nodes that are unique on our PE, i.e., do not exist on any other PE.</div><div class="line">      // These nodes can be assigned a new node ID without any communication.</div><div class="line">      // (2) Reordering those nodes that connect to mesh cells on other PEs.</div><div class="line">      // Assignment of new node IDs, i.e., reordering, must be handled in a way</div><div class="line">      // that the same new node IDs will be assigned to the nodes that are</div><div class="line">      // physically the same but happen to exist on other PEs as well as on</div><div class="line">      // ours.</div><div class="line">      //</div><div class="line">      // Accordingly, reordering starts with the owned, i.e., independently</div><div class="line">      // reordered nodes, on each PE. When that is done, Own is triggered,</div><div class="line">      // signaling that the new order for the owned nodes are ready to be</div><div class="line">      // queried. On another path, every PE immediately sends out requests to</div><div class="line">      // fellow PEs for nodes that they cannot reorder by themselves. However,</div><div class="line">      // those can only be sent back when the PE they are requested from has</div><div class="line">      // finished reordering them, so we wait until Own is satisfied on that PE.</div><div class="line">      // Req is triggered when a PE has received a request. Only when Own and</div><div class="line">      // Req are both satisfied do we need to prepare a set of new node IDs for</div><div class="line">      // a requestor, hence the above logic in the SDAG. Since there can be</div><div class="line">      // multiple requests arriving before any (or some or all) of them can be</div><div class="line">      // satisfied, the requests are queued into a vector and when the runtime</div><div class="line">      // system calls prepare(), we fullfill all requests, clear the queue, and</div><div class="line">      // automatically re-enable the trigger for Own, i.e., wait only for Req,</div><div class="line">      // i.e., new requests.</div><div class="line">      //</div><div class="line">      // The second part of the graph, only happend after reordering is done,</div><div class="line">      // after the mesh reordering has been completed and started by a call to</div><div class="line">      // bounds() inside reordered(). Ord is a partial synchronization point,</div><div class="line">      // because it happens at different times on different PEs.</div><div class="line"></div><div class="line">      // First the upper bounds of the node IDs are computed on each PE, and</div><div class="line">      // once that is done the lower bounds are communicated among the fellow</div><div class="line">      // Partitioner branches, since the lower bound of PE n is the upper bound</div><div class="line">      // of PE n-1. Only when both upper and lower bounds have been stored on a</div><div class="line">      // PE, can Worker chare array elements be inserted, done in create().</div><div class="line">      // Initiation of estimating the average and standard deviation of the</div><div class="line">      // communication cost of merging the linear system is done in the</div><div class="line">      // beginning of create(), which starts two reductions, which must be done</div><div class="line">      // after each other: the first one accumulates the sum of the cost from</div><div class="line">      // each PE, and once the average is available on Transporter, a second</div><div class="line">      // round accumulates the variances back to Transporter.</div><div class="line">      //</div><div class="line">      // While the tasks carried out as described in the previous paragraph lead</div><div class="line">      // to correct results, there is an additional trigger, _participated_,</div><div class="line">      // that needs to be enabled before create() is called. The role of</div><div class="line">      // participated_complete() is to make sure that all PEs participate in the</div><div class="line">      // distribution of new (reordered) mesh node IDs during reordering. In</div><div class="line">      // particular, since PE 0 has nothing to receive from others, if this</div><div class="line">      // trigger is not in place, PE 0 goes ahead of every other PE and calls</div><div class="line">      // create() which calls Worker constructors, a potentially heavy function.</div><div class="line">      // This is undesired at this point since PE 0 will surely need to answer</div><div class="line">      // to requests from other PEs with new node IDs, which can only be done</div><div class="line">      // (if the participated trigger is not in place) when the Workers have</div><div class="line">      // been created. This introduces unnecessarly delays and load imbalance</div><div class="line">      // during reordering. Thus requiring participated_complete() in addition</div><div class="line">      // to lower and upper, delays creating of Workers. As a result, PE 0 is</div><div class="line">      // ready for requests from other PEs for new node IDs earlier than without</div><div class="line">      // the participate trigger, which yields a lot tighter CPU utilization</div><div class="line">      // during reordering. The participated trigger is enabled in two places:</div><div class="line">      // (1) in prepare(), i.e., if a PE had to prepare some of its new node IDs</div><div class="line">      // for others, and (2) in neworder(), i.e., if a PE had to receive new</div><div class="line">      // node IDs from others. Thus node reordering is only considered complete</div><div class="line">      // if every PE has participated in communication of the new node IDs.</div><div class="line">      //</div><div class="line">      // Note that Pre, Ord, and Cre are partial synchronization points: while</div><div class="line">      // Pre always happens before Ord, and Cre on the same PE, they happen at</div><div class="line">      // different times on different PEs, so these are not considered global</div><div class="line">      // synchronization points.</div><div class="line"></div><div class="line">      entry void wait4prep() {</div><div class="line">        when reorderowned_complete(), nodes_requested_complete()</div><div class="line">        serial &quot;prepare&quot; { prepare(); }</div><div class="line">      };</div><div class="line"></div><div class="line">      entry void wait4bounds() {</div><div class="line">        when lower_complete(), upper_complete(), participated_complete()</div><div class="line">        serial &quot;create&quot; { create(); }</div><div class="line">      };</div><div class="line"></div><div class="line">      entry void reorderowned_complete();</div><div class="line">      entry void nodes_requested_complete();</div><div class="line">      entry void lower_complete();</div><div class="line">      entry void upper_complete();</div><div class="line">      entry void participated_complete();</div><div class="line">    };</div><div class="line"></div><div class="line">  } // inciter::</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="_partitioner_8h_source.html">Partitioner.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6ec0c67374eb34a66c0f5ca4ecd7d163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec0c67374eb34a66c0f5ca4ecd7d163">&#9670;&nbsp;</a></span>CK_TEMPLATES_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CK_TEMPLATES_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_partitioner_8h_source.html#l00909">909</a> of file <a class="el" href="_partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 10 2017 06:18:08 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
