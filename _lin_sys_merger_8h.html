<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/q/quinoa/src/LinSys/LinSysMerger.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3ca9c9eb36ab3ecb75ba69910724f6da.html">LinSys</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">LinSysMerger.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Charm++ chare linear system merger group to solve a linear system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;iosfwd&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &quot;Types.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_exception_8h_source.html">Exception.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_u_p_util_8h_source.html">PUPUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_fields_8h_source.html">Fields.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_matrix_8h_source.html">HypreMatrix.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_vector_8h_source.html">HypreVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_solver_8h_source.html">HypreSolver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_vector_reducer_8h_source.html">VectorReducer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_aux_solver_8h_source.html">AuxSolver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="linsysmerger_8decl_8h_source.html">NoWarning/linsysmerger.decl.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="transporter_8decl_8h_source.html">NoWarning/transporter.decl.h</a>&quot;</code><br />
<code>#include &quot;linsysmerger.def.h&quot;</code><br />
</div>
<p><a href="_lin_sys_merger_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_lin_sys_merger.html">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetk"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html">tk</a></td></tr>
<tr class="memdesc:namespacetk"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit declarations and definitions for general purpose utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_lin_sys_merger_8h.html#a6ec0c67374eb34a66c0f5ca4ecd7d163">CK_TEMPLATES_ONLY</a></td></tr>
<tr class="separator:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Charm++ chare linear system merger group to solve a linear system. </p>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Mon 20 Mar 2017 10:14:19 AM MDT </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</dd></dl>
<p>Charm++ chare linear system merger group used to collect and assemble the left hand side matrix (lhs), the right hand side (rhs) vector, and the solution (unknown) vector from individual worker (e.g., Carrier) chares. Beside collection and assembly, the system is also solved. The solution is outsourced to hypre, an MPI-only library. Once the solution is available, the individual worker chares are updated with the new solution.</p>
<p>In the basic configuration this class assembles and solves a single linear system, whose rhs vector may change during time stepping. In a more advanced configuration, an additional, auxiliary, linear system can also be solved. The basic configuration is configured by instantiating this class using the AuxSolver = AuxSolverNull template argument, while the one that solves the auxiliary system is configured by an AuxSolver class that provides a number of member functions. For possible auxiliary solver classes, see, e.g., <a class="el" href="_aux_solver_8h.html" title="Auxiliary solvers used in tk::LinSysMerger by inciter. ">src/Inciter/AuxSolver.h</a>.</p>
<p>When LinSysMerger is configured to solve an auxiliary solution beside its primary solution, the class behind the AuxSolver template argument, must have static member functions only, which may provide the necessary functionality to collect, assemble, solve, and update an auxiliary linear system. The requirements on the auxiliary linear system are: (1) the left hand side matrix must be diagonal, (2) the right hand side vector is (optionally) a combination of the primary right hand side vector and another vector, assembled separately (and overlapped with the primary system). This enables configuring the auxiliary system to be, e.g., the low order solution as required by the flux-corrected transport algorithm used for transport equations in inciter. However, it also enables entirely removing the auxiliary solution from LinSysMerger, via <a class="el" href="classinciter_1_1_aux_solver_null.html" title="AuxSolverNull: No auxiliary solver (unused for now) ">inciter::AuxSolverNull</a>. Tthe Charm++ SDAG logic does not change depending on whether an auxiliary solution is performed or not. The composition is done at compile time, depending on how LinSysMerger is instantiated.</p>
<p>The implementation uses the Charm++ runtime system and is fully asynchronous, overlapping computation and communication. The algorithm utilizes the structured dagger (SDAG) Charm++ functionality. The high-level overview of the algorithm structure and how it interfaces with Charm++ is discussed in the Charm++ interface file <a class="el" href="linsysmerger_8ci.html">src/LinSys/linsysmerger.ci</a>. Note that the SDAG logic is the same regardless whether an auxiliary solution is performed.</p>
<h4>Call graph</h4>
<p>The following is a directed acyclic graph (DAG) that outlines the asynchronous algorithm implemented in this class The detailed discussion of the algorithm is given in the Charm++ interface file <a class="el" href="linsysmerger_8ci.html">linsysmerger.ci</a>. On the DAG orange fills denote global synchronization points that contain or eventually lead to global reductions. Dashed lines are potential shortcuts that allow jumping over some of the task-graph under some circumstances or optional code paths (taken, e.g., only in DEBUG mode). See the detailed discussion in linsysmrger.ci. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="1354" height="427"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
 <div class="fragment"><div class="line">// *****************************************************************************</div><div class="line">/*!</div><div class="line">  \file      src/LinSys/linsysmerger.ci</div><div class="line">  \author    J. Bakosi</div><div class="line">  \date      Tue 08 Nov 2016 02:00:17 PM MST</div><div class="line">  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</div><div class="line">  \brief     Charm++ module interface file for merging a linear system</div><div class="line">  \details   Charm++ module interface file for merging a linear system. See more</div><div class="line">     in src/LinSys/LinSysMerger.h.</div><div class="line">*/</div><div class="line">// *****************************************************************************</div><div class="line"></div><div class="line">module linsysmerger {</div><div class="line"></div><div class="line">  include &quot;unordered_map&quot;;</div><div class="line"></div><div class="line">  extern module transporter;</div><div class="line"></div><div class="line">  namespace tk {</div><div class="line"></div><div class="line">    // List all possible specializations of templated chare to instantiate</div><div class="line">    // registration and delivery of code for the individual specializations</div><div class="line"></div><div class="line">    // Will specialize linear system merger for Transporter &amp; Carrier</div><div class="line">    chare LinSysMerger&lt; inciter::CProxy_Transporter,</div><div class="line">                        inciter::CProxy_Carrier,</div><div class="line">                        inciter::AuxSolverLumpMassDiff &gt;;</div><div class="line"></div><div class="line">    // LinSysMerger is templated so that the same code (parameterized by the</div><div class="line">    // type given by the template arguments, HostProxy and WorkerProxy) can be</div><div class="line">    // generated for different types of proxies. Howver, all possible</div><div class="line">    // specializations must be listed above to ensure that Charm++ generates</div><div class="line">    // correct code.</div><div class="line">    template&lt; class HostProxy, class WorkerProxy, class AuxSolver &gt;</div><div class="line">    group LinSysMerger {</div><div class="line">      entry LinSysMerger( const HostProxy&amp; host,</div><div class="line">                          const WorkerProxy&amp; worker,</div><div class="line">                          const std::map&lt; int,</div><div class="line">                            std::vector&lt; std::size_t &gt; &gt;&amp; side,</div><div class="line">                          std::size_t ncomp,</div><div class="line">                          bool feedback );</div><div class="line">      initnode void registerBCMerger();</div><div class="line">      entry void bounds( int pe, std::size_t lower, std::size_t upper );</div><div class="line">      entry void enable_wait4rhs();</div><div class="line">      entry void addrow( int fromch,</div><div class="line">                         int frompe,</div><div class="line">                         const std::set&lt; std::size_t &gt;&amp; row );</div><div class="line">      entry void recrow();</div><div class="line">      entry [reductiontarget] void addbc( CkReductionMsg* msg );</div><div class="line">      entry void addsol( int fromch,</div><div class="line">                         const std::map&lt; std::size_t,</div><div class="line">                                         std::vector&lt; tk::real &gt; &gt;&amp; solution );</div><div class="line">      entry void addlhs( int fromch,</div><div class="line">        const std::map&lt; std::size_t,</div><div class="line">                        std::map&lt; std::size_t,</div><div class="line">                                  std::vector&lt; tk::real &gt; &gt; &gt;&amp; lhs );</div><div class="line">      entry void addrhs( int fromch,</div><div class="line">                         const std::map&lt; std::size_t,</div><div class="line">                                         std::vector&lt; tk::real &gt; &gt;&amp; rhs );</div><div class="line">      entry void addauxrhs( int fromch,</div><div class="line">                            const std::map&lt; std::size_t,</div><div class="line">                                            std::vector&lt; tk::real &gt; &gt;&amp; auxrhs );</div><div class="line">      entry void addauxlhs( int fromch,</div><div class="line">                            const std::map&lt; std::size_t,</div><div class="line">                                            std::vector&lt; tk::real &gt; &gt;&amp; auxlhs );</div><div class="line">      entry void adddiag( int fromch,</div><div class="line">                          const std::map&lt; std::size_t,</div><div class="line">                           std::vector&lt; std::vector&lt; tk::real &gt; &gt; &gt;&amp; solution );</div><div class="line">      entry void rowsreceived();</div><div class="line"></div><div class="line">      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/</div><div class="line">      // charm++/manual.html, Sec. &quot;Structured Control Flow: Structured Dagger&quot;.</div><div class="line"></div><div class="line">      // High-level overview of the dependency and asynchronous call structure</div><div class="line">      // ---------------------------------------------------------------------</div><div class="line">      //</div><div class="line">      // Directed Acyclic Graph (DAG):</div><div class="line">      // -----------------------------</div><div class="line">      //</div><div class="line">      // See src/LinSys/LinSysMerger.h.</div><div class="line">      //</div><div class="line">      // Interpretation of the DAG in src/LinSys/LinSysMerger.h</div><div class="line">      // ------------------------------------------------------</div><div class="line">      // Control flow is from left to right and top to bottom.</div><div class="line">      //</div><div class="line">      // We start out with all worker chares contributing their porition of the</div><div class="line">      // global row IDs that each work on. This is labelled ChRow. The worker</div><div class="line">      // chares also contribute, in parallel, their portion of the global node</div><div class="line">      // ID lists at which they can set boundary conditions, labelled, ChBCs.</div><div class="line">      // Once both row IDs and BC node lists are received on LinSysMerger, we do</div><div class="line">      // a global reduction to Transport::rowcomplete() which spawns two</div><div class="line">      // broadcasts: (1) LinSysMerger::rowsreceived(), and (2) worker::init().</div><div class="line">      //</div><div class="line">      // LinSysMerger::rowsreceived() path: The member function</div><div class="line">      // tk::LinSysMerger::rowsreceived(), labeled Ver in the task-graph,</div><div class="line">      // triggers and performs the following tasks: (1) Verification that</div><div class="line">      // ensures consistent global row IDs. This step only happens in DEBUG</div><div class="line">      // mode: VerRow is simply an Assert in member function rowsreceived). (2)</div><div class="line">      // The second step in tk::LinSysMerger::rowsreceived() initiates is</div><div class="line">      // building Hypre data from the global row indices received, labeled</div><div class="line">      // HypreRow.</div><div class="line">      //</div><div class="line">      // Worker::init() path: Once the row IDs are contributed,</div><div class="line">      // tk::Transporter::rowcomplete(), not only spaws</div><div class="line">      // tk::LinSysMerger::rowsreceived() but also issues a broadcast to the</div><div class="line">      // worker chares to start initializing their system. This is started with</div><div class="line">      // a call to the init() member function of the worker. The tasks done in</div><div class="line">      // init() include setting initial and boundary conditions, sending</div><div class="line">      // unknown/solution vectors for assembly to LinSysMerger, start computing</div><div class="line">      // the minimum time step size, outputing initial field data to file, start</div><div class="line">      // computing the left hand sides for both the primary and auxiliary linear</div><div class="line">      // systems, and sending all this for linear system assembly. The</div><div class="line">      // contribution goes to those Linear System Merger group branch (one per</div><div class="line">      // CPU) the workers happen to reside on. These steps are denoted by ChSol,</div><div class="line">      // ChLhs, and ChAuxLhs in the graph above, and the contributions/assembly</div><div class="line">      // is performed by the member functions charesol(), charelhs(), and</div><div class="line">      // chareauxlhs(), respectively.</div><div class="line">      //</div><div class="line">      // Among other tasks, worker::init(), discussed above, also start</div><div class="line">      // computing the minimum time step sizes based on all PDEs integrated.</div><div class="line">      // Once a worker has finished with that task, it sends it contribution of</div><div class="line">      // the smallest dt for computing a global minimum in Transporter::dt(),</div><div class="line">      // which then spawns a broadcast to the workers to start advancing their</div><div class="line">      // PDEs, which consists of computing the right hand sides for both the</div><div class="line">      // primary system and the auxiliary system, ChRhs, ChAuxRhs. These</div><div class="line">      // right hand sides can only be comnputed if the dt is available.</div><div class="line">      //</div><div class="line">      // Once the collection of the right hand side vector, ChRhs, is done, we</div><div class="line">      // set boundary conditions on the RHS vector, RhsBC. Once the collection</div><div class="line">      // of the left hand side matrix, ChLhs, is done, we set boundary</div><div class="line">      // conditions on the LHS matrix, LhsBC.</div><div class="line">      //</div><div class="line">      // Primary solution only: Once each of the tasks, ChSol, LhsBC, and RhsBC,</div><div class="line">      // (not all at the same time but separately) are done, we continue by</div><div class="line">      // converting these data structures to a format that Hypre expects, done</div><div class="line">      // in hypresol(), hyprelhs(), and hyprerhs(), denoted by similars labels</div><div class="line">      // in the graph. These functions basically flatten the C++ data</div><div class="line">      // structures to C-style arrays and linked arrays (for the matrix). Note</div><div class="line">      // that the left and right hand sides can only begin to be converted to</div><div class="line">      // Hypre data format if the boundary conditions have also been applied on</div><div class="line">      // each.</div><div class="line">      //</div><div class="line">      // Primary solution only: Once the tasks, HypreSol, HypreLhs, HypreRhs,</div><div class="line">      // (not all at the same time but separately) are done and the Hypre data</div><div class="line">      // structure for the row IDs are complete, we continue by assigning the</div><div class="line">      // flattened data structures (more precisely, their pointers) to the Hypre</div><div class="line">      // vectors and Hypre matrix. These are denoted FillSol, FillLhs, and</div><div class="line">      // FillRhs in the DAG and correspond to the member functions sol(), lhs(),</div><div class="line">      // and rhs().</div><div class="line">      //</div><div class="line">      // Primary solution only: Once the tasks, FillSol, FillLhs, FIllRhs, (not</div><div class="line">      // all at the same time, but separately) are, we continue by calling the</div><div class="line">      // Hypre &quot;assembly&quot; routines for the solution vector, the left hand side</div><div class="line">      // matrix, and the right hand side vector. These are denoted by AsmSol,</div><div class="line">      // AsmLhs, and AsmRhs in the DAG, and performed by the member functions</div><div class="line">      // assemblesol(), assemblelhs(), and assemblerhs(), respectively.</div><div class="line">      //</div><div class="line">      // Primary solution only: Once the assembly of the solution (unknown)</div><div class="line">      // vector, the left hand side matrix, and the right hand side vector are</div><div class="line">      // all done (on a CPU), labels AsmSol, AsmLhs, AsmRhs, respectively, we</div><div class="line">      // call the solve() member function which solves the primary linear system</div><div class="line">      // by calling Hypre and also updates the primary solution, i.e.,</div><div class="line">      // propagates the new solution back to the worker chares, labeled Upd.</div><div class="line">      //</div><div class="line">      // Auxiliary solution only: The auxiliary solution is performed once the</div><div class="line">      // boundary conditions have been set on the primary right hand side vector</div><div class="line">      // (RhsBC), the auxiliary rhs vector, combined with primary the rhs</div><div class="line">      // (AuxRhs) has been ready, and the auxiliary left hand side (AuxLhs) are</div><div class="line">      // all complete. The solution of the auxiliary system is a simple</div><div class="line">      // back-substitution, since the system is assumed diagonal. Note also,</div><div class="line">      // that due to the way FluxCorrector::aec() computes the antidiffusive</div><div class="line">      // element contributions and the way it applies the limiter in</div><div class="line">      // FluxCorrector::lim(), there is no need to set Dirichlet boundary</div><div class="line">      // conditions on the auxiliary system. See more details in</div><div class="line">      // FluxCorrector::aec().</div><div class="line">      //</div><div class="line">      // A word on multiple invokation of SDAG triggers: As the commit message</div><div class="line">      // of b79ea29 explains, the &quot;triggers&quot;, such as hyprerow_complete(),</div><div class="line">      // enumerated below, at threir call site should be thought of as messages</div><div class="line">      // being put in some message queue and consumed at when clauses wherever</div><div class="line">      // they appear. If they appear in multiple when clauses, they consume</div><div class="line">      // multple messages, thus they have to be triggered multiple times. See</div><div class="line">      // also</div><div class="line">      // https://lists.cs.illinois.edu/lists/arc/charm/2016-09/msg00002.html.</div><div class="line">      //</div><div class="line">      // As discussed in src/LinSys/LinSysMerger.h, the SDAG logic discussed</div><div class="line">      // here is the same regardless whether an auxiliary linear solution is</div><div class="line">      // performed.</div><div class="line"></div><div class="line">      entry void wait4row() {</div><div class="line">        when row_complete(), bc_complete() serial &quot;row&quot; {</div><div class="line">          signal2host_row_complete( m_host ); } };</div><div class="line"></div><div class="line">      entry void wait4lhsbc() {</div><div class="line">        when lhs_complete() serial &quot;lhsbc&quot; { lhsbc(); } };</div><div class="line">      entry void wait4rhsbc() {</div><div class="line">        when rhs_complete() serial &quot;rhsbc&quot; { rhsbc(); } };</div><div class="line"></div><div class="line">      entry void wait4sol() {</div><div class="line">        when sol_complete() serial &quot;hypresol&quot; { hypresol(); } };</div><div class="line">      entry void wait4lhs() {</div><div class="line">        when lhsbc_complete() serial &quot;hyprelhs&quot; { hyprelhs(); } };</div><div class="line">      entry void wait4rhs() {</div><div class="line">        when rhsbc_complete() serial &quot;hyprerhs&quot; { hyprerhs(); } };</div><div class="line"></div><div class="line">      entry void wait4hypresol() {</div><div class="line">        when hypresol_complete(), hyprerow_complete() serial &quot;sol&quot; { sol(); } };</div><div class="line">      entry void wait4hyprelhs() {</div><div class="line">        when hyprelhs_complete(), hyprerow_complete() serial &quot;lhs&quot; { lhs(); } };</div><div class="line">      entry void wait4hyprerhs() {</div><div class="line">        when hyprerhs_complete(), hyprerow_complete() serial &quot;rhs&quot; { rhs(); } };</div><div class="line"></div><div class="line">      entry void wait4fillsol() {</div><div class="line">        when fillsol_complete() serial &quot;asmsol&quot; { assemblesol(); } };</div><div class="line">      entry void wait4filllhs() {</div><div class="line">        when filllhs_complete() serial &quot;asmlhs&quot; { assemblelhs(); } };</div><div class="line">      entry void wait4fillrhs() {</div><div class="line">        when fillrhs_complete() serial &quot;asmrhs&quot; { assemblerhs(); } };</div><div class="line"></div><div class="line">      entry void wait4asm() {</div><div class="line">        when asmsol_complete(), asmlhs_complete(), asmrhs_complete()</div><div class="line">          serial &quot;solve&quot; { solve(); } };</div><div class="line">      entry void wait4aux() {</div><div class="line">        when rhsbc_complete(), auxlhs_complete(), auxrhs_complete()</div><div class="line">          serial &quot;aux&quot; { auxsolve(); } };</div><div class="line"></div><div class="line">      entry void wait4solve() {</div><div class="line">        when solve_complete() serial &quot;update&quot; { updateSol(); } };</div><div class="line">      entry void wait4auxsolve() {</div><div class="line">        when auxsolve_complete() serial &quot;updateaux&quot; { updateAuxSol(); } };</div><div class="line"></div><div class="line">      entry void row_complete();</div><div class="line">      entry void bc_complete();</div><div class="line">      entry void lhsbc_complete();</div><div class="line">      entry void rhsbc_complete();</div><div class="line">      entry void hyprerow_complete();</div><div class="line">      entry void lhs_complete();</div><div class="line">      entry void rhs_complete();</div><div class="line">      entry void sol_complete();</div><div class="line">      entry void auxrhs_complete();</div><div class="line">      entry void auxlhs_complete();</div><div class="line">      entry void hyprelhs_complete();</div><div class="line">      entry void hyprerhs_complete();</div><div class="line">      entry void hypresol_complete();</div><div class="line">      entry void filllhs_complete();</div><div class="line">      entry void fillrhs_complete();</div><div class="line">      entry void fillsol_complete();</div><div class="line">      entry void asmlhs_complete();</div><div class="line">      entry void asmrhs_complete();</div><div class="line">      entry void asmsol_complete();</div><div class="line">      entry void solve_complete();</div><div class="line">      entry void auxsolve_complete();</div><div class="line">    };</div><div class="line"></div><div class="line">  } // tk::</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="_lin_sys_merger_8h_source.html">LinSysMerger.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6ec0c67374eb34a66c0f5ca4ecd7d163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec0c67374eb34a66c0f5ca4ecd7d163">&#9670;&nbsp;</a></span>CK_TEMPLATES_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CK_TEMPLATES_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_lin_sys_merger_8h_source.html#l01281">1281</a> of file <a class="el" href="_lin_sys_merger_8h_source.html">LinSysMerger.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2017 05:38:55 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
