<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: kw::keyword&lt; Info, Char, Chars &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structkw_1_1keyword.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structkw_1_1keyword-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kw::keyword&lt; Info, Char, Chars &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic definition of a keyword.  
 <a href="structkw_1_1keyword.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_keyword_8h_source.html">Keyword.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa45ce99d102881f96c9df6d8a819531d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#aa45ce99d102881f96c9df6d8a819531d">pegtl_string</a> = pegtl::string&lt; Char, Chars... &gt;</td></tr>
<tr class="memdesc:aa45ce99d102881f96c9df6d8a819531d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to keyword as pegtl::string.  <a href="#aa45ce99d102881f96c9df6d8a819531d">More...</a><br /></td></tr>
<tr class="separator:aa45ce99d102881f96c9df6d8a819531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23957f177ef793053d57358242161612"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a23957f177ef793053d57358242161612">info</a> = Info</td></tr>
<tr class="memdesc:a23957f177ef793053d57358242161612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring template argument 'Info' to scope as 'info'.  <a href="#a23957f177ef793053d57358242161612">More...</a><br /></td></tr>
<tr class="separator:a23957f177ef793053d57358242161612"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab21b3194f0f6a3d0fc5f79a935d9b358"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#ab21b3194f0f6a3d0fc5f79a935d9b358">string</a> ()</td></tr>
<tr class="memdesc:ab21b3194f0f6a3d0fc5f79a935d9b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to keyword as std::string.  <a href="#ab21b3194f0f6a3d0fc5f79a935d9b358">More...</a><br /></td></tr>
<tr class="separator:ab21b3194f0f6a3d0fc5f79a935d9b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b3990530599f44f96c45c4f011dae"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a221b3990530599f44f96c45c4f011dae">name</a> ()</td></tr>
<tr class="memdesc:a221b3990530599f44f96c45c4f011dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to required short name of a keyword.  <a href="#a221b3990530599f44f96c45c4f011dae">More...</a><br /></td></tr>
<tr class="separator:a221b3990530599f44f96c45c4f011dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac5732daadb0af7133d011fce892afd"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#aaac5732daadb0af7133d011fce892afd">shortDescription</a> ()</td></tr>
<tr class="memdesc:aaac5732daadb0af7133d011fce892afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to required short description of a keyword.  <a href="#aaac5732daadb0af7133d011fce892afd">More...</a><br /></td></tr>
<tr class="separator:aaac5732daadb0af7133d011fce892afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f5174ca14cdd00dafa63606dbc5f85"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a90f5174ca14cdd00dafa63606dbc5f85">longDescription</a> ()</td></tr>
<tr class="memdesc:a90f5174ca14cdd00dafa63606dbc5f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to required long description of a keyword.  <a href="#a90f5174ca14cdd00dafa63606dbc5f85">More...</a><br /></td></tr>
<tr class="separator:a90f5174ca14cdd00dafa63606dbc5f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b82164efa04e009433f9f67fc626d"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasTypedefAlias&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a6e1b82164efa04e009433f9f67fc626d"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a6e1b82164efa04e009433f9f67fc626d">alias</a> ()</td></tr>
<tr class="memdesc:a6e1b82164efa04e009433f9f67fc626d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads to optional alias accessor depending on the existence of Info::alias.  <a href="#a6e1b82164efa04e009433f9f67fc626d">More...</a><br /></td></tr>
<tr class="separator:a6e1b82164efa04e009433f9f67fc626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b82164efa04e009433f9f67fc626d"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasTypedefAlias&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a6e1b82164efa04e009433f9f67fc626d"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a6e1b82164efa04e009433f9f67fc626d">alias</a> ()</td></tr>
<tr class="separator:a6e1b82164efa04e009433f9f67fc626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7e2a2ee08843ce3927f30264483b14"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasTypedefCode&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7f7e2a2ee08843ce3927f30264483b14"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a7f7e2a2ee08843ce3927f30264483b14">code</a> ()</td></tr>
<tr class="memdesc:a7f7e2a2ee08843ce3927f30264483b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads to optional policy code accessor depending on the existence of Info::Code.  <a href="#a7f7e2a2ee08843ce3927f30264483b14">More...</a><br /></td></tr>
<tr class="separator:a7f7e2a2ee08843ce3927f30264483b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7e2a2ee08843ce3927f30264483b14"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasTypedefCode&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7f7e2a2ee08843ce3927f30264483b14"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a7f7e2a2ee08843ce3927f30264483b14">code</a> ()</td></tr>
<tr class="separator:a7f7e2a2ee08843ce3927f30264483b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasFunctionExpectDescription&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a35221e454ac8bd923ca9c96fe3877d0d">expt</a> ()</td></tr>
<tr class="memdesc:a35221e454ac8bd923ca9c96fe3877d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads to optional expected type description depending on the existence of Info::expect::description.  <a href="#a35221e454ac8bd923ca9c96fe3877d0d">More...</a><br /></td></tr>
<tr class="separator:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasFunctionExpectDescription&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a35221e454ac8bd923ca9c96fe3877d0d">expt</a> ()</td></tr>
<tr class="separator:a35221e454ac8bd923ca9c96fe3877d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasFunctionExpectChoices&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a40d32c44b391fad0d995d467f8ce6e5c">choices</a> ()</td></tr>
<tr class="memdesc:a40d32c44b391fad0d995d467f8ce6e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads to optional expected choices description depending on the existence of Info::expect::choices.  <a href="#a40d32c44b391fad0d995d467f8ce6e5c">More...</a><br /></td></tr>
<tr class="separator:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memTemplParams" colspan="2">template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasFunctionExpectChoices&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memTemplItemLeft" align="right" valign="top">static boost::optional&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkw_1_1keyword.html#a40d32c44b391fad0d995d467f8ce6e5c">choices</a> ()</td></tr>
<tr class="separator:a40d32c44b391fad0d995d467f8ce6e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Info, int Char, int... Chars&gt;<br />
struct kw::keyword&lt; Info, Char, Chars &gt;</h3>

<p>Generic definition of a keyword. </p>
<p>A keyword is a struct that collects the information that makes up a keyword. The requirement on the first template argument, Info, is that it must define the <a class="el" href="structkw_1_1keyword.html#a221b3990530599f44f96c45c4f011dae" title="Accessor to required short name of a keyword. ">name()</a>, <a class="el" href="structkw_1_1keyword.html#aaac5732daadb0af7133d011fce892afd" title="Accessor to required short description of a keyword. ">shortDescription(,)</a> and <a class="el" href="structkw_1_1keyword.html#a90f5174ca14cdd00dafa63606dbc5f85" title="Accessor to required long description of a keyword. ">longDescription()</a> member functions returning compile-time (static) std::strings. The <a class="el" href="structkw_1_1keyword.html#aaac5732daadb0af7133d011fce892afd" title="Accessor to required short description of a keyword. ">shortDescription()</a> member function is used to return a short description of what the keyword is used for, while the <a class="el" href="structkw_1_1keyword.html#a90f5174ca14cdd00dafa63606dbc5f85" title="Accessor to required long description of a keyword. ">longDescription()</a> member function is used for a longer, e.g., a paragraph-long, description on what the keyword can be used for and how it can and should be used. The last template parameters are a list of character constants, specifying the case-sensitive characters that make up the keyword, which is then matched by the parser. The keyword must be at least one character long, but otherwise its length is only limited by the compiler's recursion handling capability of variadic templates. While the <a class="el" href="structkw_1_1keyword.html#a221b3990530599f44f96c45c4f011dae" title="Accessor to required short name of a keyword. ">name()</a>, <a class="el" href="structkw_1_1keyword.html#aaac5732daadb0af7133d011fce892afd" title="Accessor to required short description of a keyword. ">shortDescription()</a> and <a class="el" href="structkw_1_1keyword.html#a90f5174ca14cdd00dafa63606dbc5f85" title="Accessor to required long description of a keyword. ">longDescription()</a> member functions of Info are required, there are also optional ones, such as Info::exptect::description(), which, if defined, must also be static and return a std::string, describing the type the particular keyword expects during parsing. This is optional since not every keyword expects a value (or values) of a particular type. For example, the keyword 'end' is simply used to close a block, and what follows does not have a relationship to the keyword. A counterexample is is 'title', which expects a double-quoted string. </p><dl class="section see"><dt>See also</dt><dd>For example client-code and more detailed documentation on the possible fields, see <a class="el" href="_keywords_8h.html" title="Definition of all keywords. ">Control/Keywords.h</a>. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00073">73</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a23957f177ef793053d57358242161612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23957f177ef793053d57358242161612">&sect;&nbsp;</a></span>info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::<a class="el" href="structkw_1_1keyword.html#a23957f177ef793053d57358242161612">info</a> =  Info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bring template argument 'Info' to scope as 'info'. </p>
<p>This is used to access, e.g., Info::alias, etc., if exist. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structtk_1_1grm_1_1alias.html" title="Match alias cmdline keyword. ">tk::grm::alias</a> </dd>
<dd>
<a class="el" href="structtk_1_1grm_1_1readcmd.html" title="Read command line &#39;keyword&#39; in verbose form, i.e., &#39;–keyword&#39;. ">tk::grm::readcmd</a> </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00102">102</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>

</div>
</div>
<a id="aa45ce99d102881f96c9df6d8a819531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45ce99d102881f96c9df6d8a819531d">&sect;&nbsp;</a></span>pegtl_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::<a class="el" href="structkw_1_1keyword.html#aa45ce99d102881f96c9df6d8a819531d">pegtl_string</a> =  pegtl::string&lt; Char, Chars... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor to keyword as pegtl::string. </p>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00076">76</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e1b82164efa04e009433f9f67fc626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b82164efa04e009433f9f67fc626d">&sect;&nbsp;</a></span>alias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasTypedefAlias&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads to optional alias accessor depending on the existence of Info::alias. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized (or uninitialized) boost::optional&lt; std::string &gt;</dd></dl>
<p>As to why type Info has to be aliased to a local type T for SFINAE to work, see <a href="http://stackoverflow.com/a/22671495">http://stackoverflow.com/a/22671495</a>. Though an alias is only a single character, it returns it as std::string since pegtl::escape returns std::string. </p><dl class="section see"><dt>See also</dt><dd><a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html">http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/types/enable_if">http://en.cppreference.com/w/cpp/types/enable_if</a> </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00116">116</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  { <span class="keywordflow">return</span> pegtl::escape( Info::alias::value ); }</div></div><!-- fragment -->
</div>
</div>
<a id="a6e1b82164efa04e009433f9f67fc626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b82164efa04e009433f9f67fc626d">&sect;&nbsp;</a></span>alias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasTypedefAlias&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00121">121</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  { <span class="keywordflow">return</span> boost::none; }</div></div><!-- fragment -->
</div>
</div>
<a id="a40d32c44b391fad0d995d467f8ce6e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d32c44b391fad0d995d467f8ce6e5c">&sect;&nbsp;</a></span>choices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasFunctionExpectChoices&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::choices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads to optional expected choices description depending on the existence of Info::expect::choices. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized (or uninitialized) boost::optional&lt; std::string &gt;</dd></dl>
<p>As to why type Info has to be aliased to a local type T for SFINAE to work, see <a href="http://stackoverflow.com/a/22671495">http://stackoverflow.com/a/22671495</a>. </p><dl class="section see"><dt>See also</dt><dd><a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html">http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/types/enable_if">http://en.cppreference.com/w/cpp/types/enable_if</a> </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00172">172</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  { <span class="keywordflow">return</span> Info::expect::choices(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a40d32c44b391fad0d995d467f8ce6e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d32c44b391fad0d995d467f8ce6e5c">&sect;&nbsp;</a></span>choices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasFunctionExpectChoices&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::choices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00177">177</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  { <span class="keywordflow">return</span> boost::none; }</div></div><!-- fragment -->
</div>
</div>
<a id="a7f7e2a2ee08843ce3927f30264483b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7e2a2ee08843ce3927f30264483b14">&sect;&nbsp;</a></span>code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasTypedefCode&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads to optional policy code accessor depending on the existence of Info::Code. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized (or uninitialized) boost::optional&lt; std::string &gt;</dd></dl>
<p>As to why type Info has to be aliased to a local type T for SFINAE to work, see <a href="http://stackoverflow.com/a/22671495">http://stackoverflow.com/a/22671495</a>. Though a code is only a single character, it returns it as std::string since pegtl::escape returns std::string. </p><dl class="section see"><dt>See also</dt><dd><a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html">http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/types/enable_if">http://en.cppreference.com/w/cpp/types/enable_if</a> </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00136">136</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  { <span class="keywordflow">return</span> pegtl::escape( Info::code::value ); }</div></div><!-- fragment -->
</div>
</div>
<a id="a7f7e2a2ee08843ce3927f30264483b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7e2a2ee08843ce3927f30264483b14">&sect;&nbsp;</a></span>code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasTypedefCode&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00141">141</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  { <span class="keywordflow">return</span> boost::none; }</div></div><!-- fragment -->
</div>
</div>
<a id="a35221e454ac8bd923ca9c96fe3877d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35221e454ac8bd923ca9c96fe3877d0d">&sect;&nbsp;</a></span>expt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; tk::HasFunctionExpectDescription&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::expt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads to optional expected type description depending on the existence of Info::expect::description. </p>
<dl class="section return"><dt>Returns</dt><dd>An initialized (or uninitialized) boost::optional&lt; std::string &gt;</dd></dl>
<p>As to why type Info has to be aliased to a local type T for SFINAE to work, see <a href="http://stackoverflow.com/a/22671495">http://stackoverflow.com/a/22671495</a>. </p><dl class="section see"><dt>See also</dt><dd><a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html">http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/language/sfinae">http://en.cppreference.com/w/cpp/language/sfinae</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/types/enable_if">http://en.cppreference.com/w/cpp/types/enable_if</a> </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00154">154</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  { <span class="keywordflow">return</span> Info::expect::description(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a35221e454ac8bd923ca9c96fe3877d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35221e454ac8bd923ca9c96fe3877d0d">&sect;&nbsp;</a></span>expt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<div class="memtemplate">
template&lt;typename T  = Info, typename std::enable_if&lt; !tk::HasFunctionExpectDescription&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::optional&lt; std::string &gt; <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::expt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00159">159</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  { <span class="keywordflow">return</span> boost::none; }</div></div><!-- fragment -->
</div>
</div>
<a id="a90f5174ca14cdd00dafa63606dbc5f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f5174ca14cdd00dafa63606dbc5f85">&sect;&nbsp;</a></span>longDescription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::longDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to required long description of a keyword. </p>
<dl class="section return"><dt>Returns</dt><dd>Long help as std::string </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00096">96</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;{ <span class="keywordflow">return</span> Info::longDescription(); }</div></div><!-- fragment -->
</div>
</div>
<a id="a221b3990530599f44f96c45c4f011dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221b3990530599f44f96c45c4f011dae">&sect;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to required short name of a keyword. </p>
<dl class="section return"><dt>Returns</dt><dd>Name of keyword as std::string </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00088">88</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{ <span class="keywordflow">return</span> Info::name(); }</div></div><!-- fragment -->
</div>
</div>
<a id="aaac5732daadb0af7133d011fce892afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac5732daadb0af7133d011fce892afd">&sect;&nbsp;</a></span>shortDescription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::shortDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to required short description of a keyword. </p>
<dl class="section return"><dt>Returns</dt><dd>Short help as std::string </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00092">92</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{ <span class="keywordflow">return</span> Info::shortDescription(); }</div></div><!-- fragment -->
</div>
</div>
<a id="ab21b3194f0f6a3d0fc5f79a935d9b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21b3194f0f6a3d0fc5f79a935d9b358">&sect;&nbsp;</a></span>string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Info , int Char, int... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="structkw_1_1keyword.html">kw::keyword</a>&lt; Info, Char, Chars &gt;::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to keyword as std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>Keyword as std::string </dd></dl>

<p>Definition at line <a class="el" href="_keyword_8h_source.html#l00080">80</a> of file <a class="el" href="_keyword_8h_source.html">Keyword.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                            {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> ( <span class="keyword">sizeof</span>...( Chars ) ) ?</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;           ( pegtl::escaper&lt; Char, Chars... &gt;::result() ) :</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;           ( pegtl::escape( Char ) );</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/tmp/q/quinoa/src/Control/<a class="el" href="_keyword_8h_source.html">Keyword.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacekw.html">kw</a></li><li class="navelem"><a class="el" href="structkw_1_1keyword.html">keyword</a></li>
    <li class="footer">Generated on Thu Dec 15 2016 04:32:05 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
