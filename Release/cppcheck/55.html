
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href="https://github.com/quinoacomputing/quinoa/commit/2050312">Quinoa_v0.2-1911-g2050312</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script language="javascript">
      function getStyle(el,styleProp) {
        if (el.currentStyle)
          var y = el.currentStyle[styleProp];
        else if (window.getComputedStyle)
          var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
        return y;
      }
      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;
        if (el.style.display == "block") {
          el.style.display = "none";
          mark.innerHTML = "[+]";
        } else {
          el.style.display = "block";
          mark.innerHTML = "[-]";
        }
      }
      function init_expandables() {
        var elts = document.getElementsByClassName("expandable");
        for (var i = 0; i < elts.length; i++) {
          var el = elts[i];
          var clickable = el.getElementsByTagName("span")[0];
          var marker = clickable.getElementsByClassName("marker")[0];
          var content = el.getElementsByClassName("content")[0];
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.onclick = toggle;
        }
      }
      function set_class_display(c, st) {
        var elements = document.querySelectorAll('.' + c),
            len = elements.length;
        for (i = 0; i < len; i++) {
            elements[i].style.display = st;
        }
      }
      function toggle_class_visibility(id) {
        var box = document.getElementById(id);
        set_class_display(id, box.checked ? '' : 'none');
      }
    </script>
  </head>
  <body onload="init_expandables()">
      <div id="header">
        <h1>Cppcheck report - [<a href="https://github.com/quinoacomputing/quinoa/commit/2050312">Quinoa_v0.2-1911-g2050312</a>]: /tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/Sorter.C </h1>
      </div>
      <div id="menu" dir="rtl">
       <p id="filename"><a href="index.html">Defects:</a> Sorter.C</p>
<a href='55.html#line-296'> useStlAlgorithm 296</a>
      </div>
      <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Inciter/Sorter.C</span>
<a name="line-4"></a><span class="cm">  \copyright 2016-2018, Los Alamos National Security, LLC.</span>
<a name="line-5"></a><span class="cm">  \brief     Mesh sorter for global distributed mesh reordering</span>
<a name="line-6"></a><span class="cm">  \see       Sorter.h for more info.</span>
<a name="line-7"></a><span class="cm">*/</span>
<a name="line-8"></a><span class="c1">// *****************************************************************************</span>
<a name="line-9"></a>
<a name="line-10"></a><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<a name="line-11"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-12"></a>
<a name="line-13"></a><span class="cp">#include</span> <span class="cpf">&quot;Sorter.h&quot;</span><span class="cp"></span>
<a name="line-14"></a><span class="cp">#include</span> <span class="cpf">&quot;Reorder.h&quot;</span><span class="cp"></span>
<a name="line-15"></a><span class="cp">#include</span> <span class="cpf">&quot;DerivedData.h&quot;</span><span class="cp"></span>
<a name="line-16"></a><span class="cp">#include</span> <span class="cpf">&quot;Inciter/InputDeck/InputDeck.h&quot;</span><span class="cp"></span>
<a name="line-17"></a><span class="cp">#include</span> <span class="cpf">&quot;Solver.h&quot;</span><span class="cp"></span>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&quot;HashMapReducer.h&quot;</span><span class="cp"></span>
<a name="line-19"></a><span class="c1">//#include &quot;BndFaceReducer.h&quot;</span>
<a name="line-20"></a>
<a name="line-21"></a><span class="k">namespace</span> <span class="n">inciter</span> <span class="p">{</span>
<a name="line-22"></a>
<a name="line-23"></a><span class="k">extern</span> <span class="n">ctr</span><span class="o">::</span><span class="n">InputDeck</span> <span class="n">g_inputdeck</span><span class="p">;</span>
<a name="line-24"></a>
<a name="line-25"></a><span class="k">static</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">reducerType</span> <span class="n">ChBndNodeMerger</span><span class="p">;</span>
<a name="line-26"></a><span class="k">static</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">reducerType</span> <span class="n">BndFaceMerger</span><span class="p">;</span>
<a name="line-27"></a><span class="k">static</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">reducerType</span> <span class="n">BndNodeMerger</span><span class="p">;</span>
<a name="line-28"></a>
<a name="line-29"></a><span class="p">}</span> <span class="c1">// inciter::</span>
<a name="line-30"></a>
<a name="line-31"></a><span class="k">using</span> <span class="n">inciter</span><span class="o">::</span><span class="n">Sorter</span><span class="p">;</span>
<a name="line-32"></a>
<a name="line-33"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">Sorter</span><span class="p">(</span> <span class="k">const</span> <span class="n">CProxy_Transporter</span><span class="o">&amp;</span> <span class="n">transporter</span><span class="p">,</span>
<a name="line-34"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_Solver</span><span class="o">&amp;</span> <span class="n">solver</span><span class="p">,</span>
<a name="line-35"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">SorterCallback</span><span class="o">&amp;</span> <span class="n">cbs</span><span class="p">,</span>
<a name="line-36"></a>                <span class="k">const</span> <span class="n">Scheme</span><span class="o">&amp;</span> <span class="n">scheme</span><span class="p">,</span>
<a name="line-37"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ginpoel</span><span class="p">,</span>
<a name="line-38"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">CoordMap</span><span class="o">&amp;</span> <span class="n">coordmap</span><span class="p">,</span>
<a name="line-39"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
<a name="line-40"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span><span class="p">,</span>
<a name="line-41"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span><span class="p">,</span>
<a name="line-42"></a>                <span class="kt">int</span> <span class="n">nchare</span> <span class="p">)</span> <span class="o">:</span>
<a name="line-43"></a>  <span class="n">m_host</span><span class="p">(</span> <span class="n">transporter</span> <span class="p">),</span>
<a name="line-44"></a>  <span class="n">m_solver</span><span class="p">(</span> <span class="n">solver</span> <span class="p">),</span>
<a name="line-45"></a>  <span class="n">m_cbs</span><span class="p">(</span> <span class="n">cbs</span> <span class="p">),</span>
<a name="line-46"></a>  <span class="n">m_scheme</span><span class="p">(</span> <span class="n">scheme</span> <span class="p">),</span>
<a name="line-47"></a>  <span class="n">m_ginpoel</span><span class="p">(</span> <span class="n">ginpoel</span> <span class="p">),</span>
<a name="line-48"></a>  <span class="n">m_coordmap</span><span class="p">(</span> <span class="n">coordmap</span> <span class="p">),</span>
<a name="line-49"></a>  <span class="n">m_bface</span><span class="p">(</span> <span class="n">bface</span> <span class="p">),</span>
<a name="line-50"></a>  <span class="n">m_triinpoel</span><span class="p">(</span> <span class="n">triinpoel</span> <span class="p">),</span>
<a name="line-51"></a>  <span class="n">m_bnode</span><span class="p">(</span> <span class="n">bnode</span> <span class="p">),</span>
<a name="line-52"></a>  <span class="n">m_nchare</span><span class="p">(</span> <span class="n">nchare</span> <span class="p">),</span>
<a name="line-53"></a>  <span class="n">m_nodeset</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">ginpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ginpoel</span><span class="p">)</span> <span class="p">),</span>
<a name="line-54"></a>  <span class="n">m_noffset</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-55"></a>  <span class="n">m_msum</span><span class="p">(),</span>
<a name="line-56"></a>  <span class="n">m_reordcomm</span><span class="p">(),</span>
<a name="line-57"></a>  <span class="n">m_start</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-58"></a>  <span class="n">m_newnodes</span><span class="p">(),</span>
<a name="line-59"></a>  <span class="n">m_newcoordmap</span><span class="p">(),</span>
<a name="line-60"></a>  <span class="n">m_reqnodes</span><span class="p">(),</span>
<a name="line-61"></a>  <span class="n">m_lower</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-62"></a>  <span class="n">m_upper</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>
<a name="line-63"></a><span class="c1">// *****************************************************************************</span>
<a name="line-64"></a><span class="c1">//  Constructor: prepare owned mesh node IDs for reordering</span>
<a name="line-65"></a><span class="c1">//! \param[in] transporter Transporter (host) Charm++ proxy</span>
<a name="line-66"></a><span class="c1">//! \param[in] solver Linear system solver Charm++ proxy</span>
<a name="line-67"></a><span class="c1">//! \param[in] cbs Charm++ callbacks for Sorter</span>
<a name="line-68"></a><span class="c1">//! \param[in] scheme Discretization scheme</span>
<a name="line-69"></a><span class="c1">//! \param[in] ginpoel Mesh connectivity (this chare) using global node IDs</span>
<a name="line-70"></a><span class="c1">//! \param[in] coordmap Mesh node coordinates (this chare) for global node IDs</span>
<a name="line-71"></a><span class="c1">//! \param[in] bface Face lists mapped to side set ids</span>
<a name="line-72"></a><span class="c1">//! \param[in] triinpoel Interconnectivity of points and boundary-faces</span>
<a name="line-73"></a><span class="c1">//! \param[in] bnode Node ids mapped to side set ids</span>
<a name="line-74"></a><span class="c1">//! \param[in] nchare Total number of Charm++ Refiner chares</span>
<a name="line-75"></a><span class="c1">// *****************************************************************************</span>
<a name="line-76"></a><span class="p">{</span>
<a name="line-77"></a>  <span class="c1">// Ensure boundary face ids will not index out of face connectivity</span>
<a name="line-78"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">m_bface</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">m_bface</span><span class="p">),</span>
<a name="line-79"></a>            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m_bface</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<a name="line-80"></a>            <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span>
<a name="line-81"></a>                                  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span> <span class="n">f</span><span class="p">)</span>
<a name="line-82"></a>                                  <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">m_triinpoel</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span> <span class="p">);</span> <span class="p">}</span> <span class="p">),</span>
<a name="line-83"></a>          <span class="s">&quot;Boundary face data structures inconsistent&quot;</span> <span class="p">);</span>
<a name="line-84"></a>
<a name="line-85"></a>  <span class="n">usesAtSync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>    <span class="c1">// Enable migration at AtSync</span>
<a name="line-86"></a>
<a name="line-87"></a>  <span class="c1">// Find chare-boundary nodes</span>
<a name="line-88"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">chbnode</span><span class="p">;</span>
<a name="line-89"></a>  <span class="k">auto</span> <span class="n">el</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">global2local</span><span class="p">(</span> <span class="n">ginpoel</span> <span class="p">);</span>      <span class="c1">// generate local mesh data</span>
<a name="line-90"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">inpoel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">el</span> <span class="p">);</span>   <span class="c1">// local connectivity</span>
<a name="line-91"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">el</span> <span class="p">);</span>      <span class="c1">// local-&gt;global node ids</span>
<a name="line-92"></a>  <span class="k">auto</span> <span class="n">esup</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsup</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>       <span class="c1">// elements surrounding points</span>
<a name="line-93"></a>  <span class="k">auto</span> <span class="n">esuel</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsuelTet</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">,</span> <span class="n">esup</span> <span class="p">);</span> <span class="c1">// elems surrounding elements</span>
<a name="line-94"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">esuel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<a name="line-95"></a>    <span class="k">auto</span> <span class="n">mark</span> <span class="o">=</span> <span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
<a name="line-96"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">f</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
<a name="line-97"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">esuel</span><span class="p">[</span><span class="n">mark</span><span class="o">+</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-98"></a>        <span class="n">chbnode</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">gid</span><span class="p">[</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">mark</span><span class="o">+</span><span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">);</span>
<a name="line-99"></a>        <span class="n">chbnode</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">gid</span><span class="p">[</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">mark</span><span class="o">+</span><span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">);</span>
<a name="line-100"></a>        <span class="n">chbnode</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">gid</span><span class="p">[</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">mark</span><span class="o">+</span><span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">);</span>
<a name="line-101"></a>      <span class="p">}</span>
<a name="line-102"></a>    <span class="p">}</span>
<a name="line-103"></a>  <span class="p">}</span>
<a name="line-104"></a>  <span class="c1">// Make boundary nodes unique</span>
<a name="line-105"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span> <span class="n">chbnode</span> <span class="p">);</span>
<a name="line-106"></a>
<a name="line-107"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">())</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chbnd</span><span class="p">();</span>
<a name="line-108"></a>
<a name="line-109"></a>  <span class="c1">// Activate SDAG wait for receiving boundary face and node data</span>
<a name="line-110"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4com</span><span class="p">();</span>
<a name="line-111"></a>
<a name="line-112"></a>  <span class="c1">// Aggregate chare boundary nodes across all Sorter chares</span>
<a name="line-113"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-114"></a>    <span class="n">bnd</span><span class="p">{{</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">chbnode</span><span class="p">)</span> <span class="p">}};</span>
<a name="line-115"></a>  <span class="k">auto</span> <span class="n">chbnodestream</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span> <span class="n">bnd</span> <span class="p">);</span>
<a name="line-116"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="n">chbnodestream</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">chbnodestream</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">ChBndNodeMerger</span><span class="p">,</span>
<a name="line-117"></a>    <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkIndex_Sorter</span><span class="o">::</span><span class="n">comChBndNode</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="n">thisProxy</span><span class="p">)</span> <span class="p">);</span>
<a name="line-118"></a>
<a name="line-119"></a>  <span class="c1">// Aggregate boundary faces (and triangle connectivity) of side sets across</span>
<a name="line-120"></a>  <span class="c1">// all Sorter chares (pack to triangle connectivity set per side set first)</span>
<a name="line-121"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">FaceSet</span> <span class="o">&gt;</span> <span class="n">bconn</span><span class="p">;</span>
<a name="line-122"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">m_bface</span><span class="p">)</span> <span class="p">{</span>
<a name="line-123"></a>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bconn</span><span class="p">[</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">];</span>
<a name="line-124"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-125"></a>      <span class="n">b</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="p">{{{</span> <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span>
<a name="line-126"></a>                    <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
<a name="line-127"></a>                    <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="p">}}}</span> <span class="p">);</span>
<a name="line-128"></a>    <span class="p">}</span> 
<a name="line-129"></a>  <span class="p">}</span>
<a name="line-130"></a>  <span class="k">auto</span> <span class="n">facestream</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span> <span class="n">bconn</span> <span class="p">);</span>
<a name="line-131"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="n">facestream</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">facestream</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">BndFaceMerger</span><span class="p">,</span>
<a name="line-132"></a>    <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkIndex_Sorter</span><span class="o">::</span><span class="n">comface</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="n">thisProxy</span><span class="p">)</span> <span class="p">);</span>
<a name="line-133"></a>
<a name="line-134"></a>  <span class="c1">// Aggregate boundary nodes of side sets across all Sorter chares (pack to</span>
<a name="line-135"></a>  <span class="c1">// node sets per side set first)</span>
<a name="line-136"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bnodeset</span><span class="p">;</span>
<a name="line-137"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">m_bnode</span><span class="p">)</span>
<a name="line-138"></a>    <span class="n">bnodeset</span><span class="p">[</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-139"></a>  <span class="k">auto</span> <span class="n">nodestream</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span> <span class="n">bnodeset</span> <span class="p">);</span>
<a name="line-140"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="n">nodestream</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">nodestream</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">BndNodeMerger</span><span class="p">,</span>
<a name="line-141"></a>    <span class="n">CkCallback</span><span class="p">(</span><span class="n">CkIndex_Sorter</span><span class="o">::</span><span class="n">comnode</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="n">thisProxy</span><span class="p">)</span> <span class="p">);</span>
<a name="line-142"></a><span class="p">}</span>
<a name="line-143"></a>
<a name="line-144"></a><span class="kt">void</span>
<a name="line-145"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">registerReducers</span><span class="p">()</span>
<a name="line-146"></a><span class="c1">// *****************************************************************************</span>
<a name="line-147"></a><span class="c1">//  Configure Charm++ reduction types</span>
<a name="line-148"></a><span class="c1">//! \details Since this is a [nodeinit] routine, the runtime system executes the</span>
<a name="line-149"></a><span class="c1">//!   routine exactly once on every logical node early on in the Charm++ init</span>
<a name="line-150"></a><span class="c1">//!   sequence. Must be static as it is called without an object. See also:</span>
<a name="line-151"></a><span class="c1">//!   Section &quot;Initializations at Program Startup&quot; at in the Charm++ manual</span>
<a name="line-152"></a><span class="c1">//!   http://charm.cs.illinois.edu/manuals/html/charm++/manual.html.</span>
<a name="line-153"></a><span class="c1">// *****************************************************************************</span>
<a name="line-154"></a><span class="p">{</span>
<a name="line-155"></a>  <span class="n">ChBndNodeMerger</span> <span class="o">=</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">addReducer</span><span class="p">(</span>
<a name="line-156"></a>                      <span class="n">tk</span><span class="o">::</span><span class="n">mergeHashMap</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">);</span>
<a name="line-157"></a>  <span class="n">BndFaceMerger</span> <span class="o">=</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">addReducer</span><span class="p">(</span>
<a name="line-158"></a>                    <span class="n">tk</span><span class="o">::</span><span class="n">mergeHashMap</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">FaceSet</span> <span class="o">&gt;</span> <span class="p">);</span>
<a name="line-159"></a>  <span class="n">BndNodeMerger</span> <span class="o">=</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">addReducer</span><span class="p">(</span>
<a name="line-160"></a>                   <span class="n">tk</span><span class="o">::</span><span class="n">mergeHashMap</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">);</span>
<a name="line-161"></a><span class="p">}</span>
<a name="line-162"></a>
<a name="line-163"></a><span class="kt">void</span>
<a name="line-164"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">comChBndNode</span><span class="p">(</span> <span class="n">CkReductionMsg</span><span class="o">*</span> <span class="n">msg</span> <span class="p">)</span>
<a name="line-165"></a><span class="c1">// *****************************************************************************</span>
<a name="line-166"></a><span class="c1">//  Receive aggregated chare boundary nodes associated to chares</span>
<a name="line-167"></a><span class="c1">//! \param[in] msg Aggregated chare boundary nodes across the whole problem</span>
<a name="line-168"></a><span class="c1">//! \details This is a reduction target receiving the aggregated chare boundary</span>
<a name="line-169"></a><span class="c1">//!    nodes associated to chare IDs across the whole problem.</span>
<a name="line-170"></a><span class="c1">// *****************************************************************************</span>
<a name="line-171"></a><span class="p">{</span>
<a name="line-172"></a>  <span class="c1">// Unpack final result of aggregating boundary nodes associated to chares</span>
<a name="line-173"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bnd</span><span class="p">;</span>
<a name="line-174"></a>  <span class="n">PUP</span><span class="o">::</span><span class="n">fromMem</span> <span class="n">creator</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="p">);</span>
<a name="line-175"></a>  <span class="n">creator</span> <span class="o">|</span> <span class="n">bnd</span><span class="p">;</span>
<a name="line-176"></a>  <span class="k">delete</span> <span class="n">msg</span><span class="p">;</span>
<a name="line-177"></a>
<a name="line-178"></a>  <span class="c1">// Store the global mesh node IDs associated to chare IDs bordering our mesh</span>
<a name="line-179"></a>  <span class="c1">// chunk. This loop computes m_msum, a symmetric chare-node communication map,</span>
<a name="line-180"></a>  <span class="c1">// that associates a unique set of global node IDs to chare IDs we share these</span>
<a name="line-181"></a>  <span class="c1">// nodes with.</span>
<a name="line-182"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">bnd</span><span class="p">)</span>
<a name="line-183"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">thisIndex</span><span class="p">)</span>
<a name="line-184"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">c</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-185"></a>        <span class="k">const</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
<a name="line-186"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">m_nodeset</span><span class="p">))</span> <span class="n">m_msum</span><span class="p">[</span> <span class="n">c</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
<a name="line-187"></a>      <span class="p">}</span>
<a name="line-188"></a>
<a name="line-189"></a>  <span class="n">comchbndnode_complete</span><span class="p">();</span>
<a name="line-190"></a><span class="p">}</span>
<a name="line-191"></a>
<a name="line-192"></a><span class="kt">void</span>
<a name="line-193"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">comface</span><span class="p">(</span> <span class="n">CkReductionMsg</span><span class="o">*</span> <span class="n">msg</span> <span class="p">)</span>
<a name="line-194"></a><span class="c1">// *****************************************************************************</span>
<a name="line-195"></a><span class="c1">//  Receive aggregated boundary faces (and triangle connectivity) of side sets</span>
<a name="line-196"></a><span class="c1">//! \param[in] msg Aggregated boundary faces (and triangle connectivity) of side</span>
<a name="line-197"></a><span class="c1">//!   sets across the whole problem</span>
<a name="line-198"></a><span class="c1">//! \details This is a reduction target receiving the aggregated boundary faces</span>
<a name="line-199"></a><span class="c1">//!   (and triangle connectivity) of side sets across the whole problem.</span>
<a name="line-200"></a><span class="c1">// *****************************************************************************</span>
<a name="line-201"></a><span class="p">{</span>
<a name="line-202"></a>  <span class="c1">// Unpack final result of aggregating boundary face data associated to chares</span>
<a name="line-203"></a>  <span class="n">PUP</span><span class="o">::</span><span class="n">fromMem</span> <span class="n">creator</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="p">);</span>
<a name="line-204"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">FaceSet</span> <span class="o">&gt;</span> <span class="n">bconn</span><span class="p">;</span>
<a name="line-205"></a>  <span class="n">creator</span> <span class="o">|</span> <span class="n">bconn</span><span class="p">;</span>
<a name="line-206"></a>  <span class="k">delete</span> <span class="n">msg</span><span class="p">;</span>
<a name="line-207"></a>
<a name="line-208"></a>   <span class="c1">// Convert set of triangle connectivities per side set to 2 data structures:</span>
<a name="line-209"></a>   <span class="c1">// one that stores the face lists (local face ids) per side set, and an other</span>
<a name="line-210"></a>   <span class="c1">// with the triangle connectivity.</span>
<a name="line-211"></a>   <span class="n">m_bface</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-212"></a>   <span class="n">m_triinpoel</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-213"></a>   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-214"></a>   <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">bconn</span><span class="p">)</span> <span class="p">{</span>
<a name="line-215"></a>     <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">m_bface</span><span class="p">[</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">];</span>
<a name="line-216"></a>     <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-217"></a>       <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">f</span><span class="o">++</span> <span class="p">);</span>
<a name="line-218"></a>       <span class="n">m_triinpoel</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">end</span><span class="p">(</span><span class="n">m_triinpoel</span><span class="p">),</span> <span class="n">begin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">);</span>
<a name="line-219"></a>     <span class="p">}</span>
<a name="line-220"></a>   <span class="p">}</span>
<a name="line-221"></a>
<a name="line-222"></a>  <span class="n">comface_complete</span><span class="p">();</span>
<a name="line-223"></a><span class="p">}</span>
<a name="line-224"></a>
<a name="line-225"></a><span class="kt">void</span>
<a name="line-226"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">comnode</span><span class="p">(</span> <span class="n">CkReductionMsg</span><span class="o">*</span> <span class="n">msg</span> <span class="p">)</span>
<a name="line-227"></a><span class="c1">// *****************************************************************************</span>
<a name="line-228"></a><span class="c1">//  Receive aggregated boundary nodes of side sets</span>
<a name="line-229"></a><span class="c1">//! \param[in] msg Aggregated boundary nodes of side sets across the whole</span>
<a name="line-230"></a><span class="c1">//!   problem</span>
<a name="line-231"></a><span class="c1">//! \details This is a reduction target receiving the aggregated boundary nodes</span>
<a name="line-232"></a><span class="c1">//!   of side sets across the whole problem.</span>
<a name="line-233"></a><span class="c1">// *****************************************************************************</span>
<a name="line-234"></a><span class="p">{</span>
<a name="line-235"></a>  <span class="c1">// Unpack final result of aggregating boundary nodes associated to chares</span>
<a name="line-236"></a>  <span class="n">PUP</span><span class="o">::</span><span class="n">fromMem</span> <span class="n">creator</span><span class="p">(</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="p">);</span>
<a name="line-237"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bnode</span><span class="p">;</span>
<a name="line-238"></a>  <span class="n">creator</span> <span class="o">|</span> <span class="n">bnode</span><span class="p">;</span>
<a name="line-239"></a>  <span class="k">delete</span> <span class="n">msg</span><span class="p">;</span>
<a name="line-240"></a>
<a name="line-241"></a>   <span class="c1">// Convert set to vector of nodes per side sets</span>
<a name="line-242"></a>   <span class="n">m_bnode</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-243"></a>   <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">bnode</span><span class="p">)</span> <span class="p">{</span>
<a name="line-244"></a>     <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">m_bnode</span><span class="p">[</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">];</span>
<a name="line-245"></a>     <span class="n">b</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-246"></a>   <span class="p">}</span>
<a name="line-247"></a>
<a name="line-248"></a>  <span class="n">comnode_complete</span><span class="p">();</span>
<a name="line-249"></a><span class="p">}</span>
<a name="line-250"></a>
<a name="line-251"></a><span class="kt">void</span>
<a name="line-252"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">start</span><span class="p">()</span>
<a name="line-253"></a><span class="c1">// *****************************************************************************</span>
<a name="line-254"></a><span class="c1">//  Start reordering (if enabled it)</span>
<a name="line-255"></a><span class="c1">// *****************************************************************************</span>
<a name="line-256"></a><span class="p">{</span>
<a name="line-257"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">())</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chcomm</span><span class="p">();</span>
<a name="line-258"></a>
<a name="line-259"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">reorder</span> <span class="o">&gt;</span><span class="p">())</span>
<a name="line-260"></a>    <span class="n">mask</span><span class="p">();</span>   <span class="c1">// continue with mesh node reordering if requested (or required)</span>
<a name="line-261"></a>  <span class="k">else</span>
<a name="line-262"></a>    <span class="nf">create</span><span class="p">();</span> <span class="c1">// skip mesh node reordering</span>
<a name="line-263"></a><span class="p">}</span>
<a name="line-264"></a>
<a name="line-265"></a><span class="kt">void</span>
<a name="line-266"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">mask</span><span class="p">()</span>
<a name="line-267"></a><span class="c1">// *****************************************************************************</span>
<a name="line-268"></a><span class="c1">//  Start preparing for mesh node reordering in parallel</span>
<a name="line-269"></a><span class="c1">// *****************************************************************************</span>
<a name="line-270"></a><span class="p">{</span>
<a name="line-271"></a>  <span class="c1">// Compute asymmetric communcation map that will be used for reordering. This</span>
<a name="line-272"></a>  <span class="c1">// communication map is asymmetric because it associates global mesh node IDs</span>
<a name="line-273"></a>  <span class="c1">// to chares only with lower IDs than thisIndex. That is because this chare</span>
<a name="line-274"></a>  <span class="c1">// will need to receive new (reorderd) node IDs only from chares with lower</span>
<a name="line-275"></a>  <span class="c1">// IDs than thisIndex during node reordering. Since it only stores data for</span>
<a name="line-276"></a>  <span class="c1">// lower chare IDs, it is asymmetric. Note that because of this algorithm the</span>
<a name="line-277"></a>  <span class="c1">// type of m_msum is an ordered map, because of the std::none_of() algorithm</span>
<a name="line-278"></a>  <span class="c1">// needs to look at ALL chares this chare potentially communicates nodes with</span>
<a name="line-279"></a>  <span class="c1">// that have lower chare IDs that thisIndex. Since the map is ordered, it can</span>
<a name="line-280"></a>  <span class="c1">// walk through from the beginning of m_msum until the outer loop variable c,</span>
<a name="line-281"></a>  <span class="c1">// which is the chare ID the outer loop works on in a given cycle.</span>
<a name="line-282"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">=</span><span class="n">m_msum</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">c</span><span class="o">!=</span><span class="n">m_msum</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span>
<a name="line-283"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">thisIndex</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
<a name="line-284"></a>      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m_reordcomm</span><span class="p">[</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">];</span>
<a name="line-285"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">j</span> <span class="p">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span>
<a name="line-286"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">none_of</span><span class="p">(</span> <span class="n">m_msum</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">c</span><span class="p">,</span>
<a name="line-287"></a>             <span class="p">[</span> <span class="n">j</span> <span class="p">](</span> <span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m_msum</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span>
<a name="line-288"></a>             <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="p">}</span> <span class="p">))</span> <span class="p">{</span>
<a name="line-289"></a>          <span class="n">n</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<a name="line-290"></a>        <span class="p">}</span>
<a name="line-291"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">);</span>
<a name="line-292"></a>    <span class="p">}</span>
<a name="line-293"></a>
<a name="line-294"></a>  <span class="c1">// Count up total number of nodes this chare will need to receive</span>
<a name="line-295"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nrecv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-296"></a><span class="hll">  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">m_reordcomm</span><span class="p">)</span> <span class="n">nrecv</span> <span class="o">+=</span> <span class="n">u</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class='error2'>&lt;--- Consider using std::accumulate algorithm instead of a raw loop.</span>
</span><a name="line-297"></a>
<a name="line-298"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chmask</span><span class="p">();</span>
<a name="line-299"></a>
<a name="line-300"></a>  <span class="c1">// Compute number of mesh node IDs we will assign IDs to</span>
<a name="line-301"></a>  <span class="k">auto</span> <span class="n">nuniq</span> <span class="o">=</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">nrecv</span><span class="p">;</span>
<a name="line-302"></a>
<a name="line-303"></a>  <span class="c1">// Start computing offsets for node reordering</span>
<a name="line-304"></a>  <span class="n">thisProxy</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">nuniq</span> <span class="p">);</span>
<a name="line-305"></a><span class="p">}</span>
<a name="line-306"></a>
<a name="line-307"></a><span class="kt">void</span>
<a name="line-308"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">offset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">u</span> <span class="p">)</span>
<a name="line-309"></a><span class="c1">// *****************************************************************************</span>
<a name="line-310"></a><span class="c1">//  Receive number of uniquely assigned global mesh node IDs from chares with</span>
<a name="line-311"></a><span class="c1">//  lower IDs than thisIndex</span>
<a name="line-312"></a><span class="c1">//! \param[in] c Chare ID</span>
<a name="line-313"></a><span class="c1">//! \param[in] u Number of mesh node IDs chare c will assign IDs to</span>
<a name="line-314"></a><span class="c1">//! \details This function computes the offset each chare will need to start</span>
<a name="line-315"></a><span class="c1">//!   assigning its new node IDs from. The offset for a chare is the</span>
<a name="line-316"></a><span class="c1">//!   offset for the previous chare plus the number of node IDs the previous</span>
<a name="line-317"></a><span class="c1">//!   chare (uniquely) assigns new IDs for minus the number of node IDs the</span>
<a name="line-318"></a><span class="c1">//!   previous chare receives from others (lower chares). This is computed here</span>
<a name="line-319"></a><span class="c1">//!   in a parallel/distributed fashion by each chare sending its number of node</span>
<a name="line-320"></a><span class="c1">//!   IDs (that it uniquely assigns) to all chares. Note that each chare would</span>
<a name="line-321"></a><span class="c1">//!   only need to send this information to chares with higher IDs, but instead</span>
<a name="line-322"></a><span class="c1">//!   this function is called in a broadcast fashion, because that is more</span>
<a name="line-323"></a><span class="c1">//!   efficient than individual calls to only chares with higher IDs. Therefore</span>
<a name="line-324"></a><span class="c1">//!   when computing the offsets, we only count the lower chares. When this is</span>
<a name="line-325"></a><span class="c1">//!   done, we have the precise asymmetric communication map as well as the</span>
<a name="line-326"></a><span class="c1">//!   start offset on all chares and so we can start the distributed global mesh</span>
<a name="line-327"></a><span class="c1">//!   node ID reordering.</span>
<a name="line-328"></a><span class="c1">// *****************************************************************************</span>
<a name="line-329"></a><span class="p">{</span>
<a name="line-330"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">thisIndex</span><span class="p">)</span> <span class="n">m_start</span> <span class="o">+=</span> <span class="n">u</span><span class="p">;</span>
<a name="line-331"></a>  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_noffset</span> <span class="o">==</span> <span class="n">m_nchare</span><span class="p">)</span> <span class="n">reorder</span><span class="p">();</span>
<a name="line-332"></a><span class="p">}</span>
<a name="line-333"></a>
<a name="line-334"></a><span class="kt">void</span>
<a name="line-335"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">reorder</span><span class="p">()</span>
<a name="line-336"></a><span class="c1">// *****************************************************************************</span>
<a name="line-337"></a><span class="c1">//  Reorder global mesh node IDs</span>
<a name="line-338"></a><span class="c1">// *****************************************************************************</span>
<a name="line-339"></a><span class="p">{</span>
<a name="line-340"></a>  <span class="n">AtSync</span><span class="p">();</span>   <span class="c1">// Migrate here if needed</span>
<a name="line-341"></a>
<a name="line-342"></a>  <span class="c1">// Activate SDAG waits for arriving requests from other chares requesting new</span>
<a name="line-343"></a>  <span class="c1">// node IDs for node IDs we assign new IDs to during reordering; and for</span>
<a name="line-344"></a>  <span class="c1">// computing/receiving lower and upper bounds of global node IDs our chare&#39;s</span>
<a name="line-345"></a>  <span class="c1">// linear system will operate on after reordering.</span>
<a name="line-346"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4prep</span><span class="p">();</span>
<a name="line-347"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4bounds</span><span class="p">();</span>
<a name="line-348"></a>
<a name="line-349"></a>  <span class="c1">// Send out request for new global node IDs for nodes we do not reorder</span>
<a name="line-350"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">m_reordcomm</span><span class="p">)</span>
<a name="line-351"></a>    <span class="n">thisProxy</span><span class="p">[</span> <span class="n">c</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">request</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
<a name="line-352"></a>
<a name="line-353"></a>  <span class="c1">// Lambda to decide if node is assigned a new ID by this chare. If node is not</span>
<a name="line-354"></a>  <span class="c1">// found in the asymmetric communication map, it is owned, i.e., this chare</span>
<a name="line-355"></a>  <span class="c1">// assigns its new id.</span>
<a name="line-356"></a>  <span class="k">auto</span> <span class="n">ownnode</span> <span class="o">=</span> <span class="p">[</span> <span class="k">this</span> <span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-357"></a>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
<a name="line-358"></a>                        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m_reordcomm</span><span class="p">)</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<a name="line-359"></a>                        <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-360"></a>  <span class="p">};</span>
<a name="line-361"></a>
<a name="line-362"></a>  <span class="c1">// Reorder our chunk of the mesh node IDs. Looping through all of our node</span>
<a name="line-363"></a>  <span class="c1">// IDs, we test if we are to assign a new ID to a node ID, and if so, we</span>
<a name="line-364"></a>  <span class="c1">// assign a new ID, i.e., reorder, by constructing a map associating new to</span>
<a name="line-365"></a>  <span class="c1">// old IDs (m_newnodes). We also count up the reordered nodes, which serves as</span>
<a name="line-366"></a>  <span class="c1">// the new node id. We also store the node coordinates associated to the new</span>
<a name="line-367"></a>  <span class="c1">// node ID.</span>
<a name="line-368"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m_nodeset</span><span class="p">)</span>
<a name="line-369"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">ownnode</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<a name="line-370"></a>      <span class="n">m_newnodes</span><span class="p">[</span> <span class="n">p</span> <span class="p">]</span> <span class="o">=</span> <span class="n">m_start</span><span class="p">;</span>        <span class="c1">// assign new node ID (reorder)</span>
<a name="line-371"></a>      <span class="n">m_newcoordmap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">m_start</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_coordmap</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="p">);</span>
<a name="line-372"></a>      <span class="o">++</span><span class="n">m_start</span><span class="p">;</span>
<a name="line-373"></a>    <span class="p">}</span>
<a name="line-374"></a>
<a name="line-375"></a>  <span class="c1">// Trigger SDAG wait indicating that reordering our node IDs are complete</span>
<a name="line-376"></a>  <span class="n">reorderowned_complete</span><span class="p">();</span>
<a name="line-377"></a>
<a name="line-378"></a>  <span class="c1">// If all our nodes have new IDs assigned, reordering complete on this chare</span>
<a name="line-379"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_newnodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">finish</span><span class="p">();</span>
<a name="line-380"></a><span class="p">}</span>
<a name="line-381"></a>
<a name="line-382"></a><span class="kt">void</span>
<a name="line-383"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">request</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">nd</span> <span class="p">)</span>
<a name="line-384"></a><span class="c1">// *****************************************************************************</span>
<a name="line-385"></a><span class="c1">//  Request new global node IDs for old node IDs</span>
<a name="line-386"></a><span class="c1">//! \param[in] c Chare request coming from and to which we send new IDs to</span>
<a name="line-387"></a><span class="c1">//! \param[in] nd Set of old node IDs whose new IDs are requested</span>
<a name="line-388"></a><span class="c1">// *****************************************************************************</span>
<a name="line-389"></a><span class="p">{</span>
<a name="line-390"></a>  <span class="c1">// Queue up requesting chare and node IDs</span>
<a name="line-391"></a>  <span class="n">m_reqnodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">c</span><span class="p">,</span> <span class="n">nd</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-392"></a>  <span class="c1">// Trigger SDAG wait signaling that node IDs have been requested from us</span>
<a name="line-393"></a>  <span class="n">nodes_requested_complete</span><span class="p">();</span>
<a name="line-394"></a><span class="p">}</span>
<a name="line-395"></a>
<a name="line-396"></a><span class="kt">void</span>
<a name="line-397"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">prepare</span><span class="p">()</span>
<a name="line-398"></a><span class="c1">// *****************************************************************************</span>
<a name="line-399"></a><span class="c1">//  Find new node IDs for old ones and return them to the requestor(s)</span>
<a name="line-400"></a><span class="c1">// *****************************************************************************</span>
<a name="line-401"></a><span class="p">{</span>
<a name="line-402"></a>  <span class="c1">// Find and return new node IDs to sender</span>
<a name="line-403"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">r</span> <span class="p">:</span> <span class="n">m_reqnodes</span><span class="p">)</span> <span class="p">{</span>
<a name="line-404"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
<a name="line-405"></a>      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coord</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">;</span>
<a name="line-406"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">r</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-407"></a>      <span class="k">auto</span> <span class="n">newid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">m_newnodes</span><span class="p">,</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-408"></a>      <span class="n">n</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">p</span><span class="p">,</span>
<a name="line-409"></a>        <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span> <span class="n">newid</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_newcoordmap</span><span class="p">,</span><span class="n">newid</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-410"></a>    <span class="p">}</span>
<a name="line-411"></a>    <span class="n">thisProxy</span><span class="p">[</span> <span class="n">r</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">neworder</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-412"></a>  <span class="p">}</span>
<a name="line-413"></a>
<a name="line-414"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_reqnodes</span> <span class="p">);</span> <span class="c1">// Clear queue of requests just fulfilled</span>
<a name="line-415"></a>
<a name="line-416"></a>  <span class="c1">// Re-enable SDAG wait for preparing new node requests</span>
<a name="line-417"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4prep</span><span class="p">();</span>
<a name="line-418"></a>
<a name="line-419"></a>  <span class="c1">// Re-enable trigger signaling that reordering of owned node IDs are</span>
<a name="line-420"></a>  <span class="c1">// complete right away</span>
<a name="line-421"></a>  <span class="n">reorderowned_complete</span><span class="p">();</span>
<a name="line-422"></a><span class="p">}</span>
<a name="line-423"></a>
<a name="line-424"></a><span class="kt">void</span>
<a name="line-425"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">neworder</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
<a name="line-426"></a>                        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coord</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">nodes</span> <span class="p">)</span>
<a name="line-427"></a><span class="c1">// *****************************************************************************</span>
<a name="line-428"></a><span class="c1">//  Receive new (reordered) global node IDs</span>
<a name="line-429"></a><span class="c1">//! \param[in] nodes Map associating new to old node IDs</span>
<a name="line-430"></a><span class="c1">// *****************************************************************************</span>
<a name="line-431"></a><span class="p">{</span>
<a name="line-432"></a>  <span class="c1">// Store new node IDs associated to old ones, and node coordinates associated</span>
<a name="line-433"></a>  <span class="c1">// to new node IDs.</span>
<a name="line-434"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
<a name="line-435"></a>    <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
<a name="line-436"></a>    <span class="n">m_newnodes</span><span class="p">[</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
<a name="line-437"></a>    <span class="n">m_newcoordmap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-438"></a>  <span class="p">}</span>
<a name="line-439"></a>
<a name="line-440"></a>  <span class="c1">// If all our nodes have new IDs assigned, reorder complete on this PE</span>
<a name="line-441"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_newnodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">finish</span><span class="p">();</span>
<a name="line-442"></a><span class="p">}</span>
<a name="line-443"></a>
<a name="line-444"></a><span class="kt">void</span>
<a name="line-445"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">finish</span><span class="p">()</span>
<a name="line-446"></a><span class="c1">// *****************************************************************************</span>
<a name="line-447"></a><span class="c1">//  Compute final result of reordering</span>
<a name="line-448"></a><span class="c1">//! \details Reordering is now complete on this chare. We now remap all mesh</span>
<a name="line-449"></a><span class="c1">//!   data to reflect the new ordering.</span>
<a name="line-450"></a><span class="c1">// *****************************************************************************</span>
<a name="line-451"></a><span class="p">{</span>
<a name="line-452"></a>  <span class="c1">// Update elem connectivity with the reordered node IDs</span>
<a name="line-453"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m_ginpoel</span><span class="p">)</span> <span class="n">p</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">m_newnodes</span><span class="p">,</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-454"></a>
<a name="line-455"></a>  <span class="c1">// Update node coordinate map with the reordered IDs</span>
<a name="line-456"></a>  <span class="n">m_coordmap</span> <span class="o">=</span> <span class="n">m_newcoordmap</span><span class="p">;</span>
<a name="line-457"></a>
<a name="line-458"></a>  <span class="c1">// Update symmetric chare-node communication map with the reordered IDs</span>
<a name="line-459"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">m_msum</span><span class="p">)</span> <span class="p">{</span>
<a name="line-460"></a>    <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
<a name="line-461"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">c</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">n</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="p">);</span>
<a name="line-462"></a>    <span class="n">c</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-463"></a>  <span class="p">}</span>
<a name="line-464"></a>
<a name="line-465"></a>  <span class="c1">// Update unique global node IDs of this chare with the reordered node IDs</span>
<a name="line-466"></a>  <span class="n">m_nodeset</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-467"></a>  <span class="n">m_nodeset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">m_ginpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">m_ginpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-468"></a>
<a name="line-469"></a>  <span class="c1">// Progress report to host</span>
<a name="line-470"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chreordered</span><span class="p">();</span>
<a name="line-471"></a>
<a name="line-472"></a>  <span class="c1">// Compute lower and upper bounds of reordered node IDs on this chare</span>
<a name="line-473"></a>  <span class="n">bounds</span><span class="p">();</span>
<a name="line-474"></a><span class="p">}</span>
<a name="line-475"></a>
<a name="line-476"></a><span class="kt">void</span>
<a name="line-477"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">bounds</span><span class="p">()</span>
<a name="line-478"></a><span class="c1">// *****************************************************************************</span>
<a name="line-479"></a><span class="c1">// Compute lower and upper bounds of reordered node IDs for this chare</span>
<a name="line-480"></a><span class="c1">//! \details This function computes the bounds that this chare will contribute</span>
<a name="line-481"></a><span class="c1">//!   to in a linear system solve. We find the largest node ID assigned on each</span>
<a name="line-482"></a><span class="c1">//!   chare by the reordering and use that as the upper global row index for</span>
<a name="line-483"></a><span class="c1">//!   this chare. Note that while this rarely results in equal number of rows</span>
<a name="line-484"></a><span class="c1">//!   assigned to chares, potentially resulting in some load-imbalance, it</span>
<a name="line-485"></a><span class="c1">//!   yields a pretty good division reducing communication costs during the</span>
<a name="line-486"></a><span class="c1">//!   assembly of the linear system, which is more important than a slight</span>
<a name="line-487"></a><span class="c1">//!   (FLOP) load imbalance. Since the upper index for chare 1 is the same as</span>
<a name="line-488"></a><span class="c1">//!   the lower index for chare 2, etc., we find the upper indices and then the</span>
<a name="line-489"></a><span class="c1">//!   lower indices for all chares are communicated.</span>
<a name="line-490"></a><span class="c1">// *****************************************************************************</span>
<a name="line-491"></a><span class="p">{</span>
<a name="line-492"></a>  <span class="n">m_upper</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">m_nodeset</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">m_nodeset</span><span class="p">)</span> <span class="p">);</span>
<a name="line-493"></a>
<a name="line-494"></a>  <span class="c1">// The bounds are the dividers (global mesh point indices) at which the linear</span>
<a name="line-495"></a>  <span class="c1">// system assembly is divided among PEs. However, Solver expect exclusive</span>
<a name="line-496"></a>  <span class="c1">// upper indices, so we increase the last one by one here.</span>
<a name="line-497"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">thisIndex</span> <span class="o">==</span> <span class="n">m_nchare</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">++</span><span class="n">m_upper</span><span class="p">;</span>
<a name="line-498"></a>
<a name="line-499"></a>  <span class="c1">// Tell the runtime system that the upper bound has been computed</span>
<a name="line-500"></a>  <span class="n">upper_complete</span><span class="p">();</span>
<a name="line-501"></a>
<a name="line-502"></a>  <span class="c1">// Set lower index for chare 0 as 0</span>
<a name="line-503"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">thisIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">lower</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-504"></a>
<a name="line-505"></a>  <span class="c1">// All chares except the last one send their upper bound as the lower index for</span>
<a name="line-506"></a>  <span class="c1">// the chare with thisIndex+1</span>
<a name="line-507"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">thisIndex</span> <span class="o">&lt;</span> <span class="n">m_nchare</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span><span class="o">+</span><span class="mi">1</span> <span class="p">].</span><span class="n">lower</span><span class="p">(</span> <span class="n">m_upper</span> <span class="p">);</span>
<a name="line-508"></a><span class="p">}</span>
<a name="line-509"></a>
<a name="line-510"></a><span class="kt">void</span>
<a name="line-511"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">lower</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">low</span> <span class="p">)</span>
<a name="line-512"></a><span class="c1">// *****************************************************************************</span>
<a name="line-513"></a><span class="c1">//  Receive lower bound of node IDs for this chare</span>
<a name="line-514"></a><span class="c1">//! \param[in] low Lower bound of node IDs assigned to this chare</span>
<a name="line-515"></a><span class="c1">// *****************************************************************************</span>
<a name="line-516"></a><span class="p">{</span>
<a name="line-517"></a>  <span class="n">m_lower</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
<a name="line-518"></a>  <span class="n">lower_complete</span><span class="p">();</span>
<a name="line-519"></a><span class="p">}</span>
<a name="line-520"></a>
<a name="line-521"></a><span class="kt">void</span>
<a name="line-522"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">create</span><span class="p">()</span>
<a name="line-523"></a><span class="c1">// *****************************************************************************</span>
<a name="line-524"></a><span class="c1">// Create chare array elements on this PE and assign the global mesh element IDs</span>
<a name="line-525"></a><span class="c1">// they will operate on</span>
<a name="line-526"></a><span class="c1">// *****************************************************************************</span>
<a name="line-527"></a><span class="p">{</span>
<a name="line-528"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">())</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chbounds</span><span class="p">();</span>
<a name="line-529"></a>
<a name="line-530"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">scheme</span> <span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">MatCG</span><span class="p">)</span>
<a name="line-531"></a>    <span class="c1">// broadcast this chare&#39;s bounds of global node IDs to matrix solvers</span>
<a name="line-532"></a>    <span class="n">m_solver</span><span class="p">.</span><span class="n">ckLocalBranch</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">chbounds</span><span class="p">(</span> <span class="n">m_lower</span><span class="p">,</span> <span class="n">m_upper</span> <span class="p">);</span>
<a name="line-533"></a>  <span class="k">else</span> <span class="c1">// if no MatCG, no matrix solver, continue</span>
<a name="line-534"></a>    <span class="n">createDiscWorkers</span><span class="p">();</span>
<a name="line-535"></a><span class="p">}</span>
<a name="line-536"></a>
<a name="line-537"></a><span class="kt">void</span>
<a name="line-538"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">createDiscWorkers</span><span class="p">()</span>
<a name="line-539"></a><span class="c1">// *****************************************************************************</span>
<a name="line-540"></a><span class="c1">//  Create Discretization chare array elements on this PE</span>
<a name="line-541"></a><span class="c1">//! \details We create chare array elements by calling the insert() member</span>
<a name="line-542"></a><span class="c1">//!   function, which allows specifying the PE on which the array element is</span>
<a name="line-543"></a><span class="c1">//!   created. and we send each chare array element the chunk of mesh it will</span>
<a name="line-544"></a><span class="c1">//!   operate on.</span>
<a name="line-545"></a><span class="c1">// *****************************************************************************</span>
<a name="line-546"></a><span class="p">{</span>
<a name="line-547"></a>  <span class="c1">// Create worker array element using Charm++ dynamic chare array element</span>
<a name="line-548"></a>  <span class="c1">// insertion: 1st arg: chare id, last arg: PE chare is created on, middle</span>
<a name="line-549"></a>  <span class="c1">// args: Discretization ctor args. See also Charm++ manual, Sec. &quot;Dynamic</span>
<a name="line-550"></a>  <span class="c1">// Insertion&quot;.</span>
<a name="line-551"></a>  <span class="n">m_scheme</span><span class="p">.</span><span class="n">discInsert</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">m_host</span><span class="p">,</span> <span class="n">m_ginpoel</span><span class="p">,</span> <span class="n">m_coordmap</span><span class="p">,</span> <span class="n">m_msum</span><span class="p">,</span>
<a name="line-552"></a>                       <span class="n">m_nchare</span><span class="p">,</span> <span class="n">CkMyPe</span><span class="p">()</span> <span class="p">);</span>
<a name="line-553"></a>
<a name="line-554"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discinserted</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-555"></a><span class="p">}</span>
<a name="line-556"></a>
<a name="line-557"></a><span class="kt">void</span>
<a name="line-558"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">createWorkers</span><span class="p">()</span>
<a name="line-559"></a><span class="c1">// *****************************************************************************</span>
<a name="line-560"></a><span class="c1">//  Create worker chare array element</span>
<a name="line-561"></a><span class="c1">// *****************************************************************************</span>
<a name="line-562"></a><span class="p">{</span>
<a name="line-563"></a>  <span class="c1">// If there was no reordering, assign a one-to-one node-map</span>
<a name="line-564"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_newnodes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">m_nodeset</span><span class="p">)</span> <span class="n">m_newnodes</span><span class="p">[</span> <span class="n">n</span> <span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<a name="line-565"></a>
<a name="line-566"></a>  <span class="c1">// Extract this chare&#39;s portion of the boundary node lists</span>
<a name="line-567"></a>  <span class="k">decltype</span><span class="p">(</span><span class="n">m_bnode</span><span class="p">)</span> <span class="n">chbnode</span><span class="p">;</span>
<a name="line-568"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">m_bnode</span><span class="p">)</span> <span class="p">{</span>
<a name="line-569"></a>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">chbnode</span><span class="p">[</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">];</span>
<a name="line-570"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-571"></a>      <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">m_newnodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<a name="line-572"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">))</span> <span class="n">n</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">second</span> <span class="p">);</span>
<a name="line-573"></a>    <span class="p">}</span>
<a name="line-574"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">chbnode</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
<a name="line-575"></a>  <span class="p">}</span>
<a name="line-576"></a>  <span class="c1">// Make boundary node IDs unique for each physical boundary (side set)</span>
<a name="line-577"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">chbnode</span><span class="p">)</span> <span class="n">tk</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
<a name="line-578"></a>
<a name="line-579"></a>  <span class="c1">// Generate set of all mesh faces</span>
<a name="line-580"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">FaceSet</span> <span class="n">faceset</span><span class="p">;</span>
<a name="line-581"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">m_ginpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for all tets</span>
<a name="line-582"></a>    <span class="k">auto</span> <span class="n">mark</span> <span class="o">=</span> <span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
<a name="line-583"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">f</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">f</span><span class="p">)</span> <span class="c1">// for all tet faces</span>
<a name="line-584"></a>      <span class="n">faceset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="p">{{{</span> <span class="n">m_ginpoel</span><span class="p">[</span> <span class="n">mark</span> <span class="o">+</span> <span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">],</span>
<a name="line-585"></a>                          <span class="n">m_ginpoel</span><span class="p">[</span> <span class="n">mark</span> <span class="o">+</span> <span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">],</span>
<a name="line-586"></a>                          <span class="n">m_ginpoel</span><span class="p">[</span> <span class="n">mark</span> <span class="o">+</span> <span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">}}}</span> <span class="p">);</span>
<a name="line-587"></a>  <span class="p">}</span>
<a name="line-588"></a>
<a name="line-589"></a>  <span class="c1">// Extract this chare&#39;s portion of the boundary faces and their connectivity</span>
<a name="line-590"></a>  <span class="k">decltype</span><span class="p">(</span><span class="n">m_bface</span><span class="p">)</span> <span class="n">chbface</span><span class="p">;</span>
<a name="line-591"></a>  <span class="k">decltype</span><span class="p">(</span><span class="n">m_triinpoel</span><span class="p">)</span> <span class="n">chtriinpoel</span><span class="p">;</span>
<a name="line-592"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-593"></a>
<a name="line-594"></a>  <span class="c1">// Generate boundary </span>
<a name="line-595"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">ss</span> <span class="p">:</span> <span class="n">m_bface</span><span class="p">)</span>  <span class="c1">// for all phsyical boundaries (sidesets)</span>
<a name="line-596"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">ss</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// for all faces on this physical boundary</span>
<a name="line-597"></a>      <span class="c1">// attempt to find face nodes on this chare</span>
<a name="line-598"></a>      <span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">m_newnodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
<a name="line-599"></a>      <span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">m_newnodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
<a name="line-600"></a>      <span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">m_newnodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">m_triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="p">);</span>
<a name="line-601"></a>      <span class="c1">// if all 3 nodes of the physical boundary face are on this chare</span>
<a name="line-602"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">f1</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">f2</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">f3</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">))</span> <span class="p">{</span>
<a name="line-603"></a>        <span class="c1">// Create face with new node ids (after mesh node reordering)</span>
<a name="line-604"></a>        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">{{</span><span class="n">f1</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">f2</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">f3</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">}};</span>
<a name="line-605"></a>        <span class="c1">// if this boundary face is on this chare</span>
<a name="line-606"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">faceset</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">faceset</span><span class="p">))</span> <span class="p">{</span>
<a name="line-607"></a>          <span class="c1">// store face connectivity with new (global) node ids of this chare</span>
<a name="line-608"></a>          <span class="n">chtriinpoel</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">end</span><span class="p">(</span><span class="n">chtriinpoel</span><span class="p">),</span> <span class="n">begin</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">);</span>
<a name="line-609"></a>          <span class="c1">// generate/store physical boundary face id associated to sideset id</span>
<a name="line-610"></a>          <span class="n">chbface</span><span class="p">[</span> <span class="n">ss</span><span class="p">.</span><span class="n">first</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">cnt</span><span class="o">++</span> <span class="p">);</span>
<a name="line-611"></a>        <span class="p">}</span>
<a name="line-612"></a>      <span class="p">}</span>
<a name="line-613"></a>    <span class="p">}</span>
<a name="line-614"></a>
<a name="line-615"></a>  <span class="c1">// Create face data</span>
<a name="line-616"></a>  <span class="n">FaceData</span> <span class="n">fd</span><span class="p">(</span> <span class="n">m_ginpoel</span><span class="p">,</span> <span class="n">chbface</span><span class="p">,</span> <span class="n">chbnode</span><span class="p">,</span> <span class="n">chtriinpoel</span> <span class="p">);</span>
<a name="line-617"></a>
<a name="line-618"></a>  <span class="c1">// Make sure (bound) base is already created and accessible</span>
<a name="line-619"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">m_scheme</span><span class="p">.</span><span class="n">get</span><span class="p">()[</span><span class="n">thisIndex</span><span class="p">].</span><span class="n">ckLocal</span><span class="p">()</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">,</span>
<a name="line-620"></a>          <span class="s">&quot;About to pass nullptr&quot;</span> <span class="p">);</span>
<a name="line-621"></a>
<a name="line-622"></a>  <span class="c1">// Create worker array element using Charm++ dynamic chare array element</span>
<a name="line-623"></a>  <span class="c1">// insertion: 1st arg: chare id, last arg: PE chare is created on, middle</span>
<a name="line-624"></a>  <span class="c1">// args: Discretization&#39;s child ctor args. See also Charm++ manual, Sec.</span>
<a name="line-625"></a>  <span class="c1">// &quot;Dynamic Insertion&quot;.</span>
<a name="line-626"></a>  <span class="n">m_scheme</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">m_scheme</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">m_solver</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">CkMyPe</span><span class="p">()</span> <span class="p">);</span>
<a name="line-627"></a>
<a name="line-628"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chcreated</span><span class="p">();</span>
<a name="line-629"></a>
<a name="line-630"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">workinserted</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-631"></a><span class="p">}</span>
<a name="line-632"></a>
<a name="line-633"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/sorter.def.h&quot;</span><span class="cp"></span>
</pre></div>
</td></tr></table>
      </div>
      <div id="footer">
        <p>
         Cppcheck 1.86 - a tool for static C/C++ code analysis</br>
         </br>
         Internet: <a href="http://cppcheck.net">http://cppcheck.net</a></br>
         IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a></br>
        <p>
      </div>
  </body>
</html>
