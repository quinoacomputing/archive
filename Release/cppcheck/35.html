
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href="https://github.com/quinoacomputing/quinoa/commit/cfa3f59">Quinoa_v0.2-145-gcfa3f59</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script language="javascript">
      function getStyle(el,styleProp) {
        if (el.currentStyle)
          var y = el.currentStyle[styleProp];
        else if (window.getComputedStyle)
          var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
        return y;
      }
      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;
        if (el.style.display == "block") {
          el.style.display = "none";
          mark.innerHTML = "[+]";
        } else {
          el.style.display = "block";
          mark.innerHTML = "[-]";
        }
      }
      function init_expandables() {
        var elts = document.getElementsByClassName("expandable");
        for (var i = 0; i < elts.length; i++) {
          var el = elts[i];
          var clickable = el.getElementsByTagName("span")[0];
          var marker = clickable.getElementsByClassName("marker")[0];
          var content = el.getElementsByClassName("content")[0];
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.onclick = toggle;
        }
      }
      function set_class_display(c, st) {
        var elements = document.querySelectorAll('.' + c),
            len = elements.length;
        for (i = 0; i < len; i++) {
            elements[i].style.display = st;
        }
      }
      function toggle_class_visibility(id) {
        var box = document.getElementById(id);
        set_class_display(id, box.checked ? '' : 'none');
      }
    </script>
  </head>
  <body onload="init_expandables()">
      <div id="header">
        <h1>Cppcheck report - [<a href="https://github.com/quinoacomputing/quinoa/commit/cfa3f59">Quinoa_v0.2-145-gcfa3f59</a>]: /tmp/TeamCity-14/work/821a9fd6f64749d9/src/Mesh/DerivedData.C </h1>
      </div>
      <div id="menu" dir="rtl">
       <p id="filename"><a href="index.html">Defects:</a> DerivedData.C</p>
<a href='35.html#line-202'> unusedFunction 202</a><a href='35.html#line-305'> unusedFunction 305</a><a href='35.html#line-483'> unusedFunction 483</a><a href='35.html#line-572'> unusedFunction 572</a><a href='35.html#line-692'> unusedFunction 692</a>
      </div>
      <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Mesh/DerivedData.C</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015, J. Bakosi, 2016-2017, Los Alamos National Security, LLC.</span>
<a name="line-5"></a><span class="cm">  \brief     Generate data structures derived from unstructured mesh</span>
<a name="line-6"></a><span class="cm">  \details   Generate data structures derived from the connectivity information</span>
<a name="line-7"></a><span class="cm">     of an unstructured mesh.</span>
<a name="line-8"></a><span class="cm">*/</span>
<a name="line-9"></a><span class="c1">// *****************************************************************************</span>
<a name="line-10"></a>
<a name="line-11"></a><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<a name="line-12"></a><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<a name="line-13"></a><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<a name="line-14"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-15"></a><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<a name="line-16"></a><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<a name="line-17"></a>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&quot;Exception.h&quot;                  // for Assert</span><span class="cp"></span>
<a name="line-19"></a><span class="cp">#include</span> <span class="cpf">&quot;DerivedData.h&quot;</span><span class="cp"></span>
<a name="line-20"></a>
<a name="line-21"></a><span class="k">namespace</span> <span class="n">tk</span> <span class="p">{</span>
<a name="line-22"></a>
<a name="line-23"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-24"></a><span class="n">genEsup</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span> <span class="p">)</span>
<a name="line-25"></a><span class="c1">// *****************************************************************************</span>
<a name="line-26"></a><span class="c1">//  Generate derived data structure, elements surrounding points</span>
<a name="line-27"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-28"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-29"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-30"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-31"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-32"></a><span class="c1">//!   \endcode</span>
<a name="line-33"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-34"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-35"></a><span class="c1">//! \param[in] nnpe Number of nodes per element</span>
<a name="line-36"></a><span class="c1">//! \return Linked lists storing elements surrounding points</span>
<a name="line-37"></a><span class="c1">//! \warning It is not okay to call this function with an empty container or a</span>
<a name="line-38"></a><span class="c1">//!   non-positive number of nodes per element; it will throw an exception.</span>
<a name="line-39"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-40"></a><span class="c1">//!   two linked arrays (vectors), _esup1_ and _esup2_, where _esup2_ holds the</span>
<a name="line-41"></a><span class="c1">//!   indices at which _esup1_ holds the element ids surrounding points. Looping</span>
<a name="line-42"></a><span class="c1">//!   over all elements surrounding all points can then be accomplished by the</span>
<a name="line-43"></a><span class="c1">//!   following loop:</span>
<a name="line-44"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-45"></a><span class="c1">//!     for (std::size_t p=0; p&lt;npoin; ++p)</span>
<a name="line-46"></a><span class="c1">//!       for (auto i=esup.second[p]+1; i&lt;=esup.second[p+1]; ++i)</span>
<a name="line-47"></a><span class="c1">//!          use element id esup.first[i]</span>
<a name="line-48"></a><span class="c1">//!   \endcode</span>
<a name="line-49"></a><span class="c1">//!     To find out the number of points, _npoin_, the mesh connectivity,</span>
<a name="line-50"></a><span class="c1">//!     _inpoel_, can be queried:</span>
<a name="line-51"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-52"></a><span class="c1">//!     auto minmax = std::minmax_element( begin(inpoel), end(inpoel) );</span>
<a name="line-53"></a><span class="c1">//!     Assert( *minmax.first == 0, &quot;node ids should start from zero&quot; );</span>
<a name="line-54"></a><span class="c1">//!     auto npoin = *minmax.second + 1;</span>
<a name="line-55"></a><span class="c1">//!   \endcode</span>
<a name="line-56"></a><span class="c1">//! \note In principle, this function *should* work for any positive nnpe,</span>
<a name="line-57"></a><span class="c1">//!   however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</span>
<a name="line-58"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-59"></a><span class="c1">// *****************************************************************************</span>
<a name="line-60"></a><span class="p">{</span>
<a name="line-61"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsup() on empty container&quot;</span> <span class="p">);</span>
<a name="line-62"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genEsup() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-63"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-64"></a>
<a name="line-65"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-66"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-67"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-68"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-69"></a>
<a name="line-70"></a>  <span class="c1">// allocate one of the linked lists storing elements surrounding points: esup2</span>
<a name="line-71"></a>  <span class="c1">// fill with zeros</span>
<a name="line-72"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esup2</span><span class="p">(</span> <span class="n">npoin</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-73"></a>
<a name="line-74"></a>  <span class="c1">// element pass 1: count number of elements connected to each point</span>
<a name="line-75"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">inpoel</span><span class="p">)</span> <span class="o">++</span><span class="n">esup2</span><span class="p">[</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">];</span>
<a name="line-76"></a>
<a name="line-77"></a>  <span class="c1">// storage/reshuffling pass 1: update storage counter and store</span>
<a name="line-78"></a>  <span class="c1">// also find out the maximum size of esup1 (mesup)</span>
<a name="line-79"></a>  <span class="k">auto</span> <span class="n">mesup</span> <span class="o">=</span> <span class="n">esup2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-80"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npoin</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<a name="line-81"></a>    <span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<a name="line-82"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">mesup</span><span class="p">)</span> <span class="n">mesup</span> <span class="o">=</span> <span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-83"></a>  <span class="p">}</span>
<a name="line-84"></a>
<a name="line-85"></a>  <span class="c1">// now we know mesup, so allocate the other one of the linked lists storing</span>
<a name="line-86"></a>  <span class="c1">// elements surrounding points: esup1</span>
<a name="line-87"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esup1</span><span class="p">(</span> <span class="n">mesup</span> <span class="p">);</span>
<a name="line-88"></a>
<a name="line-89"></a>  <span class="c1">// store the elements in esup1</span>
<a name="line-90"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-91"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">inpoel</span><span class="p">)</span> <span class="p">{</span>
<a name="line-92"></a>    <span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">esup2</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-93"></a>    <span class="n">esup2</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<a name="line-94"></a>    <span class="n">esup1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span>
<a name="line-95"></a>    <span class="o">++</span><span class="n">e</span><span class="p">;</span>
<a name="line-96"></a>  <span class="p">}</span>
<a name="line-97"></a>
<a name="line-98"></a>  <span class="c1">// storage/reshuffling pass 2</span>
<a name="line-99"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">npoin</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<a name="line-100"></a>  <span class="n">esup2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-101"></a>
<a name="line-102"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-103"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esup1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esup2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-104"></a><span class="p">}</span>
<a name="line-105"></a>
<a name="line-106"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-107"></a><span class="n">genPsup</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span>
<a name="line-108"></a>         <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-109"></a>         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-110"></a>                          <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-111"></a><span class="c1">// *****************************************************************************</span>
<a name="line-112"></a><span class="c1">//  Generate derived data structure, points surrounding points</span>
<a name="line-113"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-114"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-115"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-116"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-117"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-118"></a><span class="c1">//!   \endcode</span>
<a name="line-119"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-120"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-121"></a><span class="c1">//! \param[in] nnpe Number of nodes per element</span>
<a name="line-122"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-123"></a><span class="c1">//! \return Linked lists storing points surrounding points</span>
<a name="line-124"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-125"></a><span class="c1">//!   inpoel or esup.first or esup.second or a non-positive number of nodes per</span>
<a name="line-126"></a><span class="c1">//!   element; it will throw an exception.</span>
<a name="line-127"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-128"></a><span class="c1">//!   two linked arrays (vectors), _psup1_ and _psup2_, where _psup2_ holds the</span>
<a name="line-129"></a><span class="c1">//!   indices at which _psup1_ holds the point ids surrounding points. Looping</span>
<a name="line-130"></a><span class="c1">//!   over all points surrounding all points can then be accomplished by the</span>
<a name="line-131"></a><span class="c1">//!   following loop:</span>
<a name="line-132"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-133"></a><span class="c1">//!     for (std::size_t p=0; p&lt;npoin; ++p)</span>
<a name="line-134"></a><span class="c1">//!       for (auto i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i)</span>
<a name="line-135"></a><span class="c1">//!          use point id psup.first[i]</span>
<a name="line-136"></a><span class="c1">//!   \endcode</span>
<a name="line-137"></a><span class="c1">//!    To find out the number of points, _npoin_, the mesh connectivity,</span>
<a name="line-138"></a><span class="c1">//!    _inpoel_, can be queried:</span>
<a name="line-139"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-140"></a><span class="c1">//!     auto minmax = std::minmax_element( begin(inpoel), end(inpoel) );</span>
<a name="line-141"></a><span class="c1">//!     Assert( *minmax.first == 0, &quot;node ids should start from zero&quot; );</span>
<a name="line-142"></a><span class="c1">//!     auto npoin = *minmax.second + 1;</span>
<a name="line-143"></a><span class="c1">//!   \endcode</span>
<a name="line-144"></a><span class="c1">//!   or the length-1 of the generated index list:</span>
<a name="line-145"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-146"></a><span class="c1">//!     auto npoin = psup.second.size()-1;</span>
<a name="line-147"></a><span class="c1">//!   \endcode</span>
<a name="line-148"></a><span class="c1">//! \note In principle, this function *should* work for any positive nnpe,</span>
<a name="line-149"></a><span class="c1">//!   however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</span>
<a name="line-150"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-151"></a><span class="c1">// *****************************************************************************</span>
<a name="line-152"></a><span class="p">{</span>
<a name="line-153"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genPsup() on empty container&quot;</span> <span class="p">);</span>
<a name="line-154"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genPsup() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-155"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-156"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genPsup() with empty esup1&quot;</span> <span class="p">);</span>
<a name="line-157"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genPsup() with empty esup2&quot;</span> <span class="p">);</span>
<a name="line-158"></a>
<a name="line-159"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-160"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-161"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-162"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-163"></a>
<a name="line-164"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-165"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-166"></a>
<a name="line-167"></a>  <span class="c1">// allocate both of the linked lists storing points surrounding points, we</span>
<a name="line-168"></a>  <span class="c1">// only know the size of psup2, put in a single zero in psup1</span>
<a name="line-169"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">psup2</span><span class="p">(</span> <span class="n">npoin</span><span class="o">+</span><span class="mi">1</span> <span class="p">),</span> <span class="n">psup1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-170"></a>
<a name="line-171"></a>  <span class="c1">// allocate and fill with zeros a temporary array, only used locally</span>
<a name="line-172"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">lpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-173"></a>
<a name="line-174"></a>  <span class="c1">// fill both psup1 and psup2</span>
<a name="line-175"></a>  <span class="n">psup2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-176"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-177"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<a name="line-178"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-179"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-180"></a>        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">esup1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nnpe</span> <span class="o">+</span> <span class="n">n</span> <span class="p">];</span>
<a name="line-181"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-182"></a>          <span class="o">++</span><span class="n">j</span><span class="p">;</span>
<a name="line-183"></a>          <span class="n">psup1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">q</span> <span class="p">);</span>
<a name="line-184"></a>          <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-185"></a>        <span class="p">}</span>
<a name="line-186"></a>      <span class="p">}</span>
<a name="line-187"></a>    <span class="p">}</span>
<a name="line-188"></a>    <span class="n">psup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<a name="line-189"></a>  <span class="p">}</span>
<a name="line-190"></a>
<a name="line-191"></a>  <span class="c1">// sort point ids for each point in psup1</span>
<a name="line-192"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
<a name="line-193"></a>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span>
<a name="line-194"></a>      <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">psup1</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">),</span>
<a name="line-195"></a>      <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">psup1</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-196"></a>
<a name="line-197"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-198"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">psup1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">psup2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-199"></a><span class="p">}</span>
<a name="line-200"></a>
<a name="line-201"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-202"></a><span class="hll"><span class="n">genEdsup</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span><span class='error2'>&lt;--- The function 'genEdsup' is never used.</span>
</span><a name="line-203"></a>          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-204"></a>          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-205"></a>                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-206"></a><span class="c1">// *****************************************************************************</span>
<a name="line-207"></a><span class="c1">//  Generate derived data structure, edges surrounding points</span>
<a name="line-208"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-209"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-210"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-211"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-212"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-213"></a><span class="c1">//!   \endcode</span>
<a name="line-214"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-215"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-216"></a><span class="c1">//! \param[in] nnpe Number of nodes per element (3 or 4)</span>
<a name="line-217"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-218"></a><span class="c1">//! \return Linked lists storing edges (point ids p &lt; q) emanating from points</span>
<a name="line-219"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-220"></a><span class="c1">//!   inpoel or esup.first or esup.second or a non-positive number of nodes per</span>
<a name="line-221"></a><span class="c1">//!   element; it will throw an exception.</span>
<a name="line-222"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-223"></a><span class="c1">//!   two linked arrays (vectors), _edsup1_ and _edsup2_, where _edsup2_ holds</span>
<a name="line-224"></a><span class="c1">//!   the indices at which _edsup1_ holds the edge-end point ids emanating from</span>
<a name="line-225"></a><span class="c1">//!   points for all points. The generated data structure, linked lists edsup1</span>
<a name="line-226"></a><span class="c1">//!   and edsup2, are very similar to psup1 and psup2, generated by genPsup(),</span>
<a name="line-227"></a><span class="c1">//!   except here only unique edges are stored, i.e., for edges with point ids</span>
<a name="line-228"></a><span class="c1">//!   p &lt; q, only ids q are stored that are still associated to point p. Looping</span>
<a name="line-229"></a><span class="c1">//!   over all unique edges can then be accomplished by the following loop:</span>
<a name="line-230"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-231"></a><span class="c1">//!     for (std::size_t p=0; p&lt;npoin; ++p)</span>
<a name="line-232"></a><span class="c1">//!       for (auto i=edsup.second[p]+1; i&lt;=edsup.second[p+1]; ++i)</span>
<a name="line-233"></a><span class="c1">//!         use edge with point ids p &lt; edsup.first[i]</span>
<a name="line-234"></a><span class="c1">//!   \endcode</span>
<a name="line-235"></a><span class="c1">//!   To find out the number of points, _npoin_, the mesh connectivity,</span>
<a name="line-236"></a><span class="c1">//!   _inpoel_, can be queried:</span>
<a name="line-237"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-238"></a><span class="c1">//!     auto minmax = std::minmax_element( begin(inpoel), end(inpoel) );</span>
<a name="line-239"></a><span class="c1">//!     Assert( *minmax.first == 0, &quot;node ids should start from zero&quot; );</span>
<a name="line-240"></a><span class="c1">//!     auto npoin = *minmax.second + 1;</span>
<a name="line-241"></a><span class="c1">//!   \endcode</span>
<a name="line-242"></a><span class="c1">//! \note At first sight, this function seems to work for elements with more</span>
<a name="line-243"></a><span class="c1">//!   vertices than that of tetrahedra. However, that is not the case since the</span>
<a name="line-244"></a><span class="c1">//!   algorithm for nnpe &gt; 4 would erronously identify any two combination of</span>
<a name="line-245"></a><span class="c1">//!   vertices as a valid edge of an element. Since only triangles and</span>
<a name="line-246"></a><span class="c1">//!   tetrahedra have no internal edges, this algorithm only works for triangle</span>
<a name="line-247"></a><span class="c1">//!   and tetrahedra element connectivity.</span>
<a name="line-248"></a><span class="c1">//! \see tk::genInpoed for similar data that sometimes may be more advantageous</span>
<a name="line-249"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-250"></a><span class="c1">// *****************************************************************************</span>
<a name="line-251"></a><span class="p">{</span>
<a name="line-252"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEdsup() on empty container&quot;</span> <span class="p">);</span>
<a name="line-253"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genEdsup() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-254"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-255"></a>          <span class="s">&quot;Attempt to call genEdsup() with nodes per element, nnpe, that is &quot;</span>
<a name="line-256"></a>          <span class="s">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> <span class="p">);</span>
<a name="line-257"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-258"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEdsup() with empty esup1&quot;</span> <span class="p">);</span>
<a name="line-259"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEdsup() with empty esup2&quot;</span> <span class="p">);</span>
<a name="line-260"></a>
<a name="line-261"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-262"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-263"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-264"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-265"></a>
<a name="line-266"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-267"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-268"></a>
<a name="line-269"></a>  <span class="c1">// allocate and fill with zeros a temporary array, only used locally</span>
<a name="line-270"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">lpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-271"></a>
<a name="line-272"></a>  <span class="c1">// map to contain stars, a point associated to points connected with edges</span>
<a name="line-273"></a>  <span class="c1">// storing only the end-point id, q, of point ids p &lt; q</span>
<a name="line-274"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">star</span><span class="p">;</span>
<a name="line-275"></a>
<a name="line-276"></a>  <span class="c1">// generate edge connectivity and store as stars where center id &lt; spike id</span>
<a name="line-277"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
<a name="line-278"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
<a name="line-279"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-280"></a>        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">esup1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nnpe</span> <span class="o">+</span> <span class="n">n</span> <span class="p">];</span>
<a name="line-281"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-282"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span> <span class="n">star</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<a name="line-283"></a>          <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-284"></a>        <span class="p">}</span>
<a name="line-285"></a>      <span class="p">}</span>
<a name="line-286"></a>
<a name="line-287"></a>  <span class="c1">// linked lists (vectors) to store edges surrounding points and their indices</span>
<a name="line-288"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">edsup1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">edsup2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-289"></a>
<a name="line-290"></a>  <span class="c1">// sort non-center points of each star and store nodes and indices in vectors</span>
<a name="line-291"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">star</span><span class="p">)</span> <span class="p">{</span>
<a name="line-292"></a>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-293"></a>    <span class="n">edsup2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">edsup2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-294"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">edsup1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-295"></a>  <span class="p">}</span>
<a name="line-296"></a>  <span class="c1">// fill up index array with the last index for points with no new edges</span>
<a name="line-297"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npoin</span><span class="o">-</span><span class="n">star</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<a name="line-298"></a>    <span class="n">edsup2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">edsup2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="p">);</span>
<a name="line-299"></a>
<a name="line-300"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-301"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">edsup1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">edsup2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-302"></a><span class="p">}</span>
<a name="line-303"></a>
<a name="line-304"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-305"></a><span class="hll"><span class="n">genInpoed</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span><span class='error2'>&lt;--- The function 'genInpoed' is never used.</span>
</span><a name="line-306"></a>           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-307"></a>           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-308"></a>                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-309"></a><span class="c1">// *****************************************************************************</span>
<a name="line-310"></a><span class="c1">//  Generate derived data structure, edge connectivity</span>
<a name="line-311"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-312"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-313"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-314"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-315"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-316"></a><span class="c1">//!   \endcode</span>
<a name="line-317"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-318"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-319"></a><span class="c1">//! \param[in] nnpe Number of nodes per element (3 or 4)</span>
<a name="line-320"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-321"></a><span class="c1">//! \return Linear vector storing edge connectivity (point ids p &lt; q)</span>
<a name="line-322"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-323"></a><span class="c1">//!   inpoel or esup.first or esup.second or a non-positive number of nodes per</span>
<a name="line-324"></a><span class="c1">//!   element; it will throw an exception.</span>
<a name="line-325"></a><span class="c1">//! \details The data generated here is stored in a linear vector and is very</span>
<a name="line-326"></a><span class="c1">//!   similar to the linked lists, _edsup1_ and _edsup2, generated by</span>
<a name="line-327"></a><span class="c1">//!   genEdsup(). The difference is that in the linear vector, inpoed, generated</span>
<a name="line-328"></a><span class="c1">//!   here, both edge point ids are stored as a pair, p &lt; q, as opposed to the</span>
<a name="line-329"></a><span class="c1">//!   linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end</span>
<a name="line-330"></a><span class="c1">//!   point ids (still associated to edge-start point ids when used together</span>
<a name="line-331"></a><span class="c1">//!   with edsup2). The rationale is that while inpoed is larger in memory, it</span>
<a name="line-332"></a><span class="c1">//!   allows direct access to edges (pair of point ids making up an edge),</span>
<a name="line-333"></a><span class="c1">//!   edsup1 and edsup2 are smaller in memory, still allow accessing the same</span>
<a name="line-334"></a><span class="c1">//!   data (edge point id pairs) but only in a linear fashion, not by direct</span>
<a name="line-335"></a><span class="c1">//!   access to particular edges. Accessing all unique edges using the edge</span>
<a name="line-336"></a><span class="c1">//!   connectivity data structure, inpoed, generated here can be accomplished by</span>
<a name="line-337"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-338"></a><span class="c1">//!     for (std::size_t e=0; e&lt;inpoed.size()/2; ++e) {</span>
<a name="line-339"></a><span class="c1">//!       use point id p of edge e = inpoed[e*2];</span>
<a name="line-340"></a><span class="c1">//!       use point id q of edge e = inpoed[e*2+1];</span>
<a name="line-341"></a><span class="c1">//!     }</span>
<a name="line-342"></a><span class="c1">//!   \endcode</span>
<a name="line-343"></a><span class="c1">//! \note At first sight, this function seems to work for elements with more</span>
<a name="line-344"></a><span class="c1">//!   vertices than that of tetrahedra. However, that is not the case since the</span>
<a name="line-345"></a><span class="c1">//!   algorithm for nnpe &gt; 4 would erronously identify any two combination of</span>
<a name="line-346"></a><span class="c1">//!   vertices as a valid edge of an element. Since only triangles and</span>
<a name="line-347"></a><span class="c1">//!   tetrahedra have no internal edges, this algorithm only works for triangle</span>
<a name="line-348"></a><span class="c1">//!   and tetrahedra element connectivity.</span>
<a name="line-349"></a><span class="c1">//! \see tk::genEdsup for similar data that sometimes may be more advantageous</span>
<a name="line-350"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-351"></a><span class="c1">// *****************************************************************************</span>
<a name="line-352"></a><span class="p">{</span>
<a name="line-353"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genInpoed() on empty container&quot;</span> <span class="p">);</span>
<a name="line-354"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genInpoed() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-355"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-356"></a>          <span class="s">&quot;Attempt to call genInpoed() with nodes per element, nnpe, that is &quot;</span>
<a name="line-357"></a>          <span class="s">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> <span class="p">);</span>
<a name="line-358"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-359"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genInpoed() with empty esup1&quot;</span> <span class="p">);</span>
<a name="line-360"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span>
<a name="line-361"></a>          <span class="s">&quot;Attempt to call genInpoed() with empty esup2&quot;</span> <span class="p">);</span>
<a name="line-362"></a>
<a name="line-363"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-364"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-365"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-366"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-367"></a>
<a name="line-368"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-369"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-370"></a>
<a name="line-371"></a>  <span class="c1">// allocate and fill with zeros a temporary array, only used locally</span>
<a name="line-372"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">lpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-373"></a>
<a name="line-374"></a>  <span class="c1">// map to contain stars, a point associated to points connected with edges,</span>
<a name="line-375"></a>  <span class="c1">// storing only the end-point id, q, of point ids p &lt; q</span>
<a name="line-376"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">star</span><span class="p">;</span>
<a name="line-377"></a>
<a name="line-378"></a>  <span class="c1">// generate edge connectivity and store as stars where center id &lt; spike id</span>
<a name="line-379"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
<a name="line-380"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
<a name="line-381"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-382"></a>        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">esup1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nnpe</span> <span class="o">+</span> <span class="n">n</span> <span class="p">];</span>
<a name="line-383"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-384"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span> <span class="n">star</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">q</span> <span class="p">);</span>
<a name="line-385"></a>          <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-386"></a>        <span class="p">}</span>
<a name="line-387"></a>      <span class="p">}</span>
<a name="line-388"></a>
<a name="line-389"></a>  <span class="c1">// linear vector to store edge connectivity and their indices</span>
<a name="line-390"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoed</span><span class="p">;</span>
<a name="line-391"></a>
<a name="line-392"></a>  <span class="c1">// sort non-center points of each star and store both start and end points of</span>
<a name="line-393"></a>  <span class="c1">// each star in linear vector</span>
<a name="line-394"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">star</span><span class="p">)</span> <span class="p">{</span>
<a name="line-395"></a>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-396"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
<a name="line-397"></a>      <span class="n">inpoed</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
<a name="line-398"></a>      <span class="n">inpoed</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-399"></a>    <span class="p">}</span>
<a name="line-400"></a>  <span class="p">}</span>
<a name="line-401"></a>
<a name="line-402"></a>  <span class="c1">// Return (move out) linear vector</span>
<a name="line-403"></a>  <span class="k">return</span> <span class="n">inpoed</span><span class="p">;</span>
<a name="line-404"></a><span class="p">}</span>
<a name="line-405"></a>
<a name="line-406"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-407"></a><span class="n">genEsupel</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span>
<a name="line-408"></a>           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-409"></a>           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-410"></a>                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-411"></a><span class="c1">// *****************************************************************************</span>
<a name="line-412"></a><span class="c1">//  Generate derived data structure, elements surrounding points of elements</span>
<a name="line-413"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-414"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-415"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-416"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-417"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-418"></a><span class="c1">//!   \endcode</span>
<a name="line-419"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-420"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-421"></a><span class="c1">//! \param[in] nnpe Number of nodes per element</span>
<a name="line-422"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-423"></a><span class="c1">//! \return Linked lists storing elements surrounding points of elements</span>
<a name="line-424"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-425"></a><span class="c1">//!   inpoel or esup.first or esup.second or a non-positive number of nodes per</span>
<a name="line-426"></a><span class="c1">//!   element; it will throw an exception.</span>
<a name="line-427"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-428"></a><span class="c1">//!   two linked arrays (vectors), _esupel1_ and _esupel2_, where _esupel2_</span>
<a name="line-429"></a><span class="c1">//!   holds the indices at which _esupel1_ holds the element ids surrounding</span>
<a name="line-430"></a><span class="c1">//!   points of elements. Looping over all elements surrounding the points of</span>
<a name="line-431"></a><span class="c1">//!   all elements can then be accomplished by the following loop:</span>
<a name="line-432"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-433"></a><span class="c1">//!     for (std::size_t e=0; e&lt;nelem; ++e)</span>
<a name="line-434"></a><span class="c1">//!       for (auto i=esupel.second[e]+1; i&lt;=esupel.second[e+1]; ++i)</span>
<a name="line-435"></a><span class="c1">//!          use element id esupel.first[i]</span>
<a name="line-436"></a><span class="c1">//!   \endcode</span>
<a name="line-437"></a><span class="c1">//!   To find out the number of elements, _nelem_, the size of the mesh</span>
<a name="line-438"></a><span class="c1">//!   connectivity vector, _inpoel_, can be devided by the number of nodes per</span>
<a name="line-439"></a><span class="c1">//!   elements, _nnpe_:</span>
<a name="line-440"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-441"></a><span class="c1">//!     auto nelem = inpoel.size()/nnpe;</span>
<a name="line-442"></a><span class="c1">//!   \endcode</span>
<a name="line-443"></a><span class="c1">//! \note In principle, this function *should* work for any positive nnpe,</span>
<a name="line-444"></a><span class="c1">//!   however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</span>
<a name="line-445"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-446"></a><span class="c1">// *****************************************************************************</span>
<a name="line-447"></a><span class="p">{</span>
<a name="line-448"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsupel() on empty container&quot;</span> <span class="p">);</span>
<a name="line-449"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genEsupel() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-450"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-451"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsupel() with empty esup1&quot;</span> <span class="p">);</span>
<a name="line-452"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span>
<a name="line-453"></a>          <span class="s">&quot;Attempt to call genEsupel() with empty esup2&quot;</span> <span class="p">);</span>
<a name="line-454"></a>
<a name="line-455"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-456"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-457"></a>
<a name="line-458"></a>  <span class="c1">// linked lists storing elements surrounding points of elements, put in a</span>
<a name="line-459"></a>  <span class="c1">// single zero in both</span>
<a name="line-460"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esupel2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">esupel1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-461"></a>
<a name="line-462"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-463"></a>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esuel</span><span class="p">;</span>
<a name="line-464"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">inpoel</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// loop over all points of all elements</span>
<a name="line-465"></a>    <span class="c1">// collect unique element ids of elements surrounding points of element</span>
<a name="line-466"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">esuel</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">esup1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
<a name="line-467"></a>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">e</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>        <span class="c1">// when finished checking all nodes of element</span>
<a name="line-468"></a>      <span class="c1">// erase element whose surrounding elements are considered</span>
<a name="line-469"></a>      <span class="n">esuel</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">e</span><span class="o">/</span><span class="n">nnpe</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<a name="line-470"></a>      <span class="c1">// store unique element ids in esupel1</span>
<a name="line-471"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">esuel</span><span class="p">)</span> <span class="n">esupel1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
<a name="line-472"></a>      <span class="c1">// store end-index for element used to address into esupel1</span>
<a name="line-473"></a>      <span class="n">esupel2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">esupel2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">esuel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-474"></a>      <span class="n">esuel</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-475"></a>    <span class="p">}</span>
<a name="line-476"></a>  <span class="p">}</span>
<a name="line-477"></a>
<a name="line-478"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-479"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esupel1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esupel2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-480"></a><span class="p">}</span>
<a name="line-481"></a>
<a name="line-482"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-483"></a><span class="hll"><span class="n">genEsuel</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span><span class='error2'>&lt;--- The function 'genEsuel' is never used.</span>
</span><a name="line-484"></a>          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-485"></a>          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-486"></a>                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-487"></a><span class="c1">// *****************************************************************************</span>
<a name="line-488"></a><span class="c1">//  Generate derived data structure, elements surrounding elements</span>
<a name="line-489"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-490"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-491"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-492"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-493"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-494"></a><span class="c1">//!   \endcode</span>
<a name="line-495"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-496"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-497"></a><span class="c1">//! \param[in] nnpe Number of nodes per element</span>
<a name="line-498"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-499"></a><span class="c1">//! \return Linked lists storing elements surrounding elements</span>
<a name="line-500"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-501"></a><span class="c1">//!   inpoel or esup.first or esup.second; it will throw an exception.</span>
<a name="line-502"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-503"></a><span class="c1">//!   two linked arrays (vectors), _esuel1_ and _esuel2_, where _esuel2_ holds</span>
<a name="line-504"></a><span class="c1">//!   the indices at which _esuel1_ holds the element ids surrounding elements.</span>
<a name="line-505"></a><span class="c1">//!   Looping over elements surrounding elements can then be accomplished by the</span>
<a name="line-506"></a><span class="c1">//!   following loop:</span>
<a name="line-507"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-508"></a><span class="c1">//!     for (std::size_t e=0; e&lt;nelem; ++e)</span>
<a name="line-509"></a><span class="c1">//!       for (auto i=esuel.second[e]+1; i&lt;=esuel.second[e+1]; ++i)</span>
<a name="line-510"></a><span class="c1">//!          use element id esuel.first[i]</span>
<a name="line-511"></a><span class="c1">//!   \endcode</span>
<a name="line-512"></a><span class="c1">//!   To find out the number of elements, _nelem_, the size of the mesh</span>
<a name="line-513"></a><span class="c1">//!   connectivity vector, _inpoel_, can be devided by the number of nodes per</span>
<a name="line-514"></a><span class="c1">//!   elements, _nnpe_:</span>
<a name="line-515"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-516"></a><span class="c1">//!     auto nelem = inpoel.size()/nnpe;</span>
<a name="line-517"></a><span class="c1">//!   \endcode</span>
<a name="line-518"></a><span class="c1">//! \note In principle, this function *should* work for any positive nnpe,</span>
<a name="line-519"></a><span class="c1">//!   however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</span>
<a name="line-520"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-521"></a><span class="c1">// *****************************************************************************</span>
<a name="line-522"></a><span class="p">{</span>
<a name="line-523"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsuel() on empty container&quot;</span> <span class="p">);</span>
<a name="line-524"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genEsuel() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-525"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by four&quot;</span> <span class="p">);</span>
<a name="line-526"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsuel() with empty esuel1&quot;</span> <span class="p">);</span>
<a name="line-527"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span>
<a name="line-528"></a>          <span class="s">&quot;Attempt to call genEsuel() with empty esuel2&quot;</span> <span class="p">);</span>
<a name="line-529"></a>
<a name="line-530"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-531"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-532"></a>
<a name="line-533"></a>  <span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span>
<a name="line-534"></a>
<a name="line-535"></a>  <span class="c1">// lambda that returns true if elements hel and gel share a face</span>
<a name="line-536"></a>  <span class="k">auto</span> <span class="n">adj</span> <span class="o">=</span> <span class="p">[</span> <span class="o">&amp;</span><span class="n">inpoel</span><span class="p">,</span> <span class="n">nnpe</span> <span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">hel</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">gel</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
<a name="line-537"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> <span class="n">sp</span><span class="p">;</span>
<a name="line-538"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">h</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">h</span><span class="p">)</span>
<a name="line-539"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">g</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">g</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">g</span><span class="p">)</span>
<a name="line-540"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">inpoel</span><span class="p">[</span><span class="n">hel</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">h</span><span class="p">]</span> <span class="o">==</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">gel</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">g</span><span class="p">])</span> <span class="n">sp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<a name="line-541"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nnpe</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<a name="line-542"></a>  <span class="p">};</span>
<a name="line-543"></a>
<a name="line-544"></a>  <span class="c1">// map to associate unique elements and their surrounding elements</span>
<a name="line-545"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">es</span><span class="p">;</span>
<a name="line-546"></a>
<a name="line-547"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<a name="line-548"></a>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">faces</span><span class="p">;</span> <span class="c1">// will collect elem ids of shared faces</span>
<a name="line-549"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-550"></a>      <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">e</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">n</span> <span class="p">];</span>
<a name="line-551"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
<a name="line-552"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">adj</span><span class="p">(</span> <span class="n">e</span><span class="p">,</span> <span class="n">esup1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">))</span> <span class="n">faces</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">esup1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
<a name="line-553"></a>    <span class="p">}</span>
<a name="line-554"></a>    <span class="c1">// store element ids of shared faces</span>
<a name="line-555"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">j</span> <span class="p">:</span> <span class="n">faces</span><span class="p">)</span> <span class="n">es</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<a name="line-556"></a>  <span class="p">}</span>
<a name="line-557"></a>
<a name="line-558"></a>  <span class="c1">// storing elements surrounding elements</span>
<a name="line-559"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esuel1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">esuel2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-560"></a>
<a name="line-561"></a>  <span class="c1">// store elements surrounding elements in linked lists</span>
<a name="line-562"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
<a name="line-563"></a>    <span class="n">esuel2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">esuel2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-564"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">e</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">esuel1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">s</span> <span class="p">);</span>
<a name="line-565"></a>  <span class="p">}</span>
<a name="line-566"></a>
<a name="line-567"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-568"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esuel1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esuel2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-569"></a><span class="p">}</span>
<a name="line-570"></a>
<a name="line-571"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-572"></a><span class="hll"><span class="n">genInedel</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span><span class='error2'>&lt;--- The function 'genInedel' is never used.</span>
</span><a name="line-573"></a>           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-574"></a>           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoed</span> <span class="p">)</span>
<a name="line-575"></a><span class="c1">// *****************************************************************************</span>
<a name="line-576"></a><span class="c1">//  Generate derived data structure, edges of elements</span>
<a name="line-577"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-578"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-579"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-580"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-581"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-582"></a><span class="c1">//!   \endcode</span>
<a name="line-583"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-584"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-585"></a><span class="c1">//! \param[in] nnpe Number of nodes per element</span>
<a name="line-586"></a><span class="c1">//! \param[in] inpoed Edge connectivity as linear vector, see tk::genInpoed</span>
<a name="line-587"></a><span class="c1">//! \return Linear vector storing all edge ids * 2 of all elements</span>
<a name="line-588"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-589"></a><span class="c1">//!   inpoel or inpoed or a non-positive number of nodes per element; it will</span>
<a name="line-590"></a><span class="c1">//!   throw an exception.</span>
<a name="line-591"></a><span class="c1">//! \details The data generated here is stored in a linear vector with all</span>
<a name="line-592"></a><span class="c1">//!   edge ids (as defined by inpoed) of all elements. The edge ids stored in</span>
<a name="line-593"></a><span class="c1">//!   inedel can be directly used to index the vector inpoed. Because the</span>
<a name="line-594"></a><span class="c1">//!   derived data structure generated here, inedel, is intended to be used in</span>
<a name="line-595"></a><span class="c1">//!   conjunction with the linear vector inpoed and not with the linked lists</span>
<a name="line-596"></a><span class="c1">//!   edsup1 and edsup2, this function takes inpoed as an argument. Accessing</span>
<a name="line-597"></a><span class="c1">//!   the edges of element e using the edge of elements data structure, inedel,</span>
<a name="line-598"></a><span class="c1">//!   generated here can be accomplished by</span>
<a name="line-599"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-600"></a><span class="c1">//!     for (std::size_t e=0; e&lt;nelem; ++e) {</span>
<a name="line-601"></a><span class="c1">//!       for (std::size_t i=0; i&lt;nepe; ++i) {</span>
<a name="line-602"></a><span class="c1">//!         use edge id inedel[e*nepe+i] of element e, or</span>
<a name="line-603"></a><span class="c1">//!         use point ids p &lt; q of edge id inedel[e*nepe+i] of element e as</span>
<a name="line-604"></a><span class="c1">//!           p = inpoed[ inedel[e*nepe+i]*2 ]</span>
<a name="line-605"></a><span class="c1">//!           q = inpoed[ inedel[e*nepe+i]*2+1 ]</span>
<a name="line-606"></a><span class="c1">//!       }</span>
<a name="line-607"></a><span class="c1">//!     }</span>
<a name="line-608"></a><span class="c1">//!   \endcode</span>
<a name="line-609"></a><span class="c1">//!   where _nepe_ denotes the number of edges per elements: 3 for triangles, 6</span>
<a name="line-610"></a><span class="c1">//!   for tetrahedra. To find out the number of elements, _nelem_, the size of</span>
<a name="line-611"></a><span class="c1">//!   the mesh connectivity vector, _inpoel_, can be devided by the number of</span>
<a name="line-612"></a><span class="c1">//!   nodes per elements, _nnpe_:</span>
<a name="line-613"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-614"></a><span class="c1">//!     auto nelem = inpoel.size()/nnpe;</span>
<a name="line-615"></a><span class="c1">//!   \endcode</span>
<a name="line-616"></a><span class="c1">//! \note At first sight, this function seems to work for elements with more</span>
<a name="line-617"></a><span class="c1">//!   vertices than that of tetrahedra. However, that is not the case since the</span>
<a name="line-618"></a><span class="c1">//!   algorithm for nnpe &gt; 4 would erronously identify any two combination of</span>
<a name="line-619"></a><span class="c1">//!   vertices as a valid edge of an element. Since only triangles and</span>
<a name="line-620"></a><span class="c1">//!   tetrahedra have no internal edges, this algorithm only works for triangle</span>
<a name="line-621"></a><span class="c1">//!   and tetrahedra element connectivity.</span>
<a name="line-622"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-623"></a><span class="c1">// *****************************************************************************</span>
<a name="line-624"></a><span class="p">{</span>
<a name="line-625"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genInedel() on empty container&quot;</span> <span class="p">);</span>
<a name="line-626"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genInedel() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-627"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-628"></a>          <span class="s">&quot;Attempt to call genInedel() with nodes per element, nnpe, that is &quot;</span>
<a name="line-629"></a>          <span class="s">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> <span class="p">);</span>
<a name="line-630"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-631"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoed</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genInedel() with empty inpoed&quot;</span> <span class="p">);</span>
<a name="line-632"></a>
<a name="line-633"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-634"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-635"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-636"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-637"></a>
<a name="line-638"></a>  <span class="c1">// First, generate index of star centers. This is necessary to avoid a</span>
<a name="line-639"></a>  <span class="c1">// brute-force search for point ids of edges when searching for element edges.</span>
<a name="line-640"></a>  <span class="c1">// Note that this is the same as edsup2, generated by genEdsup(). However,</span>
<a name="line-641"></a>  <span class="c1">// because the derived data structure generated here, inedel, is intended to</span>
<a name="line-642"></a>  <span class="c1">// be used in conjunction with the linear vector inpoed and not with the</span>
<a name="line-643"></a>  <span class="c1">// linked lists edsup1 and edsup2, this function takes inpoed as an argument,</span>
<a name="line-644"></a>  <span class="c1">// and so edsup2 is temporarily generated here to avoid a brute-force search.</span>
<a name="line-645"></a>
<a name="line-646"></a>  <span class="c1">// map to contain stars, a point associated to points connected with edges</span>
<a name="line-647"></a>  <span class="c1">// storing only the end-point id, q, of point ids p &lt; q</span>
<a name="line-648"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">star</span><span class="p">;</span>
<a name="line-649"></a>
<a name="line-650"></a>  <span class="c1">// generate stars from inpoed; starting with zero, every even is a star</span>
<a name="line-651"></a>  <span class="c1">// center, every odd is a spike</span>
<a name="line-652"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">inpoed</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<a name="line-653"></a>    <span class="n">star</span><span class="p">[</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
<a name="line-654"></a>
<a name="line-655"></a>  <span class="c1">// store index of star centers in vector; assume non-center points of each</span>
<a name="line-656"></a>  <span class="c1">// star have already been sorted</span>
<a name="line-657"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">edsup2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-658"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">star</span><span class="p">)</span> <span class="n">edsup2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">edsup2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-659"></a>  <span class="c1">// fill up index array with the last index for points with no new edges</span>
<a name="line-660"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npoin</span><span class="o">-</span><span class="n">star</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<a name="line-661"></a>    <span class="n">edsup2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">edsup2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="p">);</span>
<a name="line-662"></a>  <span class="n">star</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-663"></a>
<a name="line-664"></a>  <span class="c1">// Second, generate edges of elements</span>
<a name="line-665"></a>
<a name="line-666"></a>  <span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span>
<a name="line-667"></a>
<a name="line-668"></a>  <span class="c1">// map associating elem id with vector of edge ids</span>
<a name="line-669"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
<a name="line-670"></a>
<a name="line-671"></a>  <span class="c1">// generate map of elements associated to edge ids</span>
<a name="line-672"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
<a name="line-673"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-674"></a>      <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">n</span><span class="p">];</span>
<a name="line-675"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">edsup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">edsup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<a name="line-676"></a>         <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
<a name="line-677"></a>            <span class="k">if</span> <span class="p">(</span><span class="n">inpoed</span><span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">j</span><span class="p">])</span>
<a name="line-678"></a>              <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<a name="line-679"></a>    <span class="p">}</span>
<a name="line-680"></a>
<a name="line-681"></a>  <span class="c1">// linear vector to store the edge ids of all elements</span>
<a name="line-682"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inedel</span><span class="p">;</span>
<a name="line-683"></a>
<a name="line-684"></a>  <span class="c1">// store edge ids of elements in linear vector</span>
<a name="line-685"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">e</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">inedel</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-686"></a>
<a name="line-687"></a>  <span class="c1">// Return (move out) vector</span>
<a name="line-688"></a>  <span class="k">return</span> <span class="n">inedel</span><span class="p">;</span>
<a name="line-689"></a><span class="p">}</span>
<a name="line-690"></a>
<a name="line-691"></a><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-692"></a><span class="hll"><span class="n">genEsued</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span><span class='error2'>&lt;--- The function 'genEsued' is never used.</span>
</span><a name="line-693"></a>          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">nnpe</span><span class="p">,</span>
<a name="line-694"></a>          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-695"></a>                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">esup</span> <span class="p">)</span>
<a name="line-696"></a><span class="c1">// *****************************************************************************</span>
<a name="line-697"></a><span class="c1">//  Generate derived data structure, elements surrounding edges</span>
<a name="line-698"></a><span class="c1">//! \param[in] inpoel Inteconnectivity of points and elements. These are the</span>
<a name="line-699"></a><span class="c1">//!   node ids of each element of an unstructured mesh. Example:</span>
<a name="line-700"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-701"></a><span class="c1">//!     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</span>
<a name="line-702"></a><span class="c1">//!                                         10, 14, 13, 12 };</span>
<a name="line-703"></a><span class="c1">//!   \endcode</span>
<a name="line-704"></a><span class="c1">//!   specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 },</span>
<a name="line-705"></a><span class="c1">//!   and { 10, 14, 13, 12 }.</span>
<a name="line-706"></a><span class="c1">//! \param[in] nnpe Number of nodes per element (3 or 4)</span>
<a name="line-707"></a><span class="c1">//! \param[in] esup Elements surrounding points as linked lists, see tk::genEsup</span>
<a name="line-708"></a><span class="c1">//! \return Linked lists storing elements surrounding edges</span>
<a name="line-709"></a><span class="c1">//! \warning It is not okay to call this function with an empty container for</span>
<a name="line-710"></a><span class="c1">//!   inpoel or esup.first or esup.second or a non-positive number of nodes per</span>
<a name="line-711"></a><span class="c1">//!   element; it will throw an exception.</span>
<a name="line-712"></a><span class="c1">//! \details The data generated here is stored in a linked list, more precisely,</span>
<a name="line-713"></a><span class="c1">//!   two linked arrays (vectors), _esued1_ and _esued2_, where _esued2_ holds</span>
<a name="line-714"></a><span class="c1">//!   the indices at which _esued1_ holds the element ids surrounding edges.</span>
<a name="line-715"></a><span class="c1">//!   Looping over all elements surrounding edges can then be accomplished by</span>
<a name="line-716"></a><span class="c1">//!   the following loop:</span>
<a name="line-717"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-718"></a><span class="c1">//!     for (std::size_t e=0; e&lt;nedge; ++e)</span>
<a name="line-719"></a><span class="c1">//!       for (auto i=esued.second[e]+1; i&lt;=esued.second[e+1]; ++i)</span>
<a name="line-720"></a><span class="c1">//!         use element id esued.first[i]</span>
<a name="line-721"></a><span class="c1">//!   \endcode</span>
<a name="line-722"></a><span class="c1">//!   To find out the number of edges, _nedge_, the edge connectivity, _inpoed_,</span>
<a name="line-723"></a><span class="c1">//!   can be queried:</span>
<a name="line-724"></a><span class="c1">//!   \code{.cpp}</span>
<a name="line-725"></a><span class="c1">//!     auto esup = tk::genEsup(inpoel,nnpe);</span>
<a name="line-726"></a><span class="c1">//!     auto nedge = tk::genInpoed(inpoel,nnpe,esup).size()/2;</span>
<a name="line-727"></a><span class="c1">//!   \endcode</span>
<a name="line-728"></a><span class="c1">//!   where _nnpe_ is the number of nodes per element (4 for tetrahedra, 3 for</span>
<a name="line-729"></a><span class="c1">//!   triangles).</span>
<a name="line-730"></a><span class="c1">//! \note At first sight, this function seems to work for elements with more</span>
<a name="line-731"></a><span class="c1">//!   vertices than that of tetrahedra. However, that is not the case since the</span>
<a name="line-732"></a><span class="c1">//!   algorithm for nnpe &gt; 4 would erronously identify any two combination of</span>
<a name="line-733"></a><span class="c1">//!   vertices as a valid edge of an element. Since only triangles and</span>
<a name="line-734"></a><span class="c1">//!   tetrahedra have no internal edges, this algorithm only works for triangle</span>
<a name="line-735"></a><span class="c1">//!   and tetrahedra element connectivity.</span>
<a name="line-736"></a><span class="c1">//! \see Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</span>
<a name="line-737"></a><span class="c1">// *****************************************************************************</span>
<a name="line-738"></a><span class="p">{</span>
<a name="line-739"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsued() on empty container&quot;</span> <span class="p">);</span>
<a name="line-740"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Attempt to call genEsued() with zero nodes per element&quot;</span> <span class="p">);</span>
<a name="line-741"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nnpe</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-742"></a>          <span class="s">&quot;Attempt to call genEsued() with nodes per element, nnpe, that is &quot;</span>
<a name="line-743"></a>          <span class="s">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> <span class="p">);</span>
<a name="line-744"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">%</span><span class="n">nnpe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Size of inpoel must be divisible by nnpe&quot;</span> <span class="p">);</span>
<a name="line-745"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsued() with empty esup1&quot;</span> <span class="p">);</span>
<a name="line-746"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Attempt to call genEsued() with empty esup2&quot;</span> <span class="p">);</span>
<a name="line-747"></a>
<a name="line-748"></a>  <span class="c1">// find out number of points in mesh connectivity</span>
<a name="line-749"></a>  <span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-750"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-751"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-752"></a>
<a name="line-753"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup1</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<a name="line-754"></a>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">esup2</span> <span class="o">=</span> <span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-755"></a>
<a name="line-756"></a>  <span class="c1">// allocate and fill with zeros a temporary array, only used locally</span>
<a name="line-757"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">lpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-758"></a>
<a name="line-759"></a>  <span class="c1">// lambda that returns true if element e contains edge (p &lt; q)</span>
<a name="line-760"></a>  <span class="k">auto</span> <span class="n">has</span> <span class="o">=</span> <span class="p">[</span> <span class="o">&amp;</span><span class="n">inpoel</span><span class="p">,</span> <span class="n">nnpe</span> <span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">q</span> <span class="p">)</span>
<a name="line-761"></a>  <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
<a name="line-762"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">bool</span> <span class="o">&gt;</span> <span class="n">sp</span><span class="p">;</span>
<a name="line-763"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
<a name="line-764"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nnpe</span><span class="o">+</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span>
<a name="line-765"></a>        <span class="n">sp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<a name="line-766"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<a name="line-767"></a>  <span class="p">};</span>
<a name="line-768"></a>
<a name="line-769"></a>  <span class="c1">// map to associate edges to unique surrounding element ids</span>
<a name="line-770"></a>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">revolver</span><span class="p">;</span>
<a name="line-771"></a>
<a name="line-772"></a>  <span class="c1">// generate edges and associated vector of unique surrounding element ids</span>
<a name="line-773"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-774"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
<a name="line-775"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
<a name="line-776"></a>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nnpe</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-777"></a>        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">esup1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nnpe</span> <span class="o">+</span> <span class="n">n</span> <span class="p">];</span>
<a name="line-778"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-779"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// for edge given point ids p &lt; q</span>
<a name="line-780"></a>            <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">esup2</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-781"></a>              <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">esup1</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<a name="line-782"></a>              <span class="k">if</span> <span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">))</span> <span class="n">revolver</span><span class="p">[</span><span class="n">ed</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<a name="line-783"></a>            <span class="p">}</span>
<a name="line-784"></a>            <span class="o">++</span><span class="n">ed</span><span class="p">;</span>
<a name="line-785"></a>          <span class="p">}</span>
<a name="line-786"></a>          <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a name="line-787"></a>        <span class="p">}</span>
<a name="line-788"></a>      <span class="p">}</span>
<a name="line-789"></a>
<a name="line-790"></a>  <span class="c1">// linked lists (vectors) to store elements surrounding edges</span>
<a name="line-791"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">esued1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">esued2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-792"></a>
<a name="line-793"></a>  <span class="c1">// sort and store elements surrounding edges and their indices in vectors</span>
<a name="line-794"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">revolver</span><span class="p">)</span> <span class="p">{</span>
<a name="line-795"></a>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">);</span>
<a name="line-796"></a>    <span class="n">esued2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">esued2</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-797"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="n">esued1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-798"></a>  <span class="p">}</span>
<a name="line-799"></a>
<a name="line-800"></a>  <span class="c1">// Return (move out) linked lists</span>
<a name="line-801"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esued1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">esued2</span><span class="p">)</span> <span class="p">);</span>
<a name="line-802"></a><span class="p">}</span>
<a name="line-803"></a>
<a name="line-804"></a><span class="p">}</span> <span class="c1">// tk::</span>
</pre></div>
</td></tr></table>
      </div>
      <div id="footer">
        <p>
         Cppcheck 1.80 - a tool for static C/C++ code analysis</br>
         </br>
         Internet: <a href="http://cppcheck.net">http://cppcheck.net</a></br>
         IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a></br>
        <p>
      </div>
  </body>
</html>
