
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href="https://github.com/quinoacomputing/quinoa/commit/c78318f">Quinoa_v0.2-645-gc78318f</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script language="javascript">
      function getStyle(el,styleProp) {
        if (el.currentStyle)
          var y = el.currentStyle[styleProp];
        else if (window.getComputedStyle)
          var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
        return y;
      }
      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;
        if (el.style.display == "block") {
          el.style.display = "none";
          mark.innerHTML = "[+]";
        } else {
          el.style.display = "block";
          mark.innerHTML = "[-]";
        }
      }
      function init_expandables() {
        var elts = document.getElementsByClassName("expandable");
        for (var i = 0; i < elts.length; i++) {
          var el = elts[i];
          var clickable = el.getElementsByTagName("span")[0];
          var marker = clickable.getElementsByClassName("marker")[0];
          var content = el.getElementsByClassName("content")[0];
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.onclick = toggle;
        }
      }
      function set_class_display(c, st) {
        var elements = document.querySelectorAll('.' + c),
            len = elements.length;
        for (i = 0; i < len; i++) {
            elements[i].style.display = st;
        }
      }
      function toggle_class_visibility(id) {
        var box = document.getElementById(id);
        set_class_display(id, box.checked ? '' : 'none');
      }
    </script>
  </head>
  <body onload="init_expandables()">
      <div id="header">
        <h1>Cppcheck report - [<a href="https://github.com/quinoacomputing/quinoa/commit/c78318f">Quinoa_v0.2-645-gc78318f</a>]: /tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/Partitioner.h </h1>
      </div>
      <div id="menu" dir="rtl">
       <p id="filename"><a href="index.html">Defects:</a> Partitioner.h</p>
<a href='24.html#line-91'> noConstructor 91</a><a href='24.html#line-91'> noConstructor 91</a>
      </div>
      <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Inciter/Partitioner.h</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.</span>
<a name="line-5"></a><span class="cm">  \brief     Charm++ chare partitioner group used to perform mesh partitioning</span>
<a name="line-6"></a><span class="cm">  \details   Charm++ chare partitioner group used to perform mesh partitioning.</span>
<a name="line-7"></a>
<a name="line-8"></a><span class="cm">    The implementation uses the Charm++ runtime system and is fully</span>
<a name="line-9"></a><span class="cm">    asynchronous, overlapping computation, communication as well as I/O. The</span>
<a name="line-10"></a><span class="cm">    algorithm utilizes the structured dagger (SDAG) Charm++ functionality. The</span>
<a name="line-11"></a><span class="cm">    high-level overview of the algorithm structure and how it interfaces with</span>
<a name="line-12"></a><span class="cm">    Charm++ is discussed in the Charm++ interface file</span>
<a name="line-13"></a><span class="cm">    src/Inciter/partitioner.ci.</span>
<a name="line-14"></a>
<a name="line-15"></a><span class="cm">    #### Call graph ####</span>
<a name="line-16"></a><span class="cm">    The following is a directed acyclic graph (DAG) that outlines the</span>
<a name="line-17"></a><span class="cm">    asynchronous algorithm implemented in this class The detailed discussion of</span>
<a name="line-18"></a><span class="cm">    the algorithm is given in the Charm++ interface file partitioner.ci,</span>
<a name="line-19"></a><span class="cm">    which also repeats the graph below using ASCII graphics. On the DAG orange</span>
<a name="line-20"></a><span class="cm">    fills denote global synchronization points, orange frames with white fill</span>
<a name="line-21"></a><span class="cm">    are partial synchronization points that overlap with other tasks, and dashed</span>
<a name="line-22"></a><span class="cm">    lines are potential shortcuts that allow jumping over some of the task-graph</span>
<a name="line-23"></a><span class="cm">    under some circumstances. See the detailed discussion in partitioner.ci.</span>
<a name="line-24"></a><span class="cm">    \dot</span>
<a name="line-25"></a><span class="cm">    digraph &quot;Partitioner SDAG&quot; {</span>
<a name="line-26"></a><span class="cm">      rankdir=&quot;LR&quot;;</span>
<a name="line-27"></a><span class="cm">      node [shape=record, fontname=Helvetica, fontsize=10];</span>
<a name="line-28"></a><span class="cm">      Own [ label=&quot;Own&quot; tooltip=&quot;owned nodes reordered&quot;</span>
<a name="line-29"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::reorder&quot;];</span>
<a name="line-30"></a><span class="cm">      Req [ label=&quot;Req&quot; tooltip=&quot;nodes requested&quot;</span>
<a name="line-31"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::request&quot;];</span>
<a name="line-32"></a><span class="cm">      Pre [ label=&quot;Pre&quot; tooltip=&quot;start preparing node IDs&quot;</span>
<a name="line-33"></a><span class="cm">            URL=&quot;\ref inciter::Partitioner::prepare&quot; color=&quot;#e6851c&quot;];</span>
<a name="line-34"></a><span class="cm">      Ord [ label=&quot;Ord&quot; tooltip=&quot;Node IDs reordered&quot;</span>
<a name="line-35"></a><span class="cm">            URL=&quot;\ref inciter::Partitioner::reordered&quot; color=&quot;#e6851c&quot;];</span>
<a name="line-36"></a><span class="cm">      Low [ label=&quot;Low&quot; tooltip=&quot;lower bound received&quot;</span>
<a name="line-37"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::lower&quot;];</span>
<a name="line-38"></a><span class="cm">      Upp [ label=&quot;Upp&quot; tooltip=&quot;upper bound computed&quot;</span>
<a name="line-39"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::bounds&quot;];</span>
<a name="line-40"></a><span class="cm">      Par [ label=&quot;Par&quot; tooltip=&quot;partitioners participated&quot;</span>
<a name="line-41"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::neworder&quot;];</span>
<a name="line-42"></a><span class="cm">      Cre [ label=&quot;Cre&quot; tooltip=&quot;create workers&quot;</span>
<a name="line-43"></a><span class="cm">             URL=&quot;\ref inciter::Partitioner::create&quot; color=&quot;#e6851c&quot;];</span>
<a name="line-44"></a><span class="cm">      Own -&gt; Pre [ style=&quot;solid&quot; ];</span>
<a name="line-45"></a><span class="cm">      Req -&gt; Pre [ style=&quot;solid&quot; ];</span>
<a name="line-46"></a><span class="cm">      Pre -&gt; Ord [ style=&quot;solid&quot; ];</span>
<a name="line-47"></a><span class="cm">      Ord -&gt; Low [ style=&quot;solid&quot; ];</span>
<a name="line-48"></a><span class="cm">      Ord -&gt; Upp [ style=&quot;solid&quot; ];</span>
<a name="line-49"></a><span class="cm">      Ord -&gt; Par [ style=&quot;solid&quot; ];</span>
<a name="line-50"></a><span class="cm">      Low -&gt; Cre [ style=&quot;solid&quot; ];</span>
<a name="line-51"></a><span class="cm">      Upp -&gt; Cre [ style=&quot;solid&quot; ];</span>
<a name="line-52"></a><span class="cm">      Par -&gt; Cre [ style=&quot;solid&quot; ];</span>
<a name="line-53"></a><span class="cm">    }</span>
<a name="line-54"></a><span class="cm">    \enddot</span>
<a name="line-55"></a><span class="cm">    \include Inciter/partitioner.ci</span>
<a name="line-56"></a><span class="cm">*/</span>
<a name="line-57"></a><span class="c1">// *****************************************************************************</span>
<a name="line-58"></a><span class="cp">#ifndef Partitioner_h</span>
<a name="line-59"></a><span class="cp">#define Partitioner_h</span>
<a name="line-60"></a>
<a name="line-61"></a><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<a name="line-62"></a><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<a name="line-63"></a><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<a name="line-64"></a><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<a name="line-65"></a><span class="cp">#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp"></span>
<a name="line-66"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-67"></a><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<a name="line-68"></a>
<a name="line-69"></a><span class="cp">#include</span> <span class="cpf">&quot;ExodusIIMeshReader.h&quot;</span><span class="cp"></span>
<a name="line-70"></a><span class="cp">#include</span> <span class="cpf">&quot;ContainerUtil.h&quot;</span><span class="cp"></span>
<a name="line-71"></a><span class="cp">#include</span> <span class="cpf">&quot;ZoltanInterOp.h&quot;</span><span class="cp"></span>
<a name="line-72"></a><span class="cp">#include</span> <span class="cpf">&quot;Inciter/InputDeck/InputDeck.h&quot;</span><span class="cp"></span>
<a name="line-73"></a><span class="cp">#include</span> <span class="cpf">&quot;Options/PartitioningAlgorithm.h&quot;</span><span class="cp"></span>
<a name="line-74"></a><span class="cp">#include</span> <span class="cpf">&quot;Solver.h&quot;</span><span class="cp"></span>
<a name="line-75"></a><span class="cp">#include</span> <span class="cpf">&quot;DerivedData.h&quot;</span><span class="cp"></span>
<a name="line-76"></a><span class="cp">#include</span> <span class="cpf">&quot;UnsMesh.h&quot;</span><span class="cp"></span>
<a name="line-77"></a><span class="cp">#include</span> <span class="cpf">&quot;AMR/mesh_adapter.h&quot;</span><span class="cp"></span>
<a name="line-78"></a><span class="cp">#include</span> <span class="cpf">&quot;FaceData.h&quot;</span><span class="cp"></span>
<a name="line-79"></a>
<a name="line-80"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/partitioner.decl.h&quot;</span><span class="cp"></span>
<a name="line-81"></a>
<a name="line-82"></a><span class="n">namespace</span> <span class="n">inciter</span> <span class="p">{</span>
<a name="line-83"></a>
<a name="line-84"></a><span class="k">extern</span> <span class="n">ctr</span><span class="o">::</span><span class="n">InputDeck</span> <span class="n">g_inputdeck</span><span class="p">;</span>
<a name="line-85"></a>
<a name="line-86"></a><span class="c1">//! Partitioner Charm++ chare group class</span>
<a name="line-87"></a><span class="c1">//! \details Instantiations of Partitioner comprise a processor aware Charm++</span>
<a name="line-88"></a><span class="c1">//!   chare group. When instantiated, a new object is created on each PE and not</span>
<a name="line-89"></a><span class="c1">//!   more (as opposed to individual chares or chare array object elements). See</span>
<a name="line-90"></a><span class="c1">//!   also the Charm++ interface file partitioner.ci.</span>
<a name="line-91"></a><span class="hll"><span class="n">class</span> <span class="nl">Partitioner</span> <span class="p">:</span> <span class="n">public</span> <span class="n">CBase_Partitioner</span> <span class="p">{</span><div class='verbose expandable'><span class='error2'>&lt;--- The class 'Partitioner' does not have a constructor. <span class='marker'>[+]</span></span><div class='content'>The class &apos;Partitioner&apos; does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.</div></div><div class='verbose expandable'><span class='error2'>&lt;--- The class 'Partitioner' does not have a constructor. <span class='marker'>[+]</span></span><div class='content'>The class &apos;Partitioner&apos; does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior.</div></div>
</span><a name="line-92"></a>
<a name="line-93"></a>  <span class="cp">#if defined(__clang__)</span>
<a name="line-94"></a>    <span class="cp">#pragma clang diagnostic push</span>
<a name="line-95"></a>    <span class="cp">#pragma clang diagnostic ignored &quot;-Wunused-parameter&quot;</span>
<a name="line-96"></a>    <span class="cp">#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;</span>
<a name="line-97"></a>  <span class="cp">#elif defined(STRICT_GNUC)</span>
<a name="line-98"></a>    <span class="cp">#pragma GCC diagnostic push</span>
<a name="line-99"></a>    <span class="cp">#pragma GCC diagnostic ignored &quot;-Wunused-parameter&quot;</span>
<a name="line-100"></a>    <span class="cp">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</span>
<a name="line-101"></a>  <span class="cp">#elif defined(__INTEL_COMPILER)</span>
<a name="line-102"></a>    <span class="cp">#pragma warning( push )</span>
<a name="line-103"></a>    <span class="cp">#pragma warning( disable: 1478 )</span>
<a name="line-104"></a>  <span class="cp">#endif</span>
<a name="line-105"></a>  <span class="c1">// Include Charm++ SDAG code. See http://charm.cs.illinois.edu/manuals/html/</span>
<a name="line-106"></a>  <span class="c1">// charm++/manual.html, Sec. &quot;Structured Control Flow: Structured Dagger&quot;.</span>
<a name="line-107"></a>  <span class="n">Partitioner_SDAG_CODE</span>
<a name="line-108"></a>  <span class="cp">#if defined(__clang__)</span>
<a name="line-109"></a>    <span class="cp">#pragma clang diagnostic pop</span>
<a name="line-110"></a>  <span class="cp">#elif defined(STRICT_GNUC)</span>
<a name="line-111"></a>    <span class="cp">#pragma GCC diagnostic pop</span>
<a name="line-112"></a>  <span class="cp">#elif defined(__INTEL_COMPILER)</span>
<a name="line-113"></a>    <span class="cp">#pragma warning( pop )</span>
<a name="line-114"></a>  <span class="cp">#endif</span>
<a name="line-115"></a>
<a name="line-116"></a>  <span class="nl">public</span><span class="p">:</span>
<a name="line-117"></a>    <span class="c1">//! Constructor</span>
<a name="line-118"></a>    <span class="n">Partitioner</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">CkCallback</span> <span class="o">&gt;&amp;</span> <span class="n">cb</span><span class="p">,</span>
<a name="line-119"></a>                 <span class="k">const</span> <span class="n">CProxy_Transporter</span><span class="o">&amp;</span> <span class="n">host</span><span class="p">,</span>
<a name="line-120"></a>                 <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_Solver</span><span class="o">&amp;</span> <span class="n">solver</span><span class="p">,</span>
<a name="line-121"></a>                 <span class="k">const</span> <span class="n">CProxy_BoundaryConditions</span><span class="o">&amp;</span> <span class="n">bc</span><span class="p">,</span>
<a name="line-122"></a>                 <span class="k">const</span> <span class="n">Scheme</span><span class="o">&amp;</span> <span class="n">scheme</span><span class="p">,</span>
<a name="line-123"></a>                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
<a name="line-124"></a>                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span> <span class="p">);</span>
<a name="line-125"></a>
<a name="line-126"></a>    <span class="c1">//! Partition the computational mesh</span>
<a name="line-127"></a>    <span class="kt">void</span> <span class="nf">partition</span><span class="p">(</span> <span class="kt">int</span> <span class="n">nchare</span> <span class="p">);</span>
<a name="line-128"></a>
<a name="line-129"></a>    <span class="c1">//! Receive number of uniquely assigned global mesh node IDs from lower PEs</span>
<a name="line-130"></a>    <span class="kt">void</span> <span class="nf">offset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">u</span> <span class="p">);</span>
<a name="line-131"></a>
<a name="line-132"></a>    <span class="c1">//! Request new global node IDs for old node IDs</span>
<a name="line-133"></a>    <span class="kt">void</span> <span class="nf">request</span><span class="p">(</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">nd</span> <span class="p">);</span>
<a name="line-134"></a>
<a name="line-135"></a>    <span class="c1">// Request new global node IDs for edges</span>
<a name="line-136"></a>    <span class="kt">void</span> <span class="nf">request</span><span class="p">(</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span><span class="o">&amp;</span> <span class="n">ed</span> <span class="p">);</span>
<a name="line-137"></a>
<a name="line-138"></a>    <span class="c1">//! Receive new (reordered) global node IDs</span>
<a name="line-139"></a>    <span class="kt">void</span> <span class="nf">neworder</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">nd</span> <span class="p">);</span>
<a name="line-140"></a>
<a name="line-141"></a>    <span class="c1">//! Receive new global node IDs associated to edge-nodes</span>
<a name="line-142"></a>    <span class="kt">void</span> <span class="nf">neworder</span><span class="p">(</span> <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">EdgeNodes</span><span class="o">&amp;</span> <span class="n">ed</span> <span class="p">);</span>
<a name="line-143"></a>
<a name="line-144"></a>    <span class="c1">//! Receive mesh node IDs associated to chares we own</span>
<a name="line-145"></a>    <span class="c1">//! \param[in] n Mesh node indices associated to chare IDs</span>
<a name="line-146"></a>    <span class="c1">//! \param[in] frompe PE call coming from</span>
<a name="line-147"></a>    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">frompe</span><span class="p">,</span>
<a name="line-148"></a>              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-149"></a>
<a name="line-150"></a>    <span class="c1">//! Acknowledge received node IDs</span>
<a name="line-151"></a>    <span class="kt">void</span> <span class="nf">recv</span><span class="p">();</span>
<a name="line-152"></a>
<a name="line-153"></a>    <span class="c1">//! Prepare owned mesh node IDs for reordering</span>
<a name="line-154"></a>    <span class="kt">void</span> <span class="nf">flatten</span><span class="p">();</span>
<a name="line-155"></a>
<a name="line-156"></a>    <span class="c1">//! Receive lower bound of node IDs our PE operates on after reordering</span>
<a name="line-157"></a>    <span class="kt">void</span> <span class="nf">lower</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">low</span> <span class="p">);</span>
<a name="line-158"></a>
<a name="line-159"></a>    <span class="c1">//! \brief Compute the variance of the communication cost of merging the</span>
<a name="line-160"></a>    <span class="c1">//!   linear system</span>
<a name="line-161"></a>    <span class="kt">void</span> <span class="nf">stdCost</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="n">av</span> <span class="p">);</span>
<a name="line-162"></a>
<a name="line-163"></a>    <span class="c1">//! \brief Start gathering global node IDs this PE will need to receive</span>
<a name="line-164"></a>    <span class="c1">//!   (instead of assign) during reordering</span>
<a name="line-165"></a>    <span class="kt">void</span> <span class="nf">gather</span><span class="p">();</span>
<a name="line-166"></a>
<a name="line-167"></a>    <span class="c1">//! \brief Query our global node IDs and edges by other PEs so they know if</span>
<a name="line-168"></a>    <span class="c1">//!   they are to receive IDs for those from during reordering</span>
<a name="line-169"></a>    <span class="kt">void</span> <span class="nf">query</span><span class="p">(</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">nodes</span> <span class="p">);</span>
<a name="line-170"></a>
<a name="line-171"></a>    <span class="c1">//! Receive mask of to-be-received global mesh node IDs</span>
<a name="line-172"></a>    <span class="kt">void</span> <span class="nf">mask</span><span class="p">(</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
<a name="line-173"></a>                              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">cn</span> <span class="p">);</span>
<a name="line-174"></a>
<a name="line-175"></a>    <span class="c1">//! Create worker chare array elements on this PE</span>
<a name="line-176"></a>    <span class="kt">void</span> <span class="nf">createWorkers</span><span class="p">();</span>
<a name="line-177"></a>
<a name="line-178"></a>  <span class="nl">private</span><span class="p">:</span>
<a name="line-179"></a>    <span class="c1">//! Charm++ callbacks associated to compile-time tags</span>
<a name="line-180"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">tuple</span><span class="o">::</span><span class="n">tagged_tuple</span><span class="o">&lt;</span>
<a name="line-181"></a>        <span class="n">tag</span><span class="o">::</span><span class="n">refined</span><span class="p">,</span>     <span class="n">CkCallback</span>
<a name="line-182"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">centroid</span><span class="p">,</span>    <span class="n">CkCallback</span>
<a name="line-183"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">distributed</span><span class="p">,</span> <span class="n">CkCallback</span>
<a name="line-184"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">flattened</span><span class="p">,</span>   <span class="n">CkCallback</span>
<a name="line-185"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">load</span><span class="p">,</span>        <span class="n">CkCallback</span>
<a name="line-186"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">avecost</span><span class="p">,</span>     <span class="n">CkCallback</span>
<a name="line-187"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">stdcost</span><span class="p">,</span>     <span class="n">CkCallback</span>
<a name="line-188"></a>      <span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">coord</span><span class="p">,</span>       <span class="n">CkCallback</span>
<a name="line-189"></a>    <span class="o">&gt;</span> <span class="n">m_cb</span><span class="p">;</span>
<a name="line-190"></a>    <span class="c1">//! Host proxy</span>
<a name="line-191"></a>    <span class="n">CProxy_Transporter</span> <span class="n">m_host</span><span class="p">;</span>
<a name="line-192"></a>    <span class="c1">//! Linear system solver proxy</span>
<a name="line-193"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_Solver</span> <span class="n">m_solver</span><span class="p">;</span>
<a name="line-194"></a>    <span class="c1">//! Boundary conditions proxy</span>
<a name="line-195"></a>    <span class="n">CProxy_BoundaryConditions</span> <span class="n">m_bc</span><span class="p">;</span>
<a name="line-196"></a>    <span class="c1">//! Discretization scheme</span>
<a name="line-197"></a>    <span class="n">Scheme</span> <span class="n">m_scheme</span><span class="p">;</span>
<a name="line-198"></a>    <span class="c1">//! Number of fellow PEs to send elem IDs to</span>
<a name="line-199"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_npe</span><span class="p">;</span>
<a name="line-200"></a>    <span class="c1">//! Queue of requested node IDs from PEs</span>
<a name="line-201"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_reqNodes</span><span class="p">;</span>
<a name="line-202"></a>    <span class="c1">//! Queue of requested edge-node IDs from PEs</span>
<a name="line-203"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_reqEdges</span><span class="p">;</span>
<a name="line-204"></a>    <span class="c1">//! \brief Starting global mesh node ID for node reordering on this PE</span>
<a name="line-205"></a>    <span class="c1">//!   during mesh node reordering</span>
<a name="line-206"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_start</span><span class="p">;</span>
<a name="line-207"></a>    <span class="c1">//! \brief Counter for number of offsets</span>
<a name="line-208"></a>    <span class="c1">//! \details This counts the to-be-received node IDs received while</span>
<a name="line-209"></a>    <span class="c1">//!   computing global mesh node ID offsets for each PE rquired for node</span>
<a name="line-210"></a>    <span class="c1">//!   reordering later</span>
<a name="line-211"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_noffset</span><span class="p">;</span>
<a name="line-212"></a>    <span class="c1">//! \brief Counter for number of queries for global mesh node IDs</span>
<a name="line-213"></a>    <span class="c1">//! \details This counts the number of queries received while</span>
<a name="line-214"></a>    <span class="c1">//!   gathering the node IDs that need to be received (instead of uniquely</span>
<a name="line-215"></a>    <span class="c1">//!   assigned) by each PE</span>
<a name="line-216"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_nquery</span><span class="p">;</span>
<a name="line-217"></a>    <span class="c1">//! \brief Counter for number of masks of to-be-received global mesh node</span>
<a name="line-218"></a>    <span class="c1">//!   IDs received</span>
<a name="line-219"></a>    <span class="c1">//! \details This counts the to-be-received node ID masks received while</span>
<a name="line-220"></a>    <span class="c1">//!   gathering the node IDs that need to be received (instead of uniquely</span>
<a name="line-221"></a>    <span class="c1">//!   assigned) by each PE</span>
<a name="line-222"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_nmask</span><span class="p">;</span>
<a name="line-223"></a>    <span class="c1">//! Tetrtahedron element connectivity of our chunk of the mesh</span>
<a name="line-224"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">m_tetinpoel</span><span class="p">;</span>
<a name="line-225"></a>    <span class="c1">//! Global element IDs we read (our chunk of the mesh)</span>
<a name="line-226"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">long</span> <span class="o">&gt;</span> <span class="n">m_gelemid</span><span class="p">;</span>
<a name="line-227"></a>    <span class="c1">//! Coordinates of mesh nodes of out chunk of the mesh</span>
<a name="line-228"></a>    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">m_coord</span><span class="p">;</span>
<a name="line-229"></a>    <span class="c1">//! Element centroid coordinates of our chunk of the mesh</span>
<a name="line-230"></a>    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">m_centroid</span><span class="p">;</span>
<a name="line-231"></a>    <span class="c1">//! Total number of chares across all PEs</span>
<a name="line-232"></a>    <span class="kt">int</span> <span class="n">m_nchare</span><span class="p">;</span>
<a name="line-233"></a>    <span class="c1">//! Lower bound of node IDs our PE operates on after reordering</span>
<a name="line-234"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_lower</span><span class="p">;</span>
<a name="line-235"></a>    <span class="c1">//! Upper bound of node IDs our PE operates on after reordering</span>
<a name="line-236"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_upper</span><span class="p">;</span>
<a name="line-237"></a>    <span class="c1">//! \brief Temporary communication map used to receive global mesh node IDs</span>
<a name="line-238"></a>    <span class="c1">//! \details This map, on each PE, associates the list of global mesh point</span>
<a name="line-239"></a>    <span class="c1">//!   indices to fellow PE IDs from which we will receive new node IDs (as</span>
<a name="line-240"></a>    <span class="c1">//!   in producing contiguous-row-id linear system contributions) during</span>
<a name="line-241"></a>    <span class="c1">//!   reordering.</span>
<a name="line-242"></a>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_ncomm</span><span class="p">;</span>
<a name="line-243"></a>    <span class="c1">//! \brief Temporary communication map used to receive global mesh edges</span>
<a name="line-244"></a>    <span class="c1">//! \details This map, on each PE, associates the list of global mesh edges</span>
<a name="line-245"></a>    <span class="c1">//!   indices to fellow PE IDs from which we will receive new nodes IDs (as</span>
<a name="line-246"></a>    <span class="c1">//!   in producing contiguous-row-id linear system contributions) associated</span>
<a name="line-247"></a>    <span class="c1">//!   to edges during reordering.</span>
<a name="line-248"></a>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span> <span class="o">&gt;</span> <span class="n">m_ecomm</span><span class="p">;</span>
<a name="line-249"></a>    <span class="c1">//! \brief Communication map used for distributed mesh node reordering</span>
<a name="line-250"></a>    <span class="c1">//! \details This map, on each PE, associates the list of global mesh point</span>
<a name="line-251"></a>    <span class="c1">//!   indices to fellow PE IDs from which we will receive new node IDs (as</span>
<a name="line-252"></a>    <span class="c1">//!   in producing contiguous-row-id linear system contributions) during</span>
<a name="line-253"></a>    <span class="c1">//!   reordering. Only data that will be received from PEs with a lower</span>
<a name="line-254"></a>    <span class="c1">//!   index are stored.</span>
<a name="line-255"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_ncommunication</span><span class="p">;</span>
<a name="line-256"></a>    <span class="c1">//! \brief Communication map used for distributed mesh edge-node reordering</span>
<a name="line-257"></a>    <span class="c1">//! \details This map, on each PE, associates the list of global mesh edges</span>
<a name="line-258"></a>    <span class="c1">//!   to fellow PE IDs from which we will receive new node IDs (as in</span>
<a name="line-259"></a>    <span class="c1">//!   producing contiguous-row-id linear system contributions)associated to</span>
<a name="line-260"></a>    <span class="c1">//!   edges during reordering. Only data that will be received from PEs with</span>
<a name="line-261"></a>    <span class="c1">//!   a lower index are stored.</span>
<a name="line-262"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span> <span class="o">&gt;</span> <span class="n">m_ecommunication</span><span class="p">;</span>
<a name="line-263"></a>    <span class="c1">//! \brief Unique global node IDs chares on our PE will contribute to in a</span>
<a name="line-264"></a>    <span class="c1">//!   linear system</span>
<a name="line-265"></a>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">m_nodeset</span><span class="p">;</span>
<a name="line-266"></a>    <span class="c1">//! \brief Unique global edges whose nodes chares on our PE will contribute</span>
<a name="line-267"></a>    <span class="c1">//!   to in a linear system</span>
<a name="line-268"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span> <span class="n">m_edgeset</span><span class="p">;</span>
<a name="line-269"></a>    <span class="c1">//! \brief Map associating new node IDs (as in producing contiguous-row-id</span>
<a name="line-270"></a>    <span class="c1">//!   linear system contributions) as map-values to old node IDs (as in</span>
<a name="line-271"></a>    <span class="c1">//!   file) as map-keys</span>
<a name="line-272"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">m_linnodes</span><span class="p">;</span>
<a name="line-273"></a>    <span class="c1">//! \brief Map associating new node IDs (as in producing contiguous-row-id</span>
<a name="line-274"></a>    <span class="c1">//!   linear system contributions) as map-values to edges given by two old</span>
<a name="line-275"></a>    <span class="c1">//!   node IDs (as in file) as map-keys</span>
<a name="line-276"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">EdgeNodes</span> <span class="n">m_linedges</span><span class="p">;</span>
<a name="line-277"></a>    <span class="c1">//! Global mesh element connectivity associated to chares owned</span>
<a name="line-278"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_chinpoel</span><span class="p">;</span>
<a name="line-279"></a>    <span class="c1">//! \brief Maps associating old node IDs to new node IDs (as in producing</span>
<a name="line-280"></a>    <span class="c1">//!   contiguous-row-id linear system contributions) categorized by chares.</span>
<a name="line-281"></a>    <span class="c1">//! \details Maps associating old node IDs (as in file) as map-values to new</span>
<a name="line-282"></a>    <span class="c1">//!   node IDs (as in producing contiguous-row-id linear system</span>
<a name="line-283"></a>    <span class="c1">//!   contributions) as map-keys, associated to chare IDs (outer keys).</span>
<a name="line-284"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
<a name="line-285"></a>      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_chfilenodes</span><span class="p">;</span>
<a name="line-286"></a>    <span class="c1">//! \brief Maps associating new node IDs (as in producing contiguous-row-id</span>
<a name="line-287"></a>    <span class="c1">//!   linear system contributions) to edges (a pair of old node IDs) in</span>
<a name="line-288"></a>    <span class="c1">//!   tk::UnsMesh::EdgeNodes maps, associated to and categorized by chares.</span>
<a name="line-289"></a>    <span class="c1">//! \details Maps associating new node IDs (as in producing</span>
<a name="line-290"></a>    <span class="c1">//!   contiguous-row-id linear system contributions) to edges (a pair of old</span>
<a name="line-291"></a>    <span class="c1">//!   node IDs, as in file) associated to chare IDs (outer key) for only</span>
<a name="line-292"></a>    <span class="c1">//!   the nodes newly added as a result of initial uniform refinement.</span>
<a name="line-293"></a>    <span class="c1">//! \note Used for looking up boundary conditions</span>
<a name="line-294"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">EdgeNodes</span> <span class="o">&gt;</span> <span class="n">m_chedgenodes</span><span class="p">;</span>
<a name="line-295"></a>    <span class="c1">//! Communication cost of linear system merging for our PE</span>
<a name="line-296"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="n">m_cost</span><span class="p">;</span>
<a name="line-297"></a>    <span class="c1">//! \brief Map associating a set of chare IDs to old (as in file) global</span>
<a name="line-298"></a>    <span class="c1">//!   mesh node IDs on the chare boundaries</span>
<a name="line-299"></a>    <span class="c1">//! \details Note that a single global mesh ID can be associated to multiple</span>
<a name="line-300"></a>    <span class="c1">//!   chare IDs as multiple chares can contribute to a single mesh node.</span>
<a name="line-301"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_bnodechares</span><span class="p">;</span>
<a name="line-302"></a>    <span class="c1">//! \brief Map associating a set of chare IDs to edges given by two old</span>
<a name="line-303"></a>    <span class="c1">//!   global mesh node IDs (old as in file)</span>
<a name="line-304"></a>    <span class="c1">//! \details Note that a single edge can be associated to multiple chare IDs</span>
<a name="line-305"></a>    <span class="c1">//!   as multiple chares can contribute to a single edge.</span>
<a name="line-306"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">EdgeChares</span> <span class="n">m_edgechares</span><span class="p">;</span>
<a name="line-307"></a>    <span class="c1">//! \brief Global mesh node IDs associated to chare IDs bordering the mesh</span>
<a name="line-308"></a>    <span class="c1">//!   chunk held by (and associated to) chare IDs this PE owns</span>
<a name="line-309"></a>    <span class="c1">//! \details msum: (M)esh chunks (S)urrounding (M)esh chunks storing mesh</span>
<a name="line-310"></a>    <span class="c1">//!   nodes. Outer map-key: chare IDs this PE owns whose neighbors are</span>
<a name="line-311"></a>    <span class="c1">//!   stored, inner map-key: chare IDs of those chares that hold mesh chunks</span>
<a name="line-312"></a>    <span class="c1">//!   surrounding the outer-key chare&#39;s mesh, map-values: global new</span>
<a name="line-313"></a>    <span class="c1">//!   (reordered, as in producing contiguous-row-id linear system</span>
<a name="line-314"></a>    <span class="c1">//!   contributions) mesh node IDs along the border of chares (at which the</span>
<a name="line-315"></a>    <span class="c1">//!   chares will need to communicate) during time stepping.</span>
<a name="line-316"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
<a name="line-317"></a>      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_msum</span><span class="p">;</span>
<a name="line-318"></a>    <span class="c1">//! \brief Mesh edges given by two global mesh node IDs associated to chare</span>
<a name="line-319"></a>    <span class="c1">//!   IDs bordering the mesh chunk held by (and associated to) chare IDs</span>
<a name="line-320"></a>    <span class="c1">//!   this PE owns</span>
<a name="line-321"></a>    <span class="c1">//! \details msum: (M)esh chunks (S)urrounding (M)esh chunks storing mesh</span>
<a name="line-322"></a>    <span class="c1">//!   nodes. Outer map-key: chare IDs this PE owns whose neighbors are</span>
<a name="line-323"></a>    <span class="c1">//!   stored, inner map-key: chare IDs of those chares that hold mesh chunks</span>
<a name="line-324"></a>    <span class="c1">//!   surrounding the outer-key chare&#39;s mesh, map-values: mesh edges given</span>
<a name="line-325"></a>    <span class="c1">//!   by two global new (reordered, as in producing contiguous-row-id linear</span>
<a name="line-326"></a>    <span class="c1">//!   system contributions) mesh node IDs along the border of chares (at</span>
<a name="line-327"></a>    <span class="c1">//!   which the chares will need to communicate) during time stepping.</span>
<a name="line-328"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
<a name="line-329"></a>      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Edges</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_msumed</span><span class="p">;</span>
<a name="line-330"></a>    <span class="c1">//! \brief Boundary face list from side-sets.</span>
<a name="line-331"></a>    <span class="c1">//!   m_bface is the list of boundary faces in the side-sets.</span>
<a name="line-332"></a>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_bface</span><span class="p">;</span>
<a name="line-333"></a>    <span class="c1">//! \brief Boundary face-node connectivity.</span>
<a name="line-334"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">m_triinpoel</span><span class="p">;</span>
<a name="line-335"></a>
<a name="line-336"></a>    <span class="c1">//! Compute element centroid coordinates</span>
<a name="line-337"></a>    <span class="kt">void</span> <span class="nf">computeCentroids</span><span class="p">(</span>
<a name="line-338"></a>      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">lid</span> <span class="p">);</span>
<a name="line-339"></a>
<a name="line-340"></a>    <span class="c1">//! Construct global mesh node ids for each chare</span>
<a name="line-341"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-342"></a>    <span class="n">chareNodes</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">che</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<a name="line-343"></a>
<a name="line-344"></a>    <span class="c1">//! Distribute global mesh node IDs to their owner PEs</span>
<a name="line-345"></a>    <span class="kt">void</span> <span class="nf">distribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span>
<a name="line-346"></a>                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;&amp;</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-347"></a>
<a name="line-348"></a>    <span class="c1">//! Compute chare distribution</span>
<a name="line-349"></a>    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">chareDistribution</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<a name="line-350"></a>
<a name="line-351"></a>    <span class="c1">//! Reorder global mesh node IDs</span>
<a name="line-352"></a>    <span class="kt">void</span> <span class="nf">reorder</span><span class="p">();</span>
<a name="line-353"></a>
<a name="line-354"></a>    <span class="c1">//! Return processing element for chare id</span>
<a name="line-355"></a>    <span class="kt">int</span> <span class="nf">pe</span><span class="p">(</span> <span class="kt">int</span> <span class="n">id</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<a name="line-356"></a>
<a name="line-357"></a>    <span class="c1">//! Associate new node IDs to old ones and return them to the requestor(s)</span>
<a name="line-358"></a>    <span class="kt">void</span> <span class="nf">prepare</span><span class="p">();</span>
<a name="line-359"></a>
<a name="line-360"></a>    <span class="c1">//! Generate compact mesh connectivity</span>
<a name="line-361"></a>    <span class="kt">void</span> <span class="nf">generate_compact_inpoel</span><span class="p">();</span>
<a name="line-362"></a>
<a name="line-363"></a>    <span class="c1">//! Uniformly refine our mesh replacing each tetrahedron with 8 new ones</span>
<a name="line-364"></a>    <span class="kt">void</span> <span class="nf">refine</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span> <span class="p">);</span>
<a name="line-365"></a>
<a name="line-366"></a>    <span class="c1">//! Compute final result of reordering</span>
<a name="line-367"></a>    <span class="kt">void</span> <span class="nf">reordered</span><span class="p">();</span>
<a name="line-368"></a>
<a name="line-369"></a>    <span class="c1">//! Compute lower and upper bounds of reordered node IDs our PE operates on</span>
<a name="line-370"></a>    <span class="kt">void</span> <span class="nf">bounds</span><span class="p">();</span>
<a name="line-371"></a>
<a name="line-372"></a>    <span class="c1">//! \brief Create chare array elements on this PE and assign the global mesh</span>
<a name="line-373"></a>    <span class="c1">//!   element IDs they will operate on</span>
<a name="line-374"></a>    <span class="kt">void</span> <span class="nf">create</span><span class="p">();</span>
<a name="line-375"></a>
<a name="line-376"></a>    <span class="c1">//! Create Discretization chare array elements on this PE</span>
<a name="line-377"></a>    <span class="kt">void</span> <span class="nf">createDiscWorkers</span><span class="p">();</span>
<a name="line-378"></a>
<a name="line-379"></a>    <span class="c1">//! Compute communication cost of linear system merging for our PE</span>
<a name="line-380"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="n">cost</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">u</span> <span class="p">);</span>
<a name="line-381"></a><span class="p">};</span>
<a name="line-382"></a>
<a name="line-383"></a><span class="p">}</span> <span class="c1">// inciter::</span>
<a name="line-384"></a>
<a name="line-385"></a><span class="cp">#endif </span><span class="c1">// Partitioner_h</span>
</pre></div>
</td></tr></table>
      </div>
      <div id="footer">
        <p>
         Cppcheck 1.80 - a tool for static C/C++ code analysis</br>
         </br>
         Internet: <a href="http://cppcheck.net">http://cppcheck.net</a></br>
         IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a></br>
        <p>
      </div>
  </body>
</html>
