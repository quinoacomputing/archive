<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: inciter::BoundaryConditions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceinciter.html">inciter</a></li><li class="navelem"><a class="el" href="classinciter_1_1_boundary_conditions.html">BoundaryConditions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classinciter_1_1_boundary_conditions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">inciter::BoundaryConditions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data and functionality working on boundary conditions.  
 <a href="classinciter_1_1_boundary_conditions.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for inciter::BoundaryConditions:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classinciter_1_1_boundary_conditions__inherit__graph.svg" width="206" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab45dbba66ee57c992327b9c92d518d32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_boundary_conditions.html#ab45dbba66ee57c992327b9c92d518d32">BoundaryConditions</a> (const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;sidenodes)</td></tr>
<tr class="memdesc:ab45dbba66ee57c992327b9c92d518d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ab45dbba66ee57c992327b9c92d518d32">More...</a><br /></td></tr>
<tr class="separator:ab45dbba66ee57c992327b9c92d518d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8a5dfa21bdbfa191b6c5eb6e0ff24f"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_boundary_conditions.html#aea8a5dfa21bdbfa191b6c5eb6e0ff24f">sideNodes</a> (const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;filenodes, const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;lid)</td></tr>
<tr class="memdesc:aea8a5dfa21bdbfa191b6c5eb6e0ff24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create map that assigns the local mesh node IDs mapped to side set ids.  <a href="#aea8a5dfa21bdbfa191b6c5eb6e0ff24f">More...</a><br /></td></tr>
<tr class="separator:aea8a5dfa21bdbfa191b6c5eb6e0ff24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5122ce978a847b50f94c36b9f21cc22"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::size_t, std::vector&lt; std::pair&lt; bool, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_boundary_conditions.html#ab5122ce978a847b50f94c36b9f21cc22">match</a> (<a class="el" href="namespacetk_1_1ctr.html#a6cf6d7d0e1054ff78d756b64677281aa">tk::ctr::ncomp_type</a> ncomp, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> t, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> dt, const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;coord, const std::vector&lt; std::size_t &gt; gid, const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;sidenodes)</td></tr>
<tr class="memdesc:ab5122ce978a847b50f94c36b9f21cc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query and match user-specified boundary conditions to side sets.  <a href="#ab5122ce978a847b50f94c36b9f21cc22">More...</a><br /></td></tr>
<tr class="separator:ab5122ce978a847b50f94c36b9f21cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad29c69ab922ec79268e5d99c040af479"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_boundary_conditions.html#ad29c69ab922ec79268e5d99c040af479">m_sideFileNodes</a></td></tr>
<tr class="separator:ad29c69ab922ec79268e5d99c040af479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data and functionality working on boundary conditions. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00024">24</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab45dbba66ee57c992327b9c92d518d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45dbba66ee57c992327b9c92d518d32">&#9670;&nbsp;</a></span>BoundaryConditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BoundaryConditions::BoundaryConditions </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sidenodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8_c_source.html#l00026">26</a> of file <a class="el" href="_boundary_conditions_8_c_source.html">BoundaryConditions.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  : <a class="code" href="classinciter_1_1_boundary_conditions.html#ad29c69ab922ec79268e5d99c040af479">m_sideFileNodes</a>( sidenodes )</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">//  Constructor</span><span class="comment"></span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">//! \param[in] ss File mesh node IDs mapped to side set ids</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"></span><span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div><div class="ttc" id="classinciter_1_1_boundary_conditions_html_ad29c69ab922ec79268e5d99c040af479"><div class="ttname"><a href="classinciter_1_1_boundary_conditions.html#ad29c69ab922ec79268e5d99c040af479">inciter::BoundaryConditions::m_sideFileNodes</a></div><div class="ttdeci">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; m_sideFileNodes</div><div class="ttdef"><b>Definition:</b> <a href="_boundary_conditions_8h_source.html#l00051">BoundaryConditions.h:51</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab5122ce978a847b50f94c36b9f21cc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5122ce978a847b50f94c36b9f21cc22">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::size_t, std::vector&lt; std::pair&lt; bool, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt; &gt; BoundaryConditions::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk_1_1ctr.html#a6cf6d7d0e1054ff78d756b64677281aa">tk::ctr::ncomp_type</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sidenodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query and match user-specified boundary conditions to side sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ncomp</td><td>Number of scalar components in PDE system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Physical time at which to query boundary conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time step size (for querying BC increments in time) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Mesh node coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gid</td><td>Global node IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sidenodes</td><td>Map storing local mesh node IDs mapped to side set ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of pairs of bool and boundary condition value associated to mesh node IDs at which the user has set Dirichlet boundary conditions for all PDEs integrated. The bool indicates whether the BC is set at the node for that component the if true, the real value is the increment (from t to dt) in the BC specified for a component.</dd></dl>
<p>Boundary conditions (BC), mathematically speaking, are applied on finite surfaces. These finite surfaces are given by element sets (i.e., a list of elements). This function queries Dirichlet boundary condition values from all PDEs in the system of PDEs integrated at the node lists associated to side set IDs (previously read from file). As a response to this query, each PDE system returns a BC data structure which is then sent to the linear system solver which needs to know about this to apply BCs before a linear solve. Note that the BC mesh nodes that this function results in, stored in dirbc and sent to the linear system solver, only contains those nodes that this chare contributes to, i.e., it does not contain those BC nodes at which other chares enforce Dirichlet BCs. The linear system solver then collects these and communicates to other PEs so that BC data held in Solver::m_bc are the same on all PEs. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8_c_source.html#l00076">76</a> of file <a class="el" href="_boundary_conditions_8_c_source.html">BoundaryConditions.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00043">inciter::g_cgpde</a>, and <a class="el" href="_macro_8h_source.html#l00019">IGNORE</a>.</p>
<div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;{</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="comment">// Vector of pairs of bool and boundary condition value associated to mesh</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="comment">// node IDs at which the user has set Dirichlet boundary conditions for all</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// PDEs integrated. NodeBC = value_type.</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  std::unordered_map&lt; std::size_t,</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    std::vector&lt; std::pair&lt; bool, tk::real &gt; &gt; &gt; dirbc;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// Query Dirichlet boundary conditions for all PDEs integrated and assign to</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// nodes. This is where the individual system of PDEs are queried for boundary</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// conditions. The outer loop goes through all sides sets that exists in the</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="comment">// input file and passes the map&#39;s value_type (a pair of the side set id and a</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="comment">// vector of local node IDs) to PDE::dirbc(). PDE::dirbc() returns a new map</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="comment">// that associates a vector of pairs associated to local node IDs. (The pair</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="comment">// is a pair of bool and real value, the former is the fact that the BC is to</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="comment">// be set while the latter is the value if it is to be set). The length of</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="comment">// this NodeBC vector, returning from each system of PDEs equals to the number</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="comment">// of scalar components the given PDE integrates. Here then we contatenate</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="comment">// this map for all PDEs integrated. If there are multiple BCs set at a mesh</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="comment">// node (dirbc::key), either because (1) in the same PDE system the user</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="comment">// prescribed BCs on side sets that share nodes or (2) because more than a</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="comment">// single PDE system assigns BCs to a given node (on different variables), the</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="comment">// NodeBC vector must be correctly stored. &quot;Correctly&quot; here means that the</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="comment">// size of the NodeBC vectors must all be the same and qual to the sum of all</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="comment">// scalar components integrated by all PDE systems integrated. Example:</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  <span class="comment">// single-phase compressible flow (density, momentum, energy = 5) +</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="comment">// transported scalars of 10 variables -&gt; NodeBC vector length = 15. Note that</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="comment">// in case (1) above a new node encountered must &quot;overwrite&quot; the already</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="comment">// existing space for the NodeBC vector. &quot;Overwrite&quot; here means that it should</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="comment">// keep the existing BCs and add the new ones yielding the union the two</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="comment">// prescription for BCs but in the same space that already exist in the NodeBC</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// vector. In case (2), however, the NodeBC pairs must go to the location in</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="comment">// the vector assigned to the given PDE system, i.e., using the above example</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">// BCs for the 10 (or less) scalars should go in the positions starting at 5,</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">// leaving the first 5 false, indicating no BCs for the flow variables.</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// TODO: Note that the logic described above is only partially implemented at</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="comment">// this point. What works is the correct insertion of multiple BCs for nodes</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <span class="comment">// shared among multiple side sets, e.g., corners, originating from the same</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// PDE system. What is not yet implemented is the case when there are no BCs</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">// set for flow variables but there are BCs for transport, the else branch</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="comment">// below will incorrectly NOT skip the space for the flow variables. In other</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// words, this only works for a single PDE system and a sytem of systems. This</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="comment">// machinery is only tested with a single system of PDEs at this point.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : sidenodes) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    std::size_t c = 0;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">for</span> (std::size_t eq=0; eq&lt;<a class="code" href="namespaceinciter.html#a13d1fc7121850561556871530b310016">g_cgpde</a>.size(); ++eq) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      <span class="keyword">auto</span> eqbc = <a class="code" href="namespaceinciter.html#a13d1fc7121850561556871530b310016">g_cgpde</a>[eq].dirbc( t, dt, s, coord );</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : eqbc) {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keyword">auto</span> <span class="keywordtype">id</span> = n.first;                      <span class="comment">// BC node ID</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; bcs = n.second;             <span class="comment">// BCs</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keyword">auto</span>&amp; nodebc = dirbc[ gid[id] ];        <span class="comment">// BCs to be set for node</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">if</span> (nodebc.size() &gt; c) {        <span class="comment">// node already has BCs from this PDE</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;          <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nodebc.size() == c+bcs.size(), <span class="stringliteral">&quot;Size mismatch&quot;</span> );</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;          <span class="keywordflow">for</span> (std::size_t i=0; i&lt;bcs.size(); i++) {</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">if</span> (bcs[i].first) nodebc[c+i] = bcs[i];</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;          }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        } <span class="keywordflow">else</span> {        <span class="comment">// node does not yet have BCs from this PDE</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;          <span class="comment">// This branch needs to be completed for system of systems of PDEs.</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;          <span class="comment">// See note above.</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;          nodebc.insert( end(nodebc), begin(bcs), end(bcs) );</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      }</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keywordflow">if</span> (!eqbc.empty()) c += eqbc.cbegin()-&gt;second.size();</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// Verify the size of each NodeBC vectors. They must have the same lengths and</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="comment">// equal to the total number of scalar components for all systems of PDEs</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="comment">// integrated. This is intentional, because this way the linear system solver</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">// does not have to (and does not) know about individual equation systems.</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="comment">// This entire loop is optimized away in RELEASE mode, thus the IGNOREs to</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="comment">// silence compiler warnings.</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : dirbc) {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <a class="code" href="_macro_8h.html#a494f327b84ea26d04e3ad24251b4bbe0">IGNORE</a>(n);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( n.second.size() == ncomp, <span class="stringliteral">&quot;Size of NodeBC vector incorrect&quot;</span> );</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <a class="code" href="_macro_8h.html#a494f327b84ea26d04e3ad24251b4bbe0">IGNORE</a>(ncomp);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="keywordflow">return</span> dirbc;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;}</div><div class="ttc" id="namespaceinciter_html_a13d1fc7121850561556871530b310016"><div class="ttname"><a href="namespaceinciter.html#a13d1fc7121850561556871530b310016">inciter::g_cgpde</a></div><div class="ttdeci">std::vector&lt; CGPDE &gt; g_cgpde</div><div class="ttdef"><b>Definition:</b> <a href="_diag_c_g_8_c_source.html#l00043">DiagCG.C:43</a></div></div>
<div class="ttc" id="_macro_8h_html_a494f327b84ea26d04e3ad24251b4bbe0"><div class="ttname"><a href="_macro_8h.html#a494f327b84ea26d04e3ad24251b4bbe0">IGNORE</a></div><div class="ttdeci">#define IGNORE(expr)</div><div class="ttdoc">This macro can be used to suppress compiler warning on unused variable. </div><div class="ttdef"><b>Definition:</b> <a href="_macro_8h_source.html#l00019">Macro.h:19</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea8a5dfa21bdbfa191b6c5eb6e0ff24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8a5dfa21bdbfa191b6c5eb6e0ff24f">&#9670;&nbsp;</a></span>sideNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; BoundaryConditions::sideNodes </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create map that assigns the local mesh node IDs mapped to side set ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filenodes</td><td>Map associating file node IDs to local node IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lid</td><td>Local node IDs associated to global node IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map that assigns the local mesh node IDs mapped to side set ids, storing only those nodes for a given side set that are part of our chunk of the mesh (based on a search in filenodes) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8_c_source.html#l00037">37</a> of file <a class="el" href="_boundary_conditions_8_c_source.html">BoundaryConditions.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_container_util_8h_source.html#l00037">tk::cref_find()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00051">m_sideFileNodes</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="comment">// First generate map associating local node IDs to file node IDs. We invert</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="comment">// the map that associates file node IDs to local node IDs for the purpose of</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="comment">// enabling efficient searches of file node IDs.</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  std::unordered_map&lt; std::size_t, std::size_t &gt; localnodes;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : filenodes) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keyword">auto</span> n = <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a>( lid, i.first );</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( n &lt; lid.size(),</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="stringliteral">&quot;Local IDs must be lower than the local number of grid points&quot;</span> );</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    localnodes[ i.second ] = n;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  }</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="comment">// Create map that assigns the local mesh node IDs mapped to side set ids</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; sidenodes;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : <a class="code" href="classinciter_1_1_boundary_conditions.html#ad29c69ab922ec79268e5d99c040af479">m_sideFileNodes</a>) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="keyword">auto</span>&amp; n = sidenodes[ s.first ];</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> o : s.second) {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      <span class="keyword">auto</span> it = localnodes.find( o );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keywordflow">if</span> (it != end(localnodes))</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        n.push_back( it-&gt;second );</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  }</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">return</span> sidenodes;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;}</div><div class="ttc" id="classinciter_1_1_boundary_conditions_html_ad29c69ab922ec79268e5d99c040af479"><div class="ttname"><a href="classinciter_1_1_boundary_conditions.html#ad29c69ab922ec79268e5d99c040af479">inciter::BoundaryConditions::m_sideFileNodes</a></div><div class="ttdeci">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; m_sideFileNodes</div><div class="ttdef"><b>Definition:</b> <a href="_boundary_conditions_8h_source.html#l00051">BoundaryConditions.h:51</a></div></div>
<div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00037">ContainerUtil.h:37</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classinciter_1_1_boundary_conditions_aea8a5dfa21bdbfa191b6c5eb6e0ff24f_cgraph.svg" width="350" height="48"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad29c69ab922ec79268e5d99c040af479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29c69ab922ec79268e5d99c040af479">&#9670;&nbsp;</a></span>m_sideFileNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; inciter::BoundaryConditions::m_sideFileNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map associating file-node IDs to side set IDs for all side sets in file</p>
<p>This map stores mesh node IDs as exist in the mesh file associated to side set IDs for all side sets read from mesh file independent of what the user sets boundary conditions on </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00051">51</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8_c_source.html#l00037">sideNodes()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/<a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a></li>
<li>/tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/<a class="el" href="_boundary_conditions_8_c_source.html">BoundaryConditions.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 27 2018 03:56:08 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
