<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: tk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Toolkit declarations and definitions for general purpose utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetk_1_1ctr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1ctr.html">ctr</a></td></tr>
<tr class="memdesc:namespacetk_1_1ctr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit control, general purpose user input to internal data transfer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1grm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html">grm</a></td></tr>
<tr class="memdesc:namespacetk_1_1grm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit general purpose grammar definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1hypre"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1hypre.html">hypre</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1mkl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1mkl.html">mkl</a></td></tr>
<tr class="memdesc:namespacetk_1_1mkl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for Intel's Math Kernel Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1random123"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1random123.html">random123</a></td></tr>
<tr class="memdesc:namespacetk_1_1random123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for the <a class="el" href="classtk_1_1_random123.html" title="Random123-based random number generator used polymorphically with tk::RNG. ">Random123</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1rngsse"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1rngsse.html">rngsse</a></td></tr>
<tr class="memdesc:namespacetk_1_1rngsse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for the <a class="el" href="classtk_1_1_r_n_g_s_s_e.html" title="RNGSSE-based random number generator used polymorphically with tk::RNG. ">RNGSSE</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1tuple"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:namespacetk_1_1tuple"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged tuple allowing tag-based access to tuple members. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1zoltan"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html">zoltan</a></td></tr>
<tr class="memdesc:namespacetk_1_1zoltan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interoperation with the Zoltan library, used for static mesh partitioning. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_around.html">Around</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class simplifying client code for iterating on entries surrounding entries via linked lists derived from unstructured mesh connectivity.  <a href="classtk_1_1_around.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_a_s_c_mesh_reader.html">ASCMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_a_s_c_mesh_reader.html" title="ASCMeshReader : tk::Reader. ">ASCMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_a_s_c_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_bi_p_d_f.html">BiPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint bivariate PDF estimator.  <a href="classtk_1_1_bi_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html">Control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch.  <a href="classtk_1_1_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_diag_writer.html">DiagWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_diag_writer.html" title="DiagWriter : tk::Writer. ">DiagWriter</a> : <a class="el" href="classtk_1_1_writer.html">tk::Writer</a>.  <a href="classtk_1_1_diag_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic exception class for producing <a href="file:func:line">file:func:line</a> info + call trace.  <a href="classtk_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html">ExodusIIMeshReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_writer.html">ExodusIIMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_file_conv_writer.html">FileConvWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_file_parser.html">FileParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_file_parser.html" title="FileParser. ">FileParser</a>.  <a href="classtk_1_1_file_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_reader.html">GmshMeshReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_writer.html">GmshMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_h5_part_writer.html">H5PartWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_choices.html">HasFunctionExpectChoices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::choices".  <a href="structtk_1_1_has_function_expect_choices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_description.html">HasFunctionExpectDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::description".  <a href="structtk_1_1_has_function_expect_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_alias.html">HasTypedefAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "alias".  <a href="structtk_1_1_has_typedef_alias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_code.html">HasTypedefCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "code".  <a href="structtk_1_1_has_typedef_code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_expect_type.html">HasTypedefExpectType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "expect::type".  <a href="structtk_1_1_has_typedef_expect_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_proxy.html">HasTypedefProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "Proxy".  <a href="structtk_1_1_has_typedef_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_hyper_mesh_reader.html">HyperMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_hyper_mesh_reader.html" title="HyperMeshReader : tk::Reader. ">HyperMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_hyper_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_idx.html">Idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if__.html">if_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type selection: <a class="el" href="structtk_1_1if__.html#a456b6172591b18a1bd516f30b653444d">if_&lt; Condition, Then, Else &gt;::type</a>.  <a href="structtk_1_1if__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if___3_01false_00_01_then_00_01_else_01_4.html">if_&lt; false, Then, Else &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_linear_map.html">LinearMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list.html">make_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_01_4.html">make_list&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_00_01_args_8_8_8_01_4.html">make_list&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_4.html">make_list&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_m_k_l_r_n_g.html">MKLRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MKL-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_m_k_l_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_msg.html">Msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ message type for sending a single T, T must be POD.  <a href="structtk_1_1_msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_reader.html">NetgenMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_netgen_mesh_reader.html" title="NetgenMeshReader : tk::Reader. ">NetgenMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_netgen_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_writer.html">NetgenMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_particle_writer.html">ParticleWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ group used to output particle data to file in parallel using H5Part and MPI-IO.  <a href="classtk_1_1_particle_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_p_d_f_writer.html">PDFWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_p_d_f_writer.html" title="PDFWriter : Writer. ">PDFWriter</a> : <a class="el" href="classtk_1_1_writer.html">Writer</a>.  <a href="classtk_1_1_p_d_f_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_progress.html">Progress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_random123.html">Random123</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random123-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_random123.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_reader.html">Reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g.html">RNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator.  <a href="classtk_1_1_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_print.html">RNGPrint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_r_n_g_print.html" title="RNGPrint : Print. ">RNGPrint</a> : <a class="el" href="classtk_1_1_print.html">Print</a>.  <a href="classtk_1_1_r_n_g_print.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_s_s_e.html">RNGSSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RNGSSE-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_r_n_g_s_s_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_stack.html">RNGStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator stack.  <a href="classtk_1_1_r_n_g_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_root_mesh_writer.html">RootMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_silo_writer.html">SiloWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_silo_writer.html" title="SiloWriter. ">SiloWriter</a>.  <a href="classtk_1_1_silo_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_solver_shadow.html">SolverShadow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_statistics.html" title="Statistics estimator. ">Statistics</a> estimator.  <a href="classtk_1_1_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_mesh.html">STLMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_mesh.html" title="STLMesh. ">STLMesh</a>.  <a href="classtk_1_1_s_t_l_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html">STLTxtMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html" title="STLTxtMeshReader : tk::Reader. ">STLTxtMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_s_t_l_txt_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1str__const.html">str_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr string  <a href="classtk_1_1str__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_string_parser.html">StringParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_string_parser.html" title="StringParser. ">StringParser</a>.  <a href="classtk_1_1_string_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_strings_msg.html">StringsMsg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ message type for sending a string of strings separated by ';'.  <a href="structtk_1_1_strings_msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_toggle.html">Toggle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_toggle.html" title="Toggle is the base for an Option, doing generic searches. ">Toggle</a> is the base for an Option, doing generic searches.  <a href="classtk_1_1_toggle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_tracker.html">Tracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_tracker.html" title="Tracker advances Lagrangian particles in state space. ">Tracker</a> advances Lagrangian particles in state space.  <a href="classtk_1_1_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_tri_p_d_f.html">TriPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint trivariate PDF estimator.  <a href="classtk_1_1_tri_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_txt_stat_writer.html">TxtStatWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_txt_stat_writer.html" title="TxtStatWriter : tk::Writer. ">TxtStatWriter</a> : <a class="el" href="classtk_1_1_writer.html">tk::Writer</a>.  <a href="classtk_1_1_txt_stat_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uni_p_d_f.html">UniPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Univariate PDF estimator.  <a href="classtk_1_1_uni_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D unstructured mesh class  <a href="classtk_1_1_uns_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh_map.html">UnsMeshMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ array map for initial placement of array elements using an unstructured grid.  <a href="classtk_1_1_uns_mesh_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_variant.html">Variant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_vec_strs_msg.html">VecStrsMsg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_writer.html">Writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a732b6aaa7f495f4b1f06dd4d1acee269">is_enum_class</a> = typename boost::mpl::bool_&lt; std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_convertible&lt; T, uint8_t &gt;::value &gt;</td></tr>
<tr class="memdesc:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait querying whether T is a strongly typed enum.  <a href="#a732b6aaa7f495f4b1f06dd4d1acee269">More...</a><br /></td></tr>
<tr class="separator:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3683fffc858642385d1292c3817021"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">Table</a> = std::vector&lt; std::pair&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;</td></tr>
<tr class="memdesc:a4a3683fffc858642385d1292c3817021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for declaring, defining, and storing a discrete y = f(x) function.  <a href="#a4a3683fffc858642385d1292c3817021">More...</a><br /></td></tr>
<tr class="separator:a4a3683fffc858642385d1292c3817021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a96ada94b7e2911ecca0a360f305575"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">real</a> = double</td></tr>
<tr class="memdesc:a1a96ada94b7e2911ecca0a360f305575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real number type used throughout the whole code.  <a href="#a1a96ada94b7e2911ecca0a360f305575">More...</a><br /></td></tr>
<tr class="separator:a1a96ada94b7e2911ecca0a360f305575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff0a76887b93164712b9ce9192fdd2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a40ff0a76887b93164712b9ce9192fdd2">SiloErrorHandler</a>) (char *)</td></tr>
<tr class="memdesc:a40ff0a76887b93164712b9ce9192fdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler function type.  <a href="#a40ff0a76887b93164712b9ce9192fdd2">More...</a><br /></td></tr>
<tr class="separator:a40ff0a76887b93164712b9ce9192fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf453dedb17140704a4e947d172bae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">ncomp_t</a> = kw::ncomp::info::expect::type</td></tr>
<tr class="separator:a9bf453dedb17140704a4e947d172bae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74de56fa53c55c0a8f35b764729cdf20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20">RNGFactory</a> = std::map&lt; <a class="el" href="namespacetk_1_1ctr.html#aa1b0831f9e998d8133473f63480b3ecb">ctr::RNGType</a>, std::function&lt; <a class="el" href="classtk_1_1_r_n_g.html">RNG</a>() &gt; &gt;</td></tr>
<tr class="memdesc:a74de56fa53c55c0a8f35b764729cdf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator factory: keys associated to their constructors.  <a href="#a74de56fa53c55c0a8f35b764729cdf20">More...</a><br /></td></tr>
<tr class="separator:a74de56fa53c55c0a8f35b764729cdf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afcc275d91d4368505f221061b9ba822a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">ErrCode</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a> = EXIT_SUCCESS, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a> = EXIT_FAILURE
<br />
 }<tr class="memdesc:afcc275d91d4368505f221061b9ba822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for the OS (or whatever calls us)  <a href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afcc275d91d4368505f221061b9ba822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d172b64b84ff0554f0e87475f4541b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">Style</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a> =1
<br />
 }<tr class="memdesc:a1d172b64b84ff0554f0e87475f4541b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output verbosity. C-style enum as this is used for template argument.  <a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1d172b64b84ff0554f0e87475f4541b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3781b50ef71ead8dd0bd286455c6030c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">ExoElemType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a> = 1
<br />
 }<tr class="memdesc:a3781b50ef71ead8dd0bd286455c6030c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported ExodusII mesh cell types.  <a href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3781b50ef71ead8dd0bd286455c6030c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">ExoWriter</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">ExoWriter::CREATE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">ExoWriter::OPEN</a>
<br />
 }<tr class="memdesc:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExodusII writer constructor modes.  <a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85016961456a798f65e4e5a451e44242"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">GmshElemType</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> = 15
<br />
 }<tr class="memdesc:a85016961456a798f65e4e5a451e44242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers of supported Gmsh elements.  <a href="namespacetk.html#a85016961456a798f65e4e5a451e44242">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a85016961456a798f65e4e5a451e44242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af910e1a2aff3119022dea29cf3d898c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">GmshFileType</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">GmshFileType::UNDEFINED</a> = -1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">GmshFileType::ASCII</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">GmshFileType::BINARY</a> = 1
<br />
 }<tr class="memdesc:af910e1a2aff3119022dea29cf3d898c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported Gmsh mesh file types.  <a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af910e1a2aff3119022dea29cf3d898c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748833535365d6e320da5fcb7d213c30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">MeshReader::GMSH</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">MeshReader::NETGEN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">MeshReader::EXODUSII</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade">MeshReader::HYPER</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c">MeshReader::ASC</a>
<br />
 }<tr class="memdesc:a748833535365d6e320da5fcb7d213c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh readers.  <a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a748833535365d6e320da5fcb7d213c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d2f365ad601e02c8d64479adfd4a7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fad8e85cdb6ef83caac7fa35c22dda2153">MeshWriter::GMSH</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fa8d2dc7a7e41c392a0da416ec0626e676">MeshWriter::NETGEN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fa834c8a77b335ad1c7bb2b632b6857339">MeshWriter::EXODUSII</a>
<br />
 }<tr class="memdesc:a43d2f365ad601e02c8d64479adfd4a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh writers.  <a href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a43d2f365ad601e02c8d64479adfd4a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3032aaeb67d38d01181590cd7f0acc7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">HeaderType::INCITER</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">HeaderType::RNGTEST</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">HeaderType::UNITTEST</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">HeaderType::MESHCONV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a">HeaderType::FILECONV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">HeaderType::WALKER</a>
<br />
 }<tr class="memdesc:a3032aaeb67d38d01181590cd7f0acc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>.  <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3032aaeb67d38d01181590cd7f0acc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a87af1b002bc711716bd170a714bda211"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a87af1b002bc711716bd170a714bda211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">unique</a> (Container &amp;c)</td></tr>
<tr class="separator:a87af1b002bc711716bd170a714bda211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e002561a68875b091a264eb2a1e5f6c"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2e002561a68875b091a264eb2a1e5f6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">cref_find</a> (const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</td></tr>
<tr class="separator:a2e002561a68875b091a264eb2a1e5f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab2aac5f0fd93d5119cfe50a39f3515c9">ref_find</a> (const Container &amp;map, const typename Container::key_type &amp;key) -&gt; typename Container::mapped_type &amp;</td></tr>
<tr class="separator:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0de4157a7818da7a9deb1476099bd8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0de4157a7818da7a9deb1476099bd8d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#af0de4157a7818da7a9deb1476099bd8d">extents</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:af0de4157a7818da7a9deb1476099bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return minimum and maximum values of a vector.  <a href="#af0de4157a7818da7a9deb1476099bd8d">More...</a><br /></td></tr>
<tr class="separator:af0de4157a7818da7a9deb1476099bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1930c11b6d90076b9d17c9f9c9d49efe">extents</a> (const Container &amp;map) -&gt; std::array&lt; typename Container::mapped_type, 2 &gt;</td></tr>
<tr class="separator:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47c993218d9384828fcce2794850ac7"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ad47c993218d9384828fcce2794850ac7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad47c993218d9384828fcce2794850ac7">operator+=</a> (std::vector&lt; T, Allocator &gt; &amp;dst, const std::vector&lt; T, Allocator &gt; &amp;src)</td></tr>
<tr class="memdesc:ad47c993218d9384828fcce2794850ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all elements of a vector to another one.  <a href="#ad47c993218d9384828fcce2794850ac7">More...</a><br /></td></tr>
<tr class="separator:ad47c993218d9384828fcce2794850ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b203c3a87657090a5c477896ce94bf9"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6b203c3a87657090a5c477896ce94bf9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a6b203c3a87657090a5c477896ce94bf9">keyEqual</a> (const Container &amp;a, const Container &amp;b)</td></tr>
<tr class="separator:a6b203c3a87657090a5c477896ce94bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0f319a47a6a5b983e161aa5f4d8f7b6c">sumsize</a> (const Container &amp;c)</td></tr>
<tr class="separator:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9140b408dcbd2eaef58f9c3a54fa104a"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a9140b408dcbd2eaef58f9c3a54fa104a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9140b408dcbd2eaef58f9c3a54fa104a">destroy</a> (Container &amp;c)</td></tr>
<tr class="separator:a9140b408dcbd2eaef58f9c3a54fa104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc362fc7a89c617e1ab8f57f1dbd100a"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:adc362fc7a89c617e1ab8f57f1dbd100a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#adc362fc7a89c617e1ab8f57f1dbd100a">operator*</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:adc362fc7a89c617e1ab8f57f1dbd100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd730d099e698f124362ef8c01483e0f"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:afd730d099e698f124362ef8c01483e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">min</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;a, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;b)</td></tr>
<tr class="separator:afd730d099e698f124362ef8c01483e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a26e30d19b940a12990a866a514cb5"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ac9a26e30d19b940a12990a866a514cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">max</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;a, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;b)</td></tr>
<tr class="separator:ac9a26e30d19b940a12990a866a514cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a21669e4d06c62a58cd0f4bf63868ab7e">operator==</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac38f5055c45cd35b8ce00151cea4c1d3">operator!=</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::size_t, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab7f02155bc2945a0a0c82c1be5cad041">maxdiff</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad986ef5558d44d5e0c6650c589499980"><td class="memTemplParams" colspan="2">template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </td></tr>
<tr class="memitem:ad986ef5558d44d5e0c6650c589499980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980">record</a> (Factory &amp;f, const Key &amp;key, ConstructorArgs &amp;&amp;... args)</td></tr>
<tr class="separator:ad986ef5558d44d5e0c6650c589499980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9673379e599043b13fff369dce1402"><td class="memTemplParams" colspan="2">template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </td></tr>
<tr class="memitem:aeb9673379e599043b13fff369dce1402"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> (const Factory &amp;f, const Key &amp;key)</td></tr>
<tr class="separator:aeb9673379e599043b13fff369dce1402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr class="memitem:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a24170c3146caaa7b79d78d4aa1d98f66">recordModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98b4e55f14339c707622a8da43d8ce9"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </td></tr>
<tr class="memitem:ae98b4e55f14339c707622a8da43d8ce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae98b4e55f14339c707622a8da43d8ce9">recordModelLate</a> (Factory &amp;f, const Key &amp;key, ModelConstrArg)</td></tr>
<tr class="separator:ae98b4e55f14339c707622a8da43d8ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6374b4792dbd3c626dad60bcef168"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr class="memitem:a4bd6374b4792dbd3c626dad60bcef168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4bd6374b4792dbd3c626dad60bcef168">recordCharmModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a4bd6374b4792dbd3c626dad60bcef168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac2323b3c43edbcc32d55d91100ffc3a6">flip_pair</a> (const std::pair&lt; A, B &gt; &amp;p)</td></tr>
<tr class="separator:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memTemplItemLeft" align="right" valign="top">std::multimap&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a42982d289f8edfffa60fa4da8b7b9fdf">flip_map</a> (const std::map&lt; A, B &gt; &amp;src)</td></tr>
<tr class="separator:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a928cb4648630899f34ee7ad08fd754"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </td></tr>
<tr class="memitem:a8a928cb4648630899f34ee7ad08fd754"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">serialize</a> (const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</td></tr>
<tr class="separator:a8a928cb4648630899f34ee7ad08fd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371117af5d2009dca83a8cb5539a43f"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </td></tr>
<tr class="memitem:ac371117af5d2009dca83a8cb5539a43f"><td class="memTemplItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac371117af5d2009dca83a8cb5539a43f">mergeHashMap</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:ac371117af5d2009dca83a8cb5539a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.  <a href="#ac371117af5d2009dca83a8cb5539a43f">More...</a><br /></td></tr>
<tr class="separator:ac371117af5d2009dca83a8cb5539a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484074849c5c9532282fc9fa4e19467"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae484074849c5c9532282fc9fa4e19467">linearLoadDistributor</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> virtualization, uint64_t load, int npe, uint64_t &amp;chunksize, uint64_t &amp;remainder)</td></tr>
<tr class="memdesc:ae484074849c5c9532282fc9fa4e19467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear load distribution for given total work and virtualization.  <a href="#ae484074849c5c9532282fc9fa4e19467">More...</a><br /></td></tr>
<tr class="separator:ae484074849c5c9532282fc9fa4e19467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1bbb9b08d37f6f5f3bed45effc8fc64e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const std::vector&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memTemplParams" colspan="2">template&lt;typename Msg &gt; </td></tr>
<tr class="memitem:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5d61711de49d010da4785f7cb6ad2d9b">waitfor</a> (const CkFuture &amp;f)</td></tr>
<tr class="separator:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4d5bfee8e8bdea2bc60e5d725672af09">rm</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file from file system.  <a href="#a4d5bfee8e8bdea2bc60e5d725672af09">More...</a><br /></td></tr>
<tr class="separator:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ed65df66049a89a8a5055895ae417a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">signalHandler</a> (int signum)</td></tr>
<tr class="memdesc:ad0ed65df66049a89a8a5055895ae417a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal handler for multiple signals, SIGABRT, SIGSEGV, etc.  <a href="#ad0ed65df66049a89a8a5055895ae417a">More...</a><br /></td></tr>
<tr class="separator:ad0ed65df66049a89a8a5055895ae417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c72da5967d8fb725ff4a26294a871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5e8c72da5967d8fb725ff4a26294a871">setSignalHandlers</a> ()</td></tr>
<tr class="memdesc:a5e8c72da5967d8fb725ff4a26294a871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc.  <a href="#a5e8c72da5967d8fb725ff4a26294a871">More...</a><br /></td></tr>
<tr class="separator:a5e8c72da5967d8fb725ff4a26294a871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04df49334286e653e440035c499a8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af04df49334286e653e440035c499a8d1">processExceptionCharm</a> ()</td></tr>
<tr class="memdesc:af04df49334286e653e440035c499a8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the Charm++ runtime system.  <a href="#af04df49334286e653e440035c499a8d1">More...</a><br /></td></tr>
<tr class="separator:af04df49334286e653e440035c499a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a2a62b5b6880fbd0a011cedf8896b19dc">processExceptionMPI</a> ()</td></tr>
<tr class="memdesc:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the MPI runtime system.  <a href="#a2a62b5b6880fbd0a011cedf8896b19dc">More...</a><br /></td></tr>
<tr class="separator:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d376e7f0dd51a64632432345dd4423"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7d376e7f0dd51a64632432345dd4423"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aa7d376e7f0dd51a64632432345dd4423">swap_endian</a> (T u)</td></tr>
<tr class="separator:aa7d376e7f0dd51a64632432345dd4423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550509206419175e2b2277bc5c18016e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a550509206419175e2b2277bc5c18016e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a550509206419175e2b2277bc5c18016e">swap_endian</a> (double u)</td></tr>
<tr class="separator:a550509206419175e2b2277bc5c18016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd06aee13370660ff0109b8f8b1958e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aabd06aee13370660ff0109b8f8b1958e"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aabd06aee13370660ff0109b8f8b1958e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const T &amp;e)</td></tr>
<tr class="separator:aabd06aee13370660ff0109b8f8b1958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aa160d13ea2e4a3498916472c3b6cdbb0">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;lhs, const T &amp;e)</td></tr>
<tr class="separator:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7adfa2dfb8b3a38f60ac0edf5666b6c4">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;&amp;lhs, const T &amp;e)</td></tr>
<tr class="separator:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a553d30e4fd16f06342dd643d26c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a28a553d30e4fd16f06342dd643d26c25">sample</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> x, const <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> &amp;table)</td></tr>
<tr class="memdesc:a28a553d30e4fd16f06342dd643d26c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a discrete y = f(x) function at x.  <a href="#a28a553d30e4fd16f06342dd643d26c25">More...</a><br /></td></tr>
<tr class="separator:a28a553d30e4fd16f06342dd643d26c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6260a3dcdcb9a995a4886e566b665c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad6260a3dcdcb9a995a4886e566b665c4">hms</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> stamp)</td></tr>
<tr class="memdesc:ad6260a3dcdcb9a995a4886e566b665c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert existing time stamp as a real to Watch (global scope)  <a href="#ad6260a3dcdcb9a995a4886e566b665c4">More...</a><br /></td></tr>
<tr class="separator:ad6260a3dcdcb9a995a4886e566b665c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d7dd976738fc1e3de5f4ee6147140"><td class="memTemplParams" colspan="2">template&lt;class ProxyElem , class Proxy &gt; </td></tr>
<tr class="memitem:a928d7dd976738fc1e3de5f4ee6147140"><td class="memTemplItemLeft" align="right" valign="top">ProxyElem&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> (const Proxy &amp;proxy, const CkArrayIndex1D &amp;x)</td></tr>
<tr class="separator:a928d7dd976738fc1e3de5f4ee6147140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab602857e33f89cab4cc3788576ab1519"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab602857e33f89cab4cc3788576ab1519"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr class="separator:ab602857e33f89cab4cc3788576ab1519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">crossdiv</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)</td></tr>
<tr class="separator:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr class="separator:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b04b00aa51667b944b7188545ec5ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5b04b00aa51667b944b7188545ec5ae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">triple</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</td></tr>
<tr class="separator:ae5b04b00aa51667b944b7188545ec5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ea32478ab229dc49f14585c74fec2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab33ea32478ab229dc49f14585c74fec2">serialize</a> (const std::vector&lt; std::size_t &gt; &amp;v)</td></tr>
<tr class="memdesc:ab33ea32478ab229dc49f14585c74fec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize std::vector to raw memory stream.  <a href="#ab33ea32478ab229dc49f14585c74fec2">More...</a><br /></td></tr>
<tr class="separator:ab33ea32478ab229dc49f14585c74fec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ded68a9723df3debe38af3634e139"><td class="memItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#adb0ded68a9723df3debe38af3634e139">mergeVector</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:adb0ded68a9723df3debe38af3634e139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging std::vectors during reduction across PEs.  <a href="#adb0ded68a9723df3debe38af3634e139">More...</a><br /></td></tr>
<tr class="separator:adb0ded68a9723df3debe38af3634e139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e7ddf794b944c7d2095c1222f4244a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">detectInput</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a08e7ddf794b944c7d2095c1222f4244a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect input mesh file type.  <a href="#a08e7ddf794b944c7d2095c1222f4244a">More...</a><br /></td></tr>
<tr class="separator:a08e7ddf794b944c7d2095c1222f4244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b09f52ea3b4314e449e70255837836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">pickOutput</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a64b09f52ea3b4314e449e70255837836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine output mesh file type.  <a href="#a64b09f52ea3b4314e449e70255837836">More...</a><br /></td></tr>
<tr class="separator:a64b09f52ea3b4314e449e70255837836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947865970b76333655208aea71ceb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af947865970b76333655208aea71ceb71">readUnsMesh</a> (const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;print, const std::string &amp;filename, std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;timestamp)</td></tr>
<tr class="memdesc:af947865970b76333655208aea71ceb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unstructured mesh from file.  <a href="#af947865970b76333655208aea71ceb71">More...</a><br /></td></tr>
<tr class="separator:af947865970b76333655208aea71ceb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ff858133bdb654de9b95c279427325"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a92ff858133bdb654de9b95c279427325">writeUnsMesh</a> (const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;print, const std::string &amp;filename, <a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> &amp;mesh, bool reorder)</td></tr>
<tr class="memdesc:a92ff858133bdb654de9b95c279427325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unstructured mesh to file.  <a href="#a92ff858133bdb654de9b95c279427325">More...</a><br /></td></tr>
<tr class="separator:a92ff858133bdb654de9b95c279427325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ee8c554da198c14efbb80a0b623a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a20ee8c554da198c14efbb80a0b623a4a">SiloError</a> (char *msg)</td></tr>
<tr class="memdesc:a20ee8c554da198c14efbb80a0b623a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler.  <a href="#a20ee8c554da198c14efbb80a0b623a4a">More...</a><br /></td></tr>
<tr class="separator:a20ee8c554da198c14efbb80a0b623a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbeb1245c469101fb0f280aa51fe0c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abcbeb1245c469101fb0f280aa51fe0c9">poinCommMaps</a> (std::size_t graphsize, const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, std::size_t nchare, std::string &amp;&amp;toofine)</td></tr>
<tr class="memdesc:abcbeb1245c469101fb0f280aa51fe0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-based communication maps.  <a href="#abcbeb1245c469101fb0f280aa51fe0c9">More...</a><br /></td></tr>
<tr class="separator:abcbeb1245c469101fb0f280aa51fe0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983201a427244339722ca9a4e809f48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5983201a427244339722ca9a4e809f48">elemCommMaps</a> (const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, const std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt; &amp;<a class="el" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a>, std::size_t nchare)</td></tr>
<tr class="memdesc:a5983201a427244339722ca9a4e809f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute element-based communication maps.  <a href="#a5983201a427244339722ca9a4e809f48">More...</a><br /></td></tr>
<tr class="separator:a5983201a427244339722ca9a4e809f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">workdir</a> ()</td></tr>
<tr class="memdesc:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for POSIX API's getcwd() from unistd.h.  <a href="#a8e567fa9a72a1d5d02cea9eb020b192a">More...</a><br /></td></tr>
<tr class="separator:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ebefad09fa900014b6271b30e8bd5f"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">curtime</a> ()</td></tr>
<tr class="memdesc:a69ebefad09fa900014b6271b30e8bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the standard C library's gettimeofday() from.  <a href="#a69ebefad09fa900014b6271b30e8bd5f">More...</a><br /></td></tr>
<tr class="separator:a69ebefad09fa900014b6271b30e8bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf10b984ba3f66b55cc8363c6a2341"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">echoHeader</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> header)</td></tr>
<tr class="memdesc:afbbf10b984ba3f66b55cc8363c6a2341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo program header.  <a href="#afbbf10b984ba3f66b55cc8363c6a2341">More...</a><br /></td></tr>
<tr class="separator:afbbf10b984ba3f66b55cc8363c6a2341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72923dba604ccbf4233af3ccafc70b3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">echoBuildEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, const std::string &amp;executable)</td></tr>
<tr class="memdesc:ab72923dba604ccbf4233af3ccafc70b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo build environment.  <a href="#ab72923dba604ccbf4233af3ccafc70b3">More...</a><br /></td></tr>
<tr class="separator:ab72923dba604ccbf4233af3ccafc70b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ea7a4015fef3262bdb056f840bf82"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">echoRunEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, int argc, char **argv, bool verbose)</td></tr>
<tr class="memdesc:a991ea7a4015fef3262bdb056f840bf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo runtime environment.  <a href="#a991ea7a4015fef3262bdb056f840bf82">More...</a><br /></td></tr>
<tr class="separator:a991ea7a4015fef3262bdb056f840bf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d21933fc9e1a656db37419b2173f5f"><td class="memTemplParams" colspan="2">template&lt;class Driver , class Printer , class CmdLine &gt; </td></tr>
<tr class="memitem:af9d21933fc9e1a656db37419b2173f5f"><td class="memTemplItemLeft" align="right" valign="top">Driver&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f">Main</a> (int argc, char *argv[], const CmdLine &amp;cmdline, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> header, const std::string &amp;executable, const Printer &amp;print)</td></tr>
<tr class="memdesc:af9d21933fc9e1a656db37419b2173f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output. ">Main()</a> used for all executables for code-reuse and a uniform output.  <a href="#af9d21933fc9e1a656db37419b2173f5f">More...</a><br /></td></tr>
<tr class="separator:af9d21933fc9e1a656db37419b2173f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd71f3e10edf6e1a8d047478abd488c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel)</td></tr>
<tr class="memdesc:abdd71f3e10edf6e1a8d047478abd488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute number of points (nodes) in mesh from connectivity.  <a href="#abdd71f3e10edf6e1a8d047478abd488c">More...</a><br /></td></tr>
<tr class="separator:abdd71f3e10edf6e1a8d047478abd488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a2889d5d8aeb4a836842c6a1010463"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">genEsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</td></tr>
<tr class="memdesc:a66a2889d5d8aeb4a836842c6a1010463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points.  <a href="#a66a2889d5d8aeb4a836842c6a1010463">More...</a><br /></td></tr>
<tr class="separator:a66a2889d5d8aeb4a836842c6a1010463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a88a65102c17149b44660db15d445b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">genPsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:ad2a88a65102c17149b44660db15d445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, points surrounding points.  <a href="#ad2a88a65102c17149b44660db15d445b">More...</a><br /></td></tr>
<tr class="separator:ad2a88a65102c17149b44660db15d445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a88611b67f7c809f2bba5c794df0b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b">genEdsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:adb7a88611b67f7c809f2bba5c794df0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges surrounding points.  <a href="#adb7a88611b67f7c809f2bba5c794df0b">More...</a><br /></td></tr>
<tr class="separator:adb7a88611b67f7c809f2bba5c794df0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559eb56e40ec844767bd2a55da55bda0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">genInpoed</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a559eb56e40ec844767bd2a55da55bda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edge connectivity.  <a href="#a559eb56e40ec844767bd2a55da55bda0">More...</a><br /></td></tr>
<tr class="separator:a559eb56e40ec844767bd2a55da55bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d835a7a93970d17a66356b64f3291af"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9d835a7a93970d17a66356b64f3291af">genEsupel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a9d835a7a93970d17a66356b64f3291af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points of elements.  <a href="#a9d835a7a93970d17a66356b64f3291af">More...</a><br /></td></tr>
<tr class="separator:a9d835a7a93970d17a66356b64f3291af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b12aff8f884c70e45c6037b4f37e662"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7b12aff8f884c70e45c6037b4f37e662">genEsuel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a7b12aff8f884c70e45c6037b4f37e662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding elements.  <a href="#a7b12aff8f884c70e45c6037b4f37e662">More...</a><br /></td></tr>
<tr class="separator:a7b12aff8f884c70e45c6037b4f37e662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7c8a720dd257388a44d5ca7af7aaec8f">genInedel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::vector&lt; std::size_t &gt; &amp;inpoed)</td></tr>
<tr class="memdesc:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges of elements.  <a href="#a7c8a720dd257388a44d5ca7af7aaec8f">More...</a><br /></td></tr>
<tr class="separator:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff39252e99681eebb5ccf0078b7b924"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924">genEsued</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:abff39252e99681eebb5ccf0078b7b924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding edges.  <a href="#abff39252e99681eebb5ccf0078b7b924">More...</a><br /></td></tr>
<tr class="separator:abff39252e99681eebb5ccf0078b7b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68c15dd976b0c7420ebee8770fb1f9c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab68c15dd976b0c7420ebee8770fb1f9c">genNbfacTet</a> (std::size_t tnbfac, const std::vector&lt; std::size_t &gt; &amp;inpoel, const std::vector&lt; std::size_t &gt; &amp;triinpoel_complete, const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;bface_complete, const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;lid, std::vector&lt; std::size_t &gt; &amp;triinpoel, std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;bface)</td></tr>
<tr class="memdesc:ab68c15dd976b0c7420ebee8770fb1f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate total number of boundary faces in this chunk.  <a href="#ab68c15dd976b0c7420ebee8770fb1f9c">More...</a><br /></td></tr>
<tr class="separator:ab68c15dd976b0c7420ebee8770fb1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61b3cb6492e71ff9853404440fddcc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5b61b3cb6492e71ff9853404440fddcc">genEsuelTet</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a5b61b3cb6492e71ff9853404440fddcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1.  <a href="#a5b61b3cb6492e71ff9853404440fddcc">More...</a><br /></td></tr>
<tr class="separator:a5b61b3cb6492e71ff9853404440fddcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94114220a51c1ba65f5f1e8314ffc27e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a94114220a51c1ba65f5f1e8314ffc27e">genNtfac</a> (std::size_t nfpe, std::size_t nbfac, const std::vector&lt; int &gt; &amp;esuelTet)</td></tr>
<tr class="memdesc:a94114220a51c1ba65f5f1e8314ffc27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, total number of faces.  <a href="#a94114220a51c1ba65f5f1e8314ffc27e">More...</a><br /></td></tr>
<tr class="separator:a94114220a51c1ba65f5f1e8314ffc27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d934afca4d36661acc1b3e6f863f05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae2d934afca4d36661acc1b3e6f863f05">genEsuf</a> (std::size_t nfpe, std::size_t ntfac, std::size_t nbfac, const std::vector&lt; std::size_t &gt; &amp;belem, const std::vector&lt; int &gt; &amp;esuelTet)</td></tr>
<tr class="memdesc:ae2d934afca4d36661acc1b3e6f863f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding faces.  <a href="#ae2d934afca4d36661acc1b3e6f863f05">More...</a><br /></td></tr>
<tr class="separator:ae2d934afca4d36661acc1b3e6f863f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501950a1a32199708b69a52382f1b1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae501950a1a32199708b69a52382f1b1e">genInpofaTet</a> (std::size_t ntfac, std::size_t nbfac, const std::vector&lt; std::size_t &gt; &amp;inpoel, const std::vector&lt; std::size_t &gt; &amp;triinpoel, const std::vector&lt; int &gt; &amp;esuelTet)</td></tr>
<tr class="memdesc:ae501950a1a32199708b69a52382f1b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, node-face connectivity.  <a href="#ae501950a1a32199708b69a52382f1b1e">More...</a><br /></td></tr>
<tr class="separator:ae501950a1a32199708b69a52382f1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e35d3f9e7f2237c0c5c3b9c5c0888"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad69e35d3f9e7f2237c0c5c3b9c5c0888">genBelemTet</a> (std::size_t nbfac, const std::vector&lt; std::size_t &gt; &amp;inpofa, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:ad69e35d3f9e7f2237c0c5c3b9c5c0888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, host/boundary element.  <a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888">More...</a><br /></td></tr>
<tr class="separator:ad69e35d3f9e7f2237c0c5c3b9c5c0888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a2eebfe3b1f67bafb3131442ffffa1"><td class="memItemLeft" align="right" valign="top">tk::Fields&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a61a2eebfe3b1f67bafb3131442ffffa1">genGeoFaceTri</a> (std::size_t ntfac, const std::vector&lt; std::size_t &gt; &amp;inpofa, const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;coord)</td></tr>
<tr class="memdesc:a61a2eebfe3b1f67bafb3131442ffffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, face geometry.  <a href="#a61a2eebfe3b1f67bafb3131442ffffa1">More...</a><br /></td></tr>
<tr class="separator:a61a2eebfe3b1f67bafb3131442ffffa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f7ec47d21ee4be4ef5a6e58fdd4776"><td class="memItemLeft" align="right" valign="top">tk::Fields&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a51f7ec47d21ee4be4ef5a6e58fdd4776">geoFaceTri</a> (const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;x, const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;y, const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;z)</td></tr>
<tr class="memdesc:a51f7ec47d21ee4be4ef5a6e58fdd4776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometry of the face given by three vertices.  <a href="#a51f7ec47d21ee4be4ef5a6e58fdd4776">More...</a><br /></td></tr>
<tr class="separator:a51f7ec47d21ee4be4ef5a6e58fdd4776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33c6a2dc1649b840ab82bfcd3d1617a"><td class="memItemLeft" align="right" valign="top">tk::Fields&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af33c6a2dc1649b840ab82bfcd3d1617a">genGeoElemTet</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;coord)</td></tr>
<tr class="memdesc:af33c6a2dc1649b840ab82bfcd3d1617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, element geometry.  <a href="#af33c6a2dc1649b840ab82bfcd3d1617a">More...</a><br /></td></tr>
<tr class="separator:af33c6a2dc1649b840ab82bfcd3d1617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5766a4d0dae70d561c514f2758072e"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#aae5766a4d0dae70d561c514f2758072e">nodegrad</a> (std::size_t node, const std::array&lt; std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;, 3 &gt; &amp;coord, const std::vector&lt; std::size_t &gt; &amp;inpoel, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup, const tk::Fields &amp;U, <a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">ncomp_t</a> c)</td></tr>
<tr class="memdesc:aae5766a4d0dae70d561c514f2758072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient at a mesh node.  <a href="#aae5766a4d0dae70d561c514f2758072e">More...</a><br /></td></tr>
<tr class="separator:aae5766a4d0dae70d561c514f2758072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8deceeef86846672dd872bb7e975bb13"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8deceeef86846672dd872bb7e975bb13">edgegrad</a> (std::size_t edge, const std::array&lt; std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;, 3 &gt; &amp;coord, const std::vector&lt; std::size_t &gt; &amp;inpoel, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esued, const tk::Fields &amp;U, <a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">ncomp_t</a> c)</td></tr>
<tr class="memdesc:a8deceeef86846672dd872bb7e975bb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient at a mesh edge.  <a href="#a8deceeef86846672dd872bb7e975bb13">More...</a><br /></td></tr>
<tr class="separator:a8deceeef86846672dd872bb7e975bb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a293dd6fafcc3b8f4b28bef4f3ef050e1">shiftToZero</a> (std::vector&lt; std::size_t &gt; &amp;inpoel)</td></tr>
<tr class="memdesc:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift node IDs to start with zero in element connectivity.  <a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1">More...</a><br /></td></tr>
<tr class="separator:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ac7b3e006f7fa6621ad910b6553cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">remap</a> (std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;map)</td></tr>
<tr class="memdesc:a261ac7b3e006f7fa6621ad910b6553cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply new mapping to vector of indices.  <a href="#a261ac7b3e006f7fa6621ad910b6553cc">More...</a><br /></td></tr>
<tr class="separator:a261ac7b3e006f7fa6621ad910b6553cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af808bcf55ee4b5e910f68ecb0fe2f8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af808bcf55ee4b5e910f68ecb0fe2f8dd">remap</a> (std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;r, const std::vector&lt; std::size_t &gt; &amp;map)</td></tr>
<tr class="memdesc:af808bcf55ee4b5e910f68ecb0fe2f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply new mapping to vector of real numbers.  <a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd">More...</a><br /></td></tr>
<tr class="separator:af808bcf55ee4b5e910f68ecb0fe2f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8b455edb4f8453d5a6173319f9c80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a22a8b455edb4f8453d5a6173319f9c80">renumber</a> (const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)</td></tr>
<tr class="memdesc:a22a8b455edb4f8453d5a6173319f9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder mesh points with the advancing front technique.  <a href="#a22a8b455edb4f8453d5a6173319f9c80">More...</a><br /></td></tr>
<tr class="separator:a22a8b455edb4f8453d5a6173319f9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb19d7c5f6c7354614bb457d6b17afde"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">assignLid</a> (const std::vector&lt; std::size_t &gt; &amp;gid)</td></tr>
<tr class="memdesc:acb19d7c5f6c7354614bb457d6b17afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign local ids to global ids.  <a href="#acb19d7c5f6c7354614bb457d6b17afde">More...</a><br /></td></tr>
<tr class="separator:acb19d7c5f6c7354614bb457d6b17afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7abd71123782d48e2ec04906fe982"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt;, std::unordered_map&lt; std::size_t, std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0ee7abd71123782d48e2ec04906fe982">global2local</a> (const std::vector&lt; std::size_t &gt; &amp;ginpoel)</td></tr>
<tr class="memdesc:a0ee7abd71123782d48e2ec04906fe982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.  <a href="#a0ee7abd71123782d48e2ec04906fe982">More...</a><br /></td></tr>
<tr class="separator:a0ee7abd71123782d48e2ec04906fe982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f585439fa7abf61b26704881e98a168"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1f585439fa7abf61b26704881e98a168">serialize</a> (const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;u)</td></tr>
<tr class="memdesc:a1f585439fa7abf61b26704881e98a168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize univariate PDF to raw memory stream.  <a href="#a1f585439fa7abf61b26704881e98a168">More...</a><br /></td></tr>
<tr class="separator:a1f585439fa7abf61b26704881e98a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24204b4ddfb41147330f02a8e6e7b760"><td class="memItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a24204b4ddfb41147330f02a8e6e7b760">mergeUniPDFs</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:a24204b4ddfb41147330f02a8e6e7b760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging a univariate PDF during reduction across PEs.  <a href="#a24204b4ddfb41147330f02a8e6e7b760">More...</a><br /></td></tr>
<tr class="separator:a24204b4ddfb41147330f02a8e6e7b760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95434266ed0be6503251e90e0fe60823"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a95434266ed0be6503251e90e0fe60823">serialize</a> (const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;u, const std::vector&lt; <a class="el" href="classtk_1_1_bi_p_d_f.html">tk::BiPDF</a> &gt; &amp;b, const std::vector&lt; <a class="el" href="classtk_1_1_tri_p_d_f.html">tk::TriPDF</a> &gt; &amp;t)</td></tr>
<tr class="memdesc:a95434266ed0be6503251e90e0fe60823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize vectors of PDFs to raw memory stream.  <a href="#a95434266ed0be6503251e90e0fe60823">More...</a><br /></td></tr>
<tr class="separator:a95434266ed0be6503251e90e0fe60823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8753a2df233c9b1327d5682940ddcbf"><td class="memItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab8753a2df233c9b1327d5682940ddcbf">mergePDF</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:ab8753a2df233c9b1327d5682940ddcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging PDFs during reduction across PEs.  <a href="#ab8753a2df233c9b1327d5682940ddcbf">More...</a><br /></td></tr>
<tr class="separator:ab8753a2df233c9b1327d5682940ddcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a63cccd84b6bd8b998cb4282adac23"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac0a63cccd84b6bd8b998cb4282adac23">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &amp;p)</td></tr>
<tr class="separator:ac0a63cccd84b6bd8b998cb4282adac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a78da814ef7132a0958c47f987e3e711c"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a78da814ef7132a0958c47f987e3e711c">UnkEqComp</a> = 0</td></tr>
<tr class="memdesc:a78da814ef7132a0958c47f987e3e711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for selecting data layout policies.  <a href="#a78da814ef7132a0958c47f987e3e711c">More...</a><br /></td></tr>
<tr class="separator:a78da814ef7132a0958c47f987e3e711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaf71501378c00aad4f847942cdef6d"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9aaf71501378c00aad4f847942cdef6d">EqCompUnk</a> = 1</td></tr>
<tr class="separator:a9aaf71501378c00aad4f847942cdef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca17aedbef10f63fdfdee06f57e29c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9ca17aedbef10f63fdfdee06f57e29c">CSTYLE_STRLEN</a> = 1024</td></tr>
<tr class="separator:af9ca17aedbef10f63fdfdee06f57e29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320fa5c795146f9a4ac4fc2eb4e2606"><td class="memItemLeft" align="right" valign="top">static CkReduction::reducerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1320fa5c795146f9a4ac4fc2eb4e2606">BCMapMerger</a></td></tr>
<tr class="separator:a1320fa5c795146f9a4ac4fc2eb4e2606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac7c57927d6134e6563817f5d005a0"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::array&lt; std::size_t, 3 &gt;, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">lpofa</a> {{ {{1,2,3}}, {{2,0,3}}, {{3,0,1}}, {{0,2,1}} }}</td></tr>
<tr class="separator:a30ac7c57927d6134e6563817f5d005a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Toolkit declarations and definitions for general purpose utilities. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a732b6aaa7f495f4b1f06dd4d1acee269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732b6aaa7f495f4b1f06dd4d1acee269">&#9670;&nbsp;</a></span>is_enum_class</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a732b6aaa7f495f4b1f06dd4d1acee269">tk::is_enum_class</a> = typedef typename boost::mpl::bool_&lt; std::is_enum&lt; T &gt;::value &amp;&amp; !std::is_convertible&lt; T, uint8_t &gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait querying whether T is a strongly typed enum. </p>

<p class="definition">Definition at line <a class="el" href="_charm_util_8h_source.html#l00020">20</a> of file <a class="el" href="_charm_util_8h_source.html">CharmUtil.h</a>.</p>

</div>
</div>
<a id="a9bf453dedb17140704a4e947d172bae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf453dedb17140704a4e947d172bae4">&#9670;&nbsp;</a></span>ncomp_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">tk::ncomp_t</a> = typedef kw::ncomp::info::expect::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_gradients_8h_source.html#l00022">22</a> of file <a class="el" href="_gradients_8h_source.html">Gradients.h</a>.</p>

</div>
</div>
<a id="a1a96ada94b7e2911ecca0a360f305575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a96ada94b7e2911ecca0a360f305575">&#9670;&nbsp;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real number type used throughout the whole code. </p>

<p class="definition">Definition at line <a class="el" href="_base_2_types_8h_source.html#l00016">16</a> of file <a class="el" href="_base_2_types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a74de56fa53c55c0a8f35b764729cdf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74de56fa53c55c0a8f35b764729cdf20">&#9670;&nbsp;</a></span>RNGFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20">tk::RNGFactory</a> = typedef std::map&lt; <a class="el" href="namespacetk_1_1ctr.html#aa1b0831f9e998d8133473f63480b3ecb">ctr::RNGType</a>, std::function&lt; <a class="el" href="classtk_1_1_r_n_g.html">RNG</a>() &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random number generator factory: keys associated to their constructors. </p>

<p class="definition">Definition at line <a class="el" href="_r_n_g_stack_8h_source.html#l00030">30</a> of file <a class="el" href="_r_n_g_stack_8h_source.html">RNGStack.h</a>.</p>

</div>
</div>
<a id="a40ff0a76887b93164712b9ce9192fdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff0a76887b93164712b9ce9192fdd2">&#9670;&nbsp;</a></span>SiloErrorHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tk::SiloErrorHandler) (char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Silo error handler function type. </p>

<p class="definition">Definition at line <a class="el" href="_silo_writer_8h_source.html#l00021">21</a> of file <a class="el" href="_silo_writer_8h_source.html">SiloWriter.h</a>.</p>

</div>
</div>
<a id="a4a3683fffc858642385d1292c3817021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3683fffc858642385d1292c3817021">&#9670;&nbsp;</a></span>Table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> = typedef std::vector&lt; std::pair&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for declaring, defining, and storing a discrete y = f(x) function. </p>

<p class="definition">Definition at line <a class="el" href="_table_8h_source.html#l00022">22</a> of file <a class="el" href="_table_8h_source.html">Table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afcc275d91d4368505f221061b9ba822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc275d91d4368505f221061b9ba822a">&#9670;&nbsp;</a></span>ErrCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">tk::ErrCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes for the OS (or whatever calls us) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3"></a>SUCCESS&#160;</td><td class="fielddoc"><p>Everything went fine. </p>
</td></tr>
<tr><td class="fieldname"><a id="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"></a>FAILURE&#160;</td><td class="fielddoc"><p>Exceptions occurred. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exception_8h_source.html#l00058">58</a> of file <a class="el" href="_exception_8h_source.html">Exception.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;             { <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a> = EXIT_SUCCESS, <span class="comment">//!&lt; Everything went fine</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"></span>               <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a> = EXIT_FAILURE  <span class="comment">//!&lt; Exceptions occurred</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"></span>};</div><div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::FAILURE</a></div><div class="ttdoc">Exceptions occurred. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00059">Exception.h:59</a></div></div>
<div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">tk::SUCCESS</a></div><div class="ttdoc">Everything went fine. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00058">Exception.h:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3781b50ef71ead8dd0bd286455c6030c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3781b50ef71ead8dd0bd286455c6030c">&#9670;&nbsp;</a></span>ExoElemType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">tk::ExoElemType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported ExodusII mesh cell types. </p>
<p>This the order in which <a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html#afa985f1ff7efafc404505766657d3854">ExodusIIMeshReader::m_eid</a> stores the element block IDs. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html#afe8144814a95bbb94d87e04091042918" title="Read element block IDs from file. ">ExodusIIMeshReader::readElemBlockIDs()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exodus_i_i_mesh_reader_8h_source.html#l00032">32</a> of file <a class="el" href="_exodus_i_i_mesh_reader_8h_source.html">ExodusIIMeshReader.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;: <span class="keywordtype">int</span> { <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 0, <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 1 };</div><div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">tk::TET</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00017">GmshMeshIO.h:17</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">tk::TRI</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00016">GmshMeshIO.h:16</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea4fb4c5b5f9f99675ec2f39d25a3482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4fb4c5b5f9f99675ec2f39d25a3482">&#9670;&nbsp;</a></span>ExoWriter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">tk::ExoWriter</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ExodusII writer constructor modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d"></a>CREATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3"></a>OPEN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html#l00023">23</a> of file <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html">ExodusIIMeshWriter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{ <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">CREATE</a>, <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">OPEN</a> };</div><div class="ttc" id="namespacetk_html_aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3"><div class="ttname"><a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">tk::ExoWriter::OPEN</a></div></div>
<div class="ttc" id="namespacetk_html_aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d"><div class="ttname"><a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">tk::ExoWriter::CREATE</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a85016961456a798f65e4e5a451e44242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85016961456a798f65e4e5a451e44242">&#9670;&nbsp;</a></span>GmshElemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">tk::GmshElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifiers of supported Gmsh elements. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d"></a>LIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125"></a>PNT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00015">15</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                  { <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> = 1,</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 2,</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 4,</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> = 15 };</div><div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">tk::TET</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00017">GmshMeshIO.h:17</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">tk::PNT</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00018">GmshMeshIO.h:18</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">tk::LIN</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00015">GmshMeshIO.h:15</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">tk::TRI</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00016">GmshMeshIO.h:16</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af910e1a2aff3119022dea29cf3d898c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af910e1a2aff3119022dea29cf3d898c1">&#9670;&nbsp;</a></span>GmshFileType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">tk::GmshFileType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported Gmsh mesh file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3"></a>UNDEFINED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc"></a>ASCII&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452"></a>BINARY&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00021">21</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                        { <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a> = -1,</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">ASCII</a> = 0,</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">BINARY</a> = 1 };</div><div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">tk::GmshFileType::ASCII</a></div></div>
<div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">tk::GmshFileType::BINARY</a></div></div>
<div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">tk::GmshFileType::UNDEFINED</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3032aaeb67d38d01181590cd7f0acc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3032aaeb67d38d01181590cd7f0acc7d">&#9670;&nbsp;</a></span>HeaderType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">tk::HeaderType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd"></a>INCITER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928"></a>RNGTEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247"></a>UNITTEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35"></a>MESHCONV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a"></a>FILECONV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa"></a>WALKER&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00028">28</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">INCITER</a>=0,</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">RNGTEST</a>,</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">UNITTEST</a>,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">MESHCONV</a>,</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a">FILECONV</a>,</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">WALKER</a> };</div><div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a">tk::HeaderType::FILECONV</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">tk::HeaderType::RNGTEST</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">tk::HeaderType::MESHCONV</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">tk::HeaderType::INCITER</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">tk::HeaderType::WALKER</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">tk::HeaderType::UNITTEST</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a748833535365d6e320da5fcb7d213c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748833535365d6e320da5fcb7d213c30">&#9670;&nbsp;</a></span>MeshReader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">tk::MeshReader</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported mesh readers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"></a>GMSH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"></a>NETGEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339"></a>EXODUSII&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade"></a>HYPER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c"></a>ASC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00022">22</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>=0,</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>,</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                                  <a class="code" href="namespacetk_1_1ctr.html#a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>,</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade">HYPER</a>,</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c">ASC</a> };</div><div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">tk::MeshReader::GMSH</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c">tk::MeshReader::ASC</a></div></div>
<div class="ttc" id="namespacetk_1_1ctr_html_a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339"><div class="ttname"><a href="namespacetk_1_1ctr.html#a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339">tk::ctr::FieldFileType::EXODUSII</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade">tk::MeshReader::HYPER</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">tk::MeshReader::NETGEN</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a43d2f365ad601e02c8d64479adfd4a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d2f365ad601e02c8d64479adfd4a7f">&#9670;&nbsp;</a></span>MeshWriter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">tk::MeshWriter</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported mesh writers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fad8e85cdb6ef83caac7fa35c22dda2153"></a>GMSH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fa8d2dc7a7e41c392a0da416ec0626e676"></a>NETGEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fa834c8a77b335ad1c7bb2b632b6857339"></a>EXODUSII&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00029">29</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>=0,</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                  <a class="code" href="namespacetk_1_1ctr.html#a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a> };</div><div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">tk::MeshReader::GMSH</a></div></div>
<div class="ttc" id="namespacetk_1_1ctr_html_a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339"><div class="ttname"><a href="namespacetk_1_1ctr.html#a9a625f1b79ce9e1a6b2c97f59956065ca834c8a77b335ad1c7bb2b632b6857339">tk::ctr::FieldFileType::EXODUSII</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">tk::MeshReader::NETGEN</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d172b64b84ff0554f0e87475f4541b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d172b64b84ff0554f0e87475f4541b4">&#9670;&nbsp;</a></span>Style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">tk::Style</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output verbosity. C-style enum as this is used for template argument. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e"></a>QUIET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2"></a>VERBOSE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_print_8h_source.html#l00031">31</a> of file <a class="el" href="_print_8h_source.html">Print.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{ <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a>=0, <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a>=1 };</div><div class="ttc" id="namespacetk_html_a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2"><div class="ttname"><a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">tk::VERBOSE</a></div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00031">Print.h:31</a></div></div>
<div class="ttc" id="namespacetk_html_a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e"><div class="ttname"><a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">tk::QUIET</a></div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00031">Print.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb19d7c5f6c7354614bb457d6b17afde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb19d7c5f6c7354614bb457d6b17afde">&#9670;&nbsp;</a></span>assignLid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::size_t, std::size_t &gt; tk::assignLid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>gid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign local ids to global ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gid</td><td>Global ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map associating global ids to local ids </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00147">147</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_discretization_8_c_source.html#l00038">inciter::Discretization::Discretization()</a>, and <a class="el" href="_reorder_8_c_source.html#l00163">global2local()</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  std::unordered_map&lt; std::size_t, std::size_t &gt; lid;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  std::size_t l = 0;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : gid) lid[p] = l++;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="keywordflow">return</span> lid;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2e002561a68875b091a264eb2a1e5f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e002561a68875b091a264eb2a1e5f6c">&#9670;&nbsp;</a></span>cref_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::cref_find </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Container::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; const typename Container::mapped_type&amp;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00037">37</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_discretization_8_c_source.html#l00364">inciter::Discretization::addEdgeNodeCoords()</a>, <a class="el" href="_d_g_8_c_source.html#l00550">inciter::DG::addGeoFace()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00139">inciter::DistFCT::aec()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00214">inciter::DistFCT::alw()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00389">inciter::DistFCT::apply()</a>, <a class="el" href="_test_timer_8h_source.html#l00155">tut::CharmTimer::CharmTimer()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00182">inciter::DistFCT::comaec()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00258">inciter::DistFCT::comalw()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00333">inciter::DiagCG::comdif()</a>, <a class="el" href="_d_g_8_c_source.html#l00462">inciter::DG::comGhost()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00191">inciter::DiagCG::comlhs()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00330">inciter::DistFCT::comlim()</a>, <a class="el" href="_partitioner_8_c_source.html#l00528">inciter::Partitioner::computeCentroids()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00301">inciter::DiagCG::comrhs()</a>, <a class="el" href="_d_g_8_c_source.html#l00751">inciter::DG::comsol()</a>, <a class="el" href="_discretization_8_c_source.html#l00216">inciter::Discretization::comvol()</a>, <a class="el" href="_partitioner_8_c_source.html#l01267">inciter::Partitioner::createDiscWorkers()</a>, <a class="el" href="_partitioner_8_c_source.html#l01311">inciter::Partitioner::createWorkers()</a>, <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>, <a class="el" href="_derived_data_8_c_source.html#l00822">genNbfacTet()</a>, <a class="el" href="_reorder_8_c_source.html#l00163">global2local()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00168">inciter::DiagCG::lhs()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00294">inciter::DistFCT::lim()</a>, <a class="el" href="_node_diagnostics_8_c_source.html#l00029">inciter::NodeDiagnostics::NodeDiagnostics()</a>, <a class="el" href="_transporter_8_c_source.html#l00351">inciter::Transporter::partition()</a>, <a class="el" href="_partitioner_8_c_source.html#l00769">inciter::Partitioner::prepare()</a>, <a class="el" href="_partitioner_8_c_source.html#l00405">inciter::Partitioner::query()</a>, <a class="el" href="_discretization_8_c_source.html#l00337">inciter::Discretization::readCoords()</a>, <a class="el" href="_container_util_8h_source.html#l00053">ref_find()</a>, <a class="el" href="_partitioner_8_c_source.html#l01049">inciter::Partitioner::reordered()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00260">inciter::DiagCG::rhs()</a>, <a class="el" href="_boundary_conditions_8_c_source.html#l00037">inciter::BoundaryConditions::sideNodes()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00378">inciter::DiagCG::solve()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00143">inciter::DiagCG::start()</a>, <a class="el" href="_discretization_8_c_source.html#l00244">inciter::Discretization::totalvol()</a>, <a class="el" href="_mat_c_g_8_c_source.html#l00236">inciter::MatCG::updateLowSol()</a>, <a class="el" href="_mat_c_g_8_c_source.html#l00269">inciter::MatCG::updateSol()</a>, <a class="el" href="_solver_8_c_source.html#l00993">tk::Solver::updateSol()</a>, and <a class="el" href="_discretization_8_c_source.html#l00159">inciter::Discretization::vol()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> it = map.find( key );</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="keywordflow">if</span> (it != end(map)) <span class="keywordflow">return</span> it-&gt;second; <span class="keywordflow">else</span> <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Can&#39;t find key&quot;</span> );</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab602857e33f89cab4cc3788576ab1519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab602857e33f89cab4cc3788576ab1519">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; tk::cross </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cross-product of two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross-product </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00018">18</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_base_2_vector_8h_source.html#l00062">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keywordflow">return</span> {{ v1[1]*v2[2] - v2[1]*v1[2],</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;            v1[2]*v2[0] - v2[2]*v1[0],</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            v1[0]*v2[1] - v2[0]*v1[1] }};</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a77ef9600b5075a8bbee89b6e4991fd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef9600b5075a8bbee89b6e4991fd69">&#9670;&nbsp;</a></span>crossdiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; tk::crossdiv </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cross-product of two vectors divided by a scalar </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Scalar to divide each component by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross-product divided by scalar </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00033">33</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_gradients_8_c_source.html#l00094">edgegrad()</a>, <a class="el" href="_gradients_8_c_source.html#l00018">nodegrad()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00160">inciter::cg::CompFlow&lt; Physics, Problem &gt;::rhs()</a>, and <a class="el" href="_c_g_transport_8h_source.html#l00167">inciter::cg::Transport&lt; Physics, Problem &gt;::rhs()</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;{</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">return</span> {{ (v1[1]*v2[2] - v2[1]*v1[2]) / j,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            (v1[2]*v2[0] - v2[2]*v1[0]) / j,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            (v1[0]*v2[1] - v2[0]*v1[1]) / j }};</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a69ebefad09fa900014b6271b30e8bd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ebefad09fa900014b6271b30e8bd5f">&#9670;&nbsp;</a></span>curtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tk::curtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for the standard C library's gettimeofday() from. </p>
<dl class="section return"><dt>Returns</dt><dd>A stirng containing the current date and time </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00050">50</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00131">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  time_t current_time;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordtype">char</span>* c_time_string;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// Obtain current time as seconds elapsed since the Epoch</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  current_time = time( <span class="keyword">nullptr</span> );</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">if</span> (current_time == static_cast&lt;time_t&gt;(-1))</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Failure to compute the current time&quot;</span> );</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="comment">// Convert to local time format</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  c_time_string = ctime(&amp;current_time);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keywordflow">if</span> (c_time_string == <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Failure to convert the current time&quot;</span> );</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="comment">// Convert to std::string and remove trailing newline</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  std::string str( c_time_string );</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  str.erase( std::remove(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>), str.end() );</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">return</span> str;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9140b408dcbd2eaef58f9c3a54fa104a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9140b408dcbd2eaef58f9c3a54fa104a">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::destroy </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free memory of a container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Container defining a swap() member function</td></tr>
  </table>
  </dd>
</dl>
<p>See <a href="http://stackoverflow.com/a/10465032">http://stackoverflow.com/a/10465032</a> as to why this is done with the swap() member function of the container. </p><dl class="section see"><dt>See also</dt><dd>Specializations of std::swap are documented at <a href="http://en.cppreference.com/w/cpp/algorithm/swap">http://en.cppreference.com/w/cpp/algorithm/swap</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00168">168</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_d_g_8_c_source.html#l00577">inciter::DG::adj()</a>, <a class="el" href="_d_g_8_c_source.html#l00251">inciter::DG::comfac()</a>, <a class="el" href="_partitioner_8_c_source.html#l00363">inciter::Partitioner::cost()</a>, <a class="el" href="_partitioner_8_c_source.html#l01267">inciter::Partitioner::createDiscWorkers()</a>, <a class="el" href="_partitioner_8_c_source.html#l01311">inciter::Partitioner::createWorkers()</a>, <a class="el" href="_partitioner_8_c_source.html#l00805">inciter::Partitioner::generate_compact_inpoel()</a>, <a class="el" href="_partitioner_8_c_source.html#l00439">inciter::Partitioner::mask()</a>, <a class="el" href="_partitioner_8_c_source.html#l00125">inciter::Partitioner::partition()</a>, <a class="el" href="_partitioner_8_c_source.html#l00769">inciter::Partitioner::prepare()</a>, <a class="el" href="_partitioner_8_c_source.html#l01049">inciter::Partitioner::reordered()</a>, and <a class="el" href="_d_g_8_c_source.html#l00647">inciter::DG::setup()</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                             {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="keyword">typename</span> std::remove_reference&lt; decltype(c) &gt;::type().swap( c );</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a08e7ddf794b944c7d2095c1222f4244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e7ddf794b944c7d2095c1222f4244a">&#9670;&nbsp;</a></span>detectInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a> tk::detectInput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect input mesh file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File to open and detect its type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum specifying the mesh reader type </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00031">31</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c">ASC</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade">HYPER</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="namespacetut.html#aa3d137634e947af278a47517d75b6167">tut::Reader()</a>, and <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00092">readUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="comment">// Get first three letters from input file</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  std::string s( <a class="code" href="namespacetut.html#aa3d137634e947af278a47517d75b6167">Reader</a>( filename ).firstline().substr(0,4) );</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;$Me&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">return</span> MeshReader::GMSH;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;CDF&quot;</span>) != std::string::npos ||</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;              s.find(<span class="stringliteral">&quot;HDF&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">return</span> MeshReader::EXODUSII;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;&lt;?x&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> MeshReader::HYPER;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;*nd&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> MeshReader::ASC;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      std::stoi(s);    <span class="comment">// try to convert to an integer</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    } <span class="keywordflow">catch</span> ( std::invalid_argument ) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Input mesh file type could not be determined from header: &quot;</span> +</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;             filename );</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="comment">// could also catch std::out_of_range, the other exception potentially</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// thrown by std::stoi(), but a three-digit integer will always fit into int</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="comment">// if we got here, the above string-to-integer conversion succeeded</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> MeshReader::NETGEN;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
<div class="ttc" id="namespacetut_html_aa3d137634e947af278a47517d75b6167"><div class="ttname"><a href="namespacetut.html#aa3d137634e947af278a47517d75b6167">tut::Reader</a></div><div class="ttdeci">static Reader_group Reader(&quot;Base/Reader&quot;)</div><div class="ttdoc">Define test group. </div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a08e7ddf794b944c7d2095c1222f4244a_cgraph.svg" width="267" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aeaca2df70ee950c576f6d74e1eb42caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaca2df70ee950c576f6d74e1eb42caa">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tk::dot </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the dot-product of two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot-product </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00049">49</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_error_8_c_source.html#l00076">AMR::Error::error_hessian()</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00062">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">return</span> v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab72923dba604ccbf4233af3ccafc70b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72923dba604ccbf4233af3ccafc70b3">&#9670;&nbsp;</a></span>echoBuildEnv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoBuildEnv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo build environment. </p>
<p>Echo information read from &lt;build&gt;/Base/Config.h filled by CMake based on src/Main/Config.h.in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00101">101</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_print_8h_source.html#l00179">tk::Print::item()</a>, and <a class="el" href="_print_8h_source.html#l00137">tk::Print::section()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00179">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;{</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  print.section( <span class="stringliteral">&quot;Build environment&quot;</span> );</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  print.item( <span class="stringliteral">&quot;Hostname&quot;</span>, BUILD_HOSTNAME );</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  print.item( <span class="stringliteral">&quot;Executable&quot;</span>, executable );</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  print.item( <span class="stringliteral">&quot;Version&quot;</span>, QUINOA_VERSION );</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keywordflow">if</span> (std::string(GIT_COMMIT).find(<span class="stringliteral">&quot;NOTFOUND&quot;</span>) == std::string::npos)</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    print.item( <span class="stringliteral">&quot;Revision SHA1&quot;</span>, GIT_COMMIT );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  print.item( <span class="stringliteral">&quot;CMake build type&quot;</span>, BUILD_TYPE );</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">#ifdef NDEBUG</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  print.item( <span class="stringliteral">&quot;MPI C++ wrapper&quot;</span>, MPI_COMPILER );</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  print.item( <span class="stringliteral">&quot;Underlying C++ compiler&quot;</span>, COMPILER );</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  print.item( <span class="stringliteral">&quot;Build date&quot;</span>, BUILD_DATE );</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab72923dba604ccbf4233af3ccafc70b3_cgraph.svg" width="310" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afbbf10b984ba3f66b55cc8363c6a2341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf10b984ba3f66b55cc8363c6a2341">&#9670;&nbsp;</a></span>echoHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo program header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which header to print </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00078">78</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a">FILECONV</a>, <a class="el" href="_print_8h_source.html#l00567">tk::Print::headerFileConv()</a>, <a class="el" href="_print_8h_source.html#l00473">tk::Print::headerInciter()</a>, <a class="el" href="_print_8h_source.html#l00598">tk::Print::headerMeshConv()</a>, <a class="el" href="_print_8h_source.html#l00504">tk::Print::headerRNGTest()</a>, <a class="el" href="_print_8h_source.html#l00535">tk::Print::headerUnitTest()</a>, <a class="el" href="_print_8h_source.html#l00629">tk::Print::headerWalker()</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">INCITER</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">MESHCONV</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">RNGTEST</a>, <a class="el" href="_exception_8h_source.html#l00031">Throw</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">UNITTEST</a>, and <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">WALKER</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00179">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;{</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keywordflow">if</span> ( header == HeaderType::INCITER )</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    print.headerInciter();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::RNGTEST )</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    print.headerRNGTest();</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::UNITTEST )</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    print.headerUnitTest();</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::MESHCONV )</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    print.headerMeshConv();</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::WALKER )</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    print.headerWalker();</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::FILECONV )</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    print.headerFileConv();</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Header not available&quot;</span> );</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_afbbf10b984ba3f66b55cc8363c6a2341_cgraph.svg" width="366" height="282"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a991ea7a4015fef3262bdb056f840bf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991ea7a4015fef3262bdb056f840bf82">&#9670;&nbsp;</a></span>echoRunEnv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoRunEnv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo runtime environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>True for verbose screen-output </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00131">131</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_init_8h_source.html#l00050">curtime()</a>, <a class="el" href="_print_8h_source.html#l00179">tk::Print::item()</a>, <a class="el" href="_print_8h_source.html#l00137">tk::Print::section()</a>, and <a class="el" href="_init_8h_source.html#l00036">workdir()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00179">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;{</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  print.section( <span class="stringliteral">&quot;Run-time environment&quot;</span> );</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  print.item( <span class="stringliteral">&quot;Date, time&quot;</span>, <a class="code" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">curtime</a>() );</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  print.item( <span class="stringliteral">&quot;Work directory&quot;</span>, <a class="code" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">workdir</a>() );</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  print.item( <span class="stringliteral">&quot;Executable (rel. to work dir)&quot;</span>, argv[0] );</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  print.item(<span class="stringliteral">&quot;Command line arguments&quot;</span> );</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  print &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="keywordflow">if</span> (argc&gt;1) {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=1; i&lt;argc-1; ++i) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      print &lt;&lt; std::string( argv[i] ) + <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    }</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    print &lt;&lt; std::string( argv[argc-1] );</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  print &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  print.item( <span class="stringliteral">&quot;Output&quot;</span>, verbose ? <span class="stringliteral">&quot;verbose (quiet: omit -v)&quot;</span> : <span class="stringliteral">&quot;quiet&quot;</span> );</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8e567fa9a72a1d5d02cea9eb020b192a"><div class="ttname"><a href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">tk::workdir</a></div><div class="ttdeci">static std::string workdir()</div><div class="ttdoc">Wrapper for POSIX API&amp;#39;s getcwd() from unistd.h. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00036">Init.h:36</a></div></div>
<div class="ttc" id="namespacetk_html_a69ebefad09fa900014b6271b30e8bd5f"><div class="ttname"><a href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">tk::curtime</a></div><div class="ttdeci">static std::string curtime()</div><div class="ttdoc">Wrapper for the standard C library&amp;#39;s gettimeofday() from. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00050">Init.h:50</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a991ea7a4015fef3262bdb056f840bf82_cgraph.svg" width="304" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8deceeef86846672dd872bb7e975bb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8deceeef86846672dd872bb7e975bb13">&#9670;&nbsp;</a></span>edgegrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; tk::edgegrad </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esued</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tk::Fields &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">ncomp_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient at a mesh edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeEdge</td><td>id at which to compute gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Mesh node coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Mesh element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esued</td><td>Linked lists storing elements surrounding edges, see <a class="el" href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924" title="Generate derived data structure, elements surrounding edges. ">tk::genEsued()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>Field vector whose component gradient to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Scalar component to compute gradient of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gradient of U(c) at mesh edge </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gradients_8_c_source.html#l00094">94</a> of file <a class="el" href="_gradients_8_c_source.html">Gradients.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_base_2_vector_8h_source.html#l00033">crossdiv()</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00062">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;{</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( c &lt; U.nprop(), <span class="stringliteral">&quot;Indexing out of field data&quot;</span> );</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = coord[0];</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; y = coord[1];</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; z = coord[2];</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// storage for gradient and volume at the mesh edge</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  std::array&lt; tk::real, 3 &gt; g{{ 0.0, 0.0, 0.0 }};</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> vol = 0.0;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="comment">// loop over cells surrounding mesh edge</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> k=esued.second[edge]+1; k&lt;=esued.second[edge+1]; ++k) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;     <span class="comment">// access element id</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;     <span class="keyword">auto</span> e = esued.first[k];</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;     <span class="comment">// access node IDs</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;     <span class="keyword">const</span> std::array&lt; std::size_t, 4 &gt; N{{ inpoel[e*4+0], inpoel[e*4+1],</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                            inpoel[e*4+2], inpoel[e*4+3] }};</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;     <span class="comment">// compute element Jacobi determinant</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;     <span class="keyword">const</span> std::array&lt; tk::real, 3 &gt;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;       ba{{ x[N[1]]-x[N[0]], y[N[1]]-y[N[0]], z[N[1]]-z[N[0]] }},</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;       ca{{ x[N[2]]-x[N[0]], y[N[2]]-y[N[0]], z[N[2]]-z[N[0]] }},</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;       da{{ x[N[3]]-x[N[0]], y[N[3]]-y[N[0]], z[N[3]]-z[N[0]] }};</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;     <span class="keyword">const</span> <span class="keyword">auto</span> J = <a class="code" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a>( ba, ca, da );        <span class="comment">// J = 6V</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;     <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( J &gt; 0, <span class="stringliteral">&quot;Element Jacobian non-positive&quot;</span> );</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;     <span class="comment">// shape function derivatives, nnode*ndim [4][3]</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;     std::array&lt; std::array&lt; tk::real, 3 &gt;, 4 &gt; grad;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;     grad[1] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( ca, da, J );</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;     grad[2] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( da, ba, J );</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;     grad[3] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( ba, ca, J );</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;     <span class="keywordflow">for</span> (std::size_t i=0; i&lt;3; ++i)</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;       grad[0][i] = -grad[1][i]-grad[2][i]-grad[3][i];</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;     <span class="comment">// access field data for scalar component c at nodes of element</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;     <span class="keyword">auto</span> u = U.extract( c, 0, N );</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;     <span class="comment">// compute edge volume: every element contributes their volume / 6</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;     vol += J/36.0;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;     <span class="comment">// compute gradient over element weighed by cell volume / 6 and sum to edge</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;     <span class="keywordflow">for</span> (std::size_t j=0; j&lt;3; ++j) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;       <span class="keywordflow">for</span> (std::size_t i=0; i&lt;4; ++i) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;         g[j] += grad[i][j] * u[i] * J/36.0;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;       }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;     }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;   }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;   <span class="comment">// divide components of gradient by edge volume</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;   <span class="keywordflow">for</span> (std::size_t j=0; j&lt;3; ++j) g[j] /= vol;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;   <span class="keywordflow">return</span> g;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;}</div><div class="ttc" id="namespacetk_html_a77ef9600b5075a8bbee89b6e4991fd69"><div class="ttname"><a href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a></div><div class="ttdeci">std::array&lt; T, 3 &gt; crossdiv(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00033">Vector.h:33</a></div></div>
<div class="ttc" id="namespacetk_html_ae5b04b00aa51667b944b7188545ec5ae"><div class="ttname"><a href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a></div><div class="ttdeci">T triple(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00062">Vector.h:62</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a8deceeef86846672dd872bb7e975bb13_cgraph.svg" width="382" height="108"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5983201a427244339722ca9a4e809f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5983201a427244339722ca9a4e809f48">&#9670;&nbsp;</a></span>elemCommMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; tk::elemCommMaps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute element-based communication maps. </p>
<p>Compute element-based communication maps </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Global mesh element ids owned by each chare distributed to PEs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-based communication map for all chares</dd></dl>
<p>This is an <em>element-based</em> export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns an element the mesh point is a vertex of. This is for algorithms that work by computing data on the mesh by looping over mesh elements, e.g., element-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p><dl class="section note"><dt>Note</dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_comm_map_8_c_source.html#l00128">128</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>

<p class="reference">References <a class="el" href="_base_2_variant_8h_source.html#l00130">element()</a>.</p>
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;{</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="comment">// unique global point ids sent (export map)</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  std::map&lt; std::size_t,</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// Construct element-based export maps</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pel : element)</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">for</span> (std::size_t c=0; c&lt;pel.size(); ++c)</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : pel[c])</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="keywordflow">for</span> (std::size_t n=0; n&lt;4; ++n) {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;          <span class="keyword">auto</span> p = tetinpoel[e*4+n];</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;          <span class="keywordflow">if</span> (chp[p] != c)      <span class="comment">// if the point-colors differ, store global id</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            comm[ c ][ chp[p] ].insert( p );</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">//   for (const auto&amp; c : comm) {</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">//     std::cout &lt;&lt; c.first &lt;&lt; &quot; -&gt; &quot;;</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">//     for (const auto&amp; t : c.second) {</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">//       std::cout &lt;&lt; t.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">//       for (auto p : t.second)</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">//       std::cout &lt;&lt; &quot;, &quot;;</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">//   std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="comment">// Construct final product: a vector of export maps associating receiver</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    ecomm( nchare );</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        ecomm[ e.first ][ x.first ].push_back( p );</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">//   std::size_t h = 0;</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">//   for (const auto&amp; m : ecomm) {</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; e-&gt; &quot;;</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">//     for (const auto&amp; x : m) {</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">//       for (auto p : x.second)</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  <span class="keywordflow">return</span> ecomm;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5983201a427244339722ca9a4e809f48_cgraph.svg" width="296" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a928d7dd976738fc1e3de5f4ee6147140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d7dd976738fc1e3de5f4ee6147140">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProxyElem , class Proxy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ProxyElem tk::element </td>
          <td>(</td>
          <td class="paramtype">const Proxy &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CkArrayIndex1D &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function dereferencing operator[] of chare proxy inside variant </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proxy</td><td>Chare array proxy inside a variant to dereference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Chare array element index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chare array element proxy as a variant, defined by ProxyElem</dd></dl>
<p>The returning element proxy is a variant, depending on the input proxy. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classinciter_1_1_scheme.html">inciter::Scheme</a>, <a class="el" href="classinciter_1_1_scheme_base.html">inciter::SchemeBase</a>, or, e.g., DistFCT::apply() for client code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_variant_8h_source.html#l00130">130</a> of file <a class="el" href="_base_2_variant_8h_source.html">Variant.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__adapter_8_c_source.html#l00565">AMR::mesh_adapter_t::check_valid_refinement_case()</a>, <a class="el" href="_comm_map_8_c_source.html#l00128">elemCommMaps()</a>, <a class="el" href="mesh__adapter_8_c_source.html#l00240">AMR::mesh_adapter_t::perform_refinement()</a>, <a class="el" href="mesh__adapter_8_c_source.html#l00647">AMR::mesh_adapter_t::refinement_class_three()</a>, and <a class="el" href="refinement_8h_source.html#l00469">AMR::refinement_t::tet_id_to_node_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                                 {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordflow">return</span> boost::apply_visitor( Idx&lt;ProxyElem&gt;(x), proxy );</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af0de4157a7818da7a9deb1476099bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0de4157a7818da7a9deb1476099bd8d">&#9670;&nbsp;</a></span>extents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 2 &gt; tk::extents </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return minimum and maximum values of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Vector whose extents to compute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of two values with the minimum and maximum values </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should not be called with heavy T types, as the a copy of a std::array&lt; T, 2 &gt; is created and returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00069">69</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keyword">auto</span> x = std::minmax_element( begin(vec), end(vec) );</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordflow">return</span> {{ *x.first, *x.second }};</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1930c11b6d90076b9d17c9f9c9d49efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1930c11b6d90076b9d17c9f9c9d49efe">&#9670;&nbsp;</a></span>extents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::extents </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> -&gt; std::array&lt; typename Container::mapped_type, 2 &gt;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00083">83</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keyword">using</span> pair_type = <span class="keyword">typename</span> Container::value_type;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keyword">auto</span> x = std::minmax_element( begin(map), end(map),</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;             []( <span class="keyword">const</span> pair_type&amp; a, <span class="keyword">const</span> pair_type&amp; b )</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;             { <span class="keywordflow">return</span> a.second &lt; b.second; } );</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">return</span> {{ x.first-&gt;second, x.second-&gt;second }};</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a42982d289f8edfffa60fa4da8b7b9fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42982d289f8edfffa60fa4da8b7b9fdf">&#9670;&nbsp;</a></span>flip_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt; B, A &gt; tk::flip_map </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip a std::map of arbitrary types, yielding a std::multimap sorted by std::map::value_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>std::map of arbitrary key and value pairs of types A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::multimap of arbitrary key and value pairs of types B and A </dd></dl>

<p class="definition">Definition at line <a class="el" href="_flip__map_8h_source.html#l00027">27</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_r_n_g_test_print_8h_source.html#l00201">rngtest::RNGTestPrint::cost()</a>, and <a class="el" href="_r_n_g_test_print_8h_source.html#l00222">rngtest::RNGTestPrint::rank()</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                                          {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  std::multimap&lt; B, A &gt; dst;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  std::transform( src.begin(), src.end(), std::inserter(dst, dst.begin()), </div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                  flip_pair&lt; A ,B &gt; );</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keywordflow">return</span> dst;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac2323b3c43edbcc32d55d91100ffc3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2323b3c43edbcc32d55d91100ffc3a6">&#9670;&nbsp;</a></span>flip_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; B, A &gt; tk::flip_pair </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip a std::pair of arbitrary types </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>std::pair of arbitrary types, A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair of arbitrary types, B and A </dd></dl>

<p class="definition">Definition at line <a class="el" href="_flip__map_8h_source.html#l00019">19</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;{ <span class="keywordflow">return</span> std::pair&lt; B, A &gt;( p.second, p.first ); }</div></div><!-- fragment -->
</div>
</div>
<a id="ad69e35d3f9e7f2237c0c5c3b9c5c0888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888">&#9670;&nbsp;</a></span>genBelemTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genBelemTet </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nbfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpofa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, host/boundary element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nbfac</td><td>Number of boundary faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpofa</td><td>Face-node connectivity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Host elements or boundary elements. The unsigned integer vector gives the elements to the left of each boundary face in the mesh. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01224">1224</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>.</p>
<div class="fragment"><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;{</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;  std::vector&lt; std::size_t &gt; belem(nbfac);</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;  <span class="keywordflow">if</span> (nbfac &gt; 0)</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;  {</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;  <span class="comment">// set tetrahedron geometry</span></div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;  std::size_t nnpf(3), <a class="code" href="namespacetag.html">tag</a>(0);</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;  <span class="comment">// loop over all the boundary faces</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;  <span class="keywordflow">for</span>(std::size_t f=0; f&lt;nbfac; ++f)</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;  {</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    belem[f] = 0;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    <span class="comment">// array storing the element-cluster around face</span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    std::vector&lt; std::size_t &gt; elemcluster;</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    <span class="comment">// loop over the nodes of this boundary face</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    <span class="keywordflow">for</span>(std::size_t lp=0; lp&lt;nnpf; ++lp)</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    {</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;      <span class="keyword">auto</span> gp = inpofa[nnpf*f + lp];</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;      <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( gp &lt; esup.second.size(), <span class="stringliteral">&quot;Indexing out of esup2&quot;</span> );</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;      <span class="comment">// loop over elements surrounding this node</span></div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup.second[gp]+1; i&lt;=esup.second[gp+1]; ++i)</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;      {</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;        <span class="comment">// form element-cluster vector</span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;        elemcluster.push_back(esup.first[i]);</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;      }</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;    }</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    <span class="comment">// loop over element cluster to find repeating elements</span></div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <span class="keywordflow">for</span>(std::size_t i=0; i&lt;elemcluster.size(); ++i)</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    {</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;      <span class="keyword">auto</span> ge = elemcluster[i];</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;      <a class="code" href="namespacetag.html">tag</a> = 1;</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;      <span class="keywordflow">for</span>(std::size_t j=0; j&lt;elemcluster.size(); ++j)</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;      {</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;        <span class="keywordflow">if</span> ( i != j &amp;&amp; elemcluster[j] == ge )</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;        {</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;          <a class="code" href="namespacetag.html">tag</a>++;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;        }</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;      }</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="namespacetag.html">tag</a> == nnpf)</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;      {</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;        <span class="comment">// this is the required boundary element</span></div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;        belem[f] = ge;</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;      }</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;    }</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;  }</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;  }</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;  <span class="keywordflow">return</span> belem;</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;}</div><div class="ttc" id="namespacetag_html"><div class="ttname"><a href="namespacetag.html">tag</a></div><div class="ttdoc">Tags used as unique-type labels for compile-time code-generation. </div><div class="ttdef"><b>Definition:</b> <a href="_tags_8h_source.html#l00013">Tags.h:13</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adb7a88611b67f7c809f2bba5c794df0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a88611b67f7c809f2bba5c794df0b">&#9670;&nbsp;</a></span>genEdsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEdsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edges surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing edges (point ids p &lt; q) emanating from points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>edsup1</em> and <em>edsup2</em>, where <em>edsup2</em> holds the indices at which <em>edsup1</em> holds the edge-end point ids emanating from points for all points. The generated data structure, linked lists edsup1 and edsup2, are very similar to psup1 and psup2, generated by <a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points. ">genPsup()</a>, except here only unique edges are stored, i.e., for edges with point ids p &lt; q, only ids q are stored that are still associated to point p. Looping over all unique edges can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup.second[p]+1; i&lt;=edsup.second[p+1]; ++i)</div><div class="line">    <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> edge with point ids p &lt; edsup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity. ">tk::genInpoed</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00219">219</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>
<div class="fragment"><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;{</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() on empty container&quot;</span> );</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEdsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEdsup() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup1&quot;</span> );</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup2&quot;</span> );</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back(q);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="comment">// linked lists (vectors) to store edges surrounding points and their indices</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  std::vector&lt; std::size_t &gt; edsup1( 1, 0 ), edsup2( 1, 0 );</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  <span class="comment">// sort non-center points of each star and store nodes and indices in vectors</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    edsup2.push_back( edsup2.back() + p.second.size() );</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) edsup1.push_back( e );</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// fill up index array with the last index for points with no new edges</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;npoin-star.size(); ++i)</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    edsup2.push_back( edsup2.back() );</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(edsup1), std::move(edsup2) );</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_adb7a88611b67f7c809f2bba5c794df0b_cgraph.svg" width="243" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abff39252e99681eebb5ccf0078b7b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff39252e99681eebb5ccf0078b7b924">&#9670;&nbsp;</a></span>genEsued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsued </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding edges </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esued1</em> and <em>esued2</em>, where <em>esued2</em> holds the indices at which <em>esued1</em> holds the element ids surrounding edges. Looping over all elements surrounding edges can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nedge; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esued.second[e]+1; i&lt;=esued.second[e+1]; ++i)</div><div class="line">    <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> <span class="keywordtype">id</span> esued.first[i]</div></div><!-- fragment --><p> To find out the number of edges, <em>nedge</em>, the edge connectivity, <em>inpoed</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> esup = <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>(inpoel,nnpe);</div><div class="line"><span class="keyword">auto</span> nedge = <a class="code" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">tk::genInpoed</a>(inpoel,nnpe,esup).size()/2;</div></div><!-- fragment --><p> where <em>nnpe</em> is the number of nodes per element (4 for tetrahedra, 3 for triangles). </p><dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00709">709</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>
<div class="fragment"><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;{</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() on empty container&quot;</span> );</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsued() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsued() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup1&quot;</span> );</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup2&quot;</span> );</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  <span class="comment">// lambda that returns true if element e contains edge (p &lt; q)</span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  <span class="keyword">auto</span> has = [ &amp;inpoel, nnpe ]( std::size_t e, std::size_t p, std::size_t q )</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  -&gt; <span class="keywordtype">bool</span> {</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;    std::vector&lt; bool &gt; sp;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n)</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;      <span class="keywordflow">if</span> (inpoel[e*nnpe+n] == p || inpoel[e*nnpe+n] == q)</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;        sp.push_back( <span class="keyword">true</span> );</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    <span class="keywordflow">if</span> (sp.size() == 2) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  };</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  <span class="comment">// map to associate edges to unique surrounding element ids</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;  std::map&lt; std::size_t,  std::vector&lt; std::size_t &gt; &gt; revolver;</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;  <span class="comment">// generate edges and associated vector of unique surrounding element ids</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;  std::size_t ed = 0;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) {  <span class="comment">// for edge given point ids p &lt; q</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;            <span class="keywordflow">for</span> (std::size_t j=esup2[p]+1; j&lt;=esup2[p+1]; ++j ) {</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;              <span class="keyword">auto</span> e = esup1[j];</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;              <span class="keywordflow">if</span> (has(e,p,q)) revolver[ed].push_back(e);</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;            }</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;            ++ed;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;          }</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;        }</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;      }</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  <span class="comment">// linked lists (vectors) to store elements surrounding edges</span></div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  std::vector&lt; std::size_t &gt; esued1( 1, 0 ), esued2( 1, 0 );</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  <span class="comment">// sort and store elements surrounding edges and their indices in vectors</span></div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : revolver) {</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    esued2.push_back( esued2.back() + p.second.size() );</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) esued1.push_back( e );</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  }</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esued1), std::move(esued2) );</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_abff39252e99681eebb5ccf0078b7b924_cgraph.svg" width="243" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7b12aff8f884c70e45c6037b4f37e662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b12aff8f884c70e45c6037b4f37e662">&#9670;&nbsp;</a></span>genEsuel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsuel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esuel1</em> and <em>esuel2</em>, where <em>esuel2</em> holds the indices at which <em>esuel1</em> holds the element ids surrounding elements. Looping over elements surrounding elements can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esuel.second[e]+1; i&lt;=esuel.second[e+1]; ++i)</div><div class="line">     <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> <span class="keywordtype">id</span> esuel.first[i]</div></div><!-- fragment --><p> To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00500">500</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;{</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() on empty container&quot;</span> );</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsuel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by four&quot;</span> );</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel1&quot;</span> );</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel2&quot;</span> );</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="comment">// lambda that returns true if elements hel and gel share a face</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  <span class="keyword">auto</span> adj = [ &amp;inpoel, nnpe ]( std::size_t hel, std::size_t gel ) -&gt; <span class="keywordtype">bool</span> {</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    std::vector&lt; bool &gt; sp;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordflow">for</span> (std::size_t h=0; h&lt;nnpe; ++h)</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;      <span class="keywordflow">for</span> (std::size_t g=0; g&lt;nnpe; ++g)</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="keywordflow">if</span> (inpoel[hel*nnpe+h] == inpoel[gel*nnpe+g]) sp.push_back( <span class="keyword">true</span> );</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">if</span> (sp.size() == nnpe-1) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  };</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  <span class="comment">// map to associate unique elements and their surrounding elements</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; es;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    std::set&lt; std::size_t &gt; faces; <span class="comment">// will collect elem ids of shared faces</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;      <span class="keyword">auto</span> i = inpoel[ e*nnpe+n ];</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=esup2[i]+1; j&lt;=esup2[i+1]; ++j)</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        <span class="keywordflow">if</span> (adj( e, esup1[j] )) faces.insert( esup1[j] );</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    }</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    <span class="comment">// store element ids of shared faces</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : faces) es[e].push_back(j);</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  }</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  <span class="comment">// storing elements surrounding elements</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  std::vector&lt; std::size_t &gt; esuel1( 1, 0 ), esuel2( 1, 0 );</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  <span class="comment">// store elements surrounding elements in linked lists</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : es) {</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    esuel2.push_back( esuel2.back() + e.second.size() );</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : e.second) esuel1.push_back( s );</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  }</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esuel1), std::move(esuel2) );</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b61b3cb6492e71ff9853404440fddcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b61b3cb6492e71ff9853404440fddcc">&#9670;&nbsp;</a></span>genEsuelTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; tk::genEsuelTet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector storing elements surrounding elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a single vector, with length nfpe * nelem. Note however, that nelem is not explicitly provided, but calculated from inpoel. For boundary elements, at the boundary face, this esuelTet stores value -1 indicating that this is outside the domain. The convention for numbering the local face (triangle) connectivity is very important, e.g., in generating the inpofa array later. This node ordering convention is stored in <a class="el" href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">tk::lpofa</a>. Thus function is specific to tetrahedra, which is reflected in the fact that nnpe and nfpe are being set here in the function rather than being input arguments. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00933">933</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_derived_data_8h_source.html#l00033">lpofa</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>, and <a class="el" href="_partitioner_8_c_source.html#l00270">inciter::Partitioner::flatten()</a>.</p>
<div class="fragment"><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;{</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsuelTet() on empty container&quot;</span> );</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsuelTet() with empty esup1&quot;</span> );</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsuelTet() with empty esup2&quot;</span> );</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;  <span class="comment">// set tetrahedron geometry</span></div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;  std::size_t nnpe(4), nfpe(4), nnpf(3);</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by four&quot;</span> );</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;  <span class="comment">// get nelem and npoin</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;  std::vector&lt; int &gt; esuelTet(nfpe*nelem, -1);</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;  std::vector&lt; std::size_t &gt; lhelp(nnpf,0),</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                             lpoin(<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>,0);</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;  {</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keyword">auto</span> mark = nnpe*e;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    <span class="keywordflow">for</span> (std::size_t fe=0; fe&lt;nfpe; ++fe)</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    {</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;      <span class="comment">// array which stores points on this face</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;      lhelp[0] = inpoel[mark+<a class="code" href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">lpofa</a>[fe][0]];</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;      lhelp[1] = inpoel[mark+lpofa[fe][1]];</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;      lhelp[2] = inpoel[mark+lpofa[fe][2]];</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;      <span class="comment">// mark in this array</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;      lpoin[lhelp[0]] = 1;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;      lpoin[lhelp[1]] = 1;</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;      lpoin[lhelp[2]] = 1;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;      <span class="comment">// select a point on this face</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;      <span class="keyword">auto</span> ipoin = lhelp[0];</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;      <span class="comment">// loop over elements around this point</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;      <span class="keywordflow">for</span> (std::size_t j=esup2[ipoin]+1; j&lt;=esup2[ipoin+1]; ++j )</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;      {</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        <span class="keyword">auto</span> jelem = esup1[j];</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;        <span class="comment">// if this jelem is not e itself then proceed</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;        <span class="keywordflow">if</span> (jelem != e)</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        {</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;          <span class="keywordflow">for</span> (std::size_t fj=0; fj&lt;nfpe; ++fj)</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;          {</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;            std::size_t icoun(0);</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;            <span class="keywordflow">for</span> (std::size_t jnofa=0; jnofa&lt;nnpf; ++jnofa)</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;            {</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;              <span class="keyword">auto</span> markj = jelem*nnpe;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;              <span class="keyword">auto</span> jpoin = inpoel[markj+lpofa[fj][jnofa]];</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;              <span class="keywordflow">if</span> (lpoin[jpoin] == 1) { ++icoun; }</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;            }</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            <span class="comment">//store esuel if</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;            <span class="keywordflow">if</span> (icoun == nnpf)</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;            {</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;              <span class="keyword">auto</span> markf = nfpe*e;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;              esuelTet[markf+fe] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(jelem);</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;              markf = nfpe*jelem;</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;              esuelTet[markf+fj] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(e);</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;            }</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;          }</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;        }</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;      }</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;      <span class="comment">// reset this array</span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;      lpoin[lhelp[0]] = 0;</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;      lpoin[lhelp[1]] = 0;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;      lpoin[lhelp[2]] = 0;</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;    }</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  }</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="keywordflow">return</span> esuelTet;</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;}</div><div class="ttc" id="namespacetk_html_a30ac7c57927d6134e6563817f5d005a0"><div class="ttname"><a href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">tk::lpofa</a></div><div class="ttdeci">const std::array&lt; std::array&lt; std::size_t, 3 &gt;, 4 &gt; lpofa</div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8h_source.html#l00033">DerivedData.h:33</a></div></div>
<div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5b61b3cb6492e71ff9853404440fddcc_cgraph.svg" width="256" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae2d934afca4d36661acc1b3e6f863f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d934afca4d36661acc1b3e6f863f05">&#9670;&nbsp;</a></span>genEsuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; tk::genEsuf </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nfpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ntfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nbfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>belem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>esuelTet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfpe</td><td>Number of faces per element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntfac</td><td>Total number of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbfac</td><td>Number of boundary faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">belem</td><td>Boundary element vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esuelTet</td><td>Elements surrounding elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elements surrounding faces.</dd></dl>
<p>The unsigned integer vector gives the IDs of the elements to the </p>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01092">1092</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>.</p>
<div class="fragment"><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;{</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( esuelTet.size()%nfpe == 0, </div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;                  <span class="stringliteral">&quot;Size of esuelTet must be divisible by nfpe&quot;</span> );</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nfpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsuf() with zero faces per element&quot;</span> );</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  <span class="keyword">auto</span> nelem = esuelTet.size()/nfpe;</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  std::vector&lt; int &gt; esuf(2*ntfac);</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  <span class="keywordflow">if</span> (nbfac &gt; 0) {</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    <span class="comment">// counters for number of internal and boundary faces</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    std::size_t icoun(2*nbfac), bcoun(0);</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    <span class="comment">// loop to get face-element connectivity for internal faces</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;      <span class="keywordflow">for</span> (std::size_t ip=nfpe*e; ip&lt;nfpe*(e+1); ++ip) {</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;        <span class="keyword">auto</span> jelem = esuelTet[ip];</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;        <span class="keywordflow">if</span> (jelem != -1)</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;        {</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;          <span class="keywordflow">if</span> ( e &lt; static_cast&lt; std::size_t &gt;(jelem) )</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;          {</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;            esuf[icoun] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>(e);</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;            esuf[icoun+1] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>(jelem);</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;            icoun = icoun + 2;</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;          }</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        }</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;      }</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    }</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    bcoun = 0;</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> ie : belem) {</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;      esuf[bcoun] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>(ie);</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;      esuf[bcoun+1] = -1;  <span class="comment">// outside domain</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;      bcoun = bcoun + 2;</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;    }</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  }</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;  <span class="keywordflow">return</span> esuf;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a66a2889d5d8aeb4a836842c6a1010463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a2889d5d8aeb4a836842c6a1010463">&#9670;&nbsp;</a></span>genEsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esup1</em> and <em>esup2</em>, where <em>esup2</em> holds the indices at which <em>esup1</em> holds the element ids surrounding points. Looping over all elements surrounding all points can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup.second[p]+1; i&lt;=esup.second[p+1]; ++i)</div><div class="line">     <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> <span class="keywordtype">id</span> esup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00041">41</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00027">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00338">inciter::FluxCorrector::alw()</a>, <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>, <a class="el" href="_partitioner_8_c_source.html#l00270">inciter::Partitioner::flatten()</a>, <a class="el" href="_comm_map_8_c_source.html#l00027">poinCommMaps()</a>, <a class="el" href="_partitioner_8_c_source.html#l00958">inciter::Partitioner::refine()</a>, <a class="el" href="_test_error_8h_source.html#l00115">tut::AMRError_common::TestErrorIndicator()</a>, <a class="el" href="_tracker_8h_source.html#l00040">tk::Tracker::Tracker()</a>, and <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsup() on empty container&quot;</span> );</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="comment">// allocate one of the linked lists storing elements surrounding points: esup2</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="comment">// fill with zeros</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  std::vector&lt; std::size_t &gt; esup2( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>+1, 0 );</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="comment">// element pass 1: count number of elements connected to each point</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) ++esup2[ n + 1 ];</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="comment">// storage/reshuffling pass 1: update storage counter and store</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// also find out the maximum size of esup1 (mesup)</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="keyword">auto</span> mesup = esup2[0]+1;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=1; i&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>+1; ++i) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    esup2[i] += esup2[i-1];</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">if</span> (esup2[i]+1 &gt; mesup) mesup = esup2[i]+1;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  }</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="comment">// now we know mesup, so allocate the other one of the linked lists storing</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="comment">// elements surrounding points: esup1</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  std::vector&lt; std::size_t &gt; esup1( mesup );</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="comment">// store the elements in esup1</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  std::size_t e = 0;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keyword">auto</span> j = esup2[n]+1;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    esup2[n] = j;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    esup1[j] = e/nnpe;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    ++e;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  }</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">// storage/reshuffling pass 2</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=npoin; i&gt;0; --i) esup2[i] = esup2[i-1];</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  esup2[0] = 0;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esup1), std::move(esup2) );</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a66a2889d5d8aeb4a836842c6a1010463_cgraph.svg" width="235" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9d835a7a93970d17a66356b64f3291af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d835a7a93970d17a66356b64f3291af">&#9670;&nbsp;</a></span>genEsupel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsupel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding points of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding points of elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esupel1</em> and <em>esupel2</em>, where <em>esupel2</em> holds the indices at which <em>esupel1</em> holds the element ids surrounding points of elements. Looping over all elements surrounding the points of all elements can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esupel.second[e]+1; i&lt;=esupel.second[e+1]; ++i)</div><div class="line">     <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> <span class="keywordtype">id</span> esupel.first[i]</div></div><!-- fragment --><p> To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00424">424</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_tracker_8h_source.html#l00040">tk::Tracker::Tracker()</a>.</p>
<div class="fragment"><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;{</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() on empty container&quot;</span> );</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsupel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup1&quot;</span> );</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup2&quot;</span> );</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <span class="comment">// linked lists storing elements surrounding points of elements, put in a</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="comment">// single zero in both</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  std::vector&lt; std::size_t &gt; esupel2( 1, 0 ), esupel1( 1, 0 );</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  std::size_t e = 0;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  std::set&lt; std::size_t &gt; esuel;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : inpoel) {       <span class="comment">// loop over all points of all elements</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="comment">// collect unique element ids of elements surrounding points of element</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup2[p]+1; i&lt;=esup2[p+1]; ++i) esuel.insert( esup1[i] );</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keywordflow">if</span> (++e%nnpe == 0) {        <span class="comment">// when finished checking all nodes of element</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      <span class="comment">// erase element whose surrounding elements are considered</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;      esuel.erase( e/nnpe-1 );</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      <span class="comment">// store unique element ids in esupel1</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : esuel) esupel1.push_back( i );</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      <span class="comment">// store end-index for element used to address into esupel1</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      esupel2.push_back( esupel2.back() + esuel.size() );</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      esuel.clear();</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    }</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esupel1), std::move(esupel2) );</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af33c6a2dc1649b840ab82bfcd3d1617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33c6a2dc1649b840ab82bfcd3d1617a">&#9670;&nbsp;</a></span>genGeoElemTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tk::Fields tk::genGeoElemTet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, element geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Element-node connectivity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Co-ordinates of nodes in this mesh-chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element geometry information. This includes element volume and element centroid coordinates. Use the following examples to access this information for element-e. volume: geoElem(e,0,0), centroid x-coordinate: geoElem(f,1,0), y-coordinate: geoElem(f,2,0), z-coordinate: geoElem(f,3,0). </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01445">1445</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00062">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;{</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;  <span class="comment">// set tetrahedron geometry</span></div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;  std::size_t nnpe(4);</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0,</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;          <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;  tk::Fields geoElem( nelem, 4 );</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = coord[0];</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; y = coord[1];</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; z = coord[2];</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;  <span class="keywordflow">for</span>(std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;  {</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;    <span class="comment">// get volume</span></div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> A = inpoel[nnpe*e+0];</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> B = inpoel[nnpe*e+1];</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> C = inpoel[nnpe*e+2];</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> D = inpoel[nnpe*e+3];</div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;    std::array&lt; tk::real, 3 &gt; ba{{ x[B]-x[A], y[B]-y[A], z[B]-z[A] }},</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;                              ca{{ x[C]-x[A], y[C]-y[A], z[C]-z[A] }},</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;                              da{{ x[D]-x[A], y[D]-y[A], z[D]-z[A] }};</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> vole = <a class="code" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a>( ba, ca, da ) / 6.0;</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( vole &gt; 0, <span class="stringliteral">&quot;Element Jacobian non-positive&quot;</span> );</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;    geoElem(e,0,0) = vole;</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    <span class="comment">// get centroid</span></div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;    geoElem(e,1,0) = (x[A]+x[B]+x[C]+x[D])/4.0;</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    geoElem(e,2,0) = (y[A]+y[B]+y[C]+y[D])/4.0;</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;    geoElem(e,3,0) = (z[A]+z[B]+z[C]+z[D])/4.0;</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;  }</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;  <span class="keywordflow">return</span> geoElem;</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;}</div><div class="ttc" id="namespacetk_html_ae5b04b00aa51667b944b7188545ec5ae"><div class="ttname"><a href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a></div><div class="ttdeci">T triple(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00062">Vector.h:62</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_af33c6a2dc1649b840ab82bfcd3d1617a_cgraph.svg" width="398" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a61a2eebfe3b1f67bafb3131442ffffa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a2eebfe3b1f67bafb3131442ffffa1">&#9670;&nbsp;</a></span>genGeoFaceTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tk::Fields tk::genGeoFaceTri </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ntfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpofa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f">tk::UnsMesh::Coords</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, face geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ntfac</td><td>Total number of faces in the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpofa</td><td>Face-node connectivity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Co-ordinates of nodes in this mesh-chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates. Use the following examples to access this information for face-f. face area: geoFace(f,0,0), unit-normal x-component: geoFace(f,1,0), y-component: geoFace(f,2,0), z-component: geoFace(f,3,0), centroid x-coordinate: geoFace(f,4,0), y-coordinate: geoFace(f,5,0), z-coordinate: geoFace(f,6,0). </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01294">1294</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l01360">geoFaceTri()</a>.</p>
<div class="fragment"><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;{</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;  tk::Fields geoFace( ntfac, 7 );</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;  <span class="comment">// set triangle geometry</span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;  std::size_t nnpf(3);</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpofa.size()%nnpf == 0,</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;          <span class="stringliteral">&quot;Size of inpofa must be divisible by nnpf&quot;</span> );</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;  <span class="keywordflow">for</span>(std::size_t f=0; f&lt;ntfac; ++f)</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;  {</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;    std::size_t ip1, ip2, ip3;</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> xp1, yp1, zp1,</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;             xp2, yp2, zp2,</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;             xp3, yp3, zp3;</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    <span class="comment">// get area</span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    ip1 = inpofa[nnpf*f];</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    ip2 = inpofa[nnpf*f + 1];</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    ip3 = inpofa[nnpf*f + 2];</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;    xp1 = coord[0][ip1];</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;    yp1 = coord[1][ip1];</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    zp1 = coord[2][ip1];</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;    xp2 = coord[0][ip2];</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    yp2 = coord[1][ip2];</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;    zp2 = coord[2][ip2];</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;    xp3 = coord[0][ip3];</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    yp3 = coord[1][ip3];</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    zp3 = coord[2][ip3];</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;    <span class="keyword">auto</span> geoif = <a class="code" href="namespacetk.html#a51f7ec47d21ee4be4ef5a6e58fdd4776">geoFaceTri</a>( {{xp1, xp2, xp3}},</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;                             {{yp1, yp2, yp3}},</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;                             {{zp1, zp2, zp3}} );</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=0; i&lt;7; ++i)</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;      geoFace(f,i,0) = geoif(0,i,0);</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;  }</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;  <span class="keywordflow">return</span> geoFace;</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;}</div><div class="ttc" id="namespacetk_html_a51f7ec47d21ee4be4ef5a6e58fdd4776"><div class="ttname"><a href="namespacetk.html#a51f7ec47d21ee4be4ef5a6e58fdd4776">tk::geoFaceTri</a></div><div class="ttdeci">tk::Fields geoFaceTri(const std::array&lt; tk::real, 3 &gt; &amp;x, const std::array&lt; tk::real, 3 &gt; &amp;y, const std::array&lt; tk::real, 3 &gt; &amp;z)</div><div class="ttdoc">Compute geometry of the face given by three vertices. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l01360">DerivedData.C:1360</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a61a2eebfe3b1f67bafb3131442ffffa1_cgraph.svg" width="302" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7c8a720dd257388a44d5ca7af7aaec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8a720dd257388a44d5ca7af7aaec8f">&#9670;&nbsp;</a></span>genInedel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genInedel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edges of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoed</td><td>Edge connectivity as linear vector, see <a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity. ">tk::genInpoed</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear vector storing all edge ids * 2 of all elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or inpoed or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector with all edge ids (as defined by inpoed) of all elements. The edge ids stored in inedel can be directly used to index the vector inpoed. Because the derived data structure generated here, inedel, is intended to be used in conjunction with the linear vector inpoed and not with the linked lists edsup1 and edsup2, this function takes inpoed as an argument. Accessing the edges of element e using the edge of elements data structure, inedel, generated here can be accomplished by </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;nepe; ++i) {</div><div class="line">    <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> edge <span class="keywordtype">id</span> inedel[e*nepe+i] of <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> e, or</div><div class="line">    <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> point ids p &lt; q of edge <span class="keywordtype">id</span> inedel[e*nepe+i] of <a class="code" href="namespacetk.html#a928d7dd976738fc1e3de5f4ee6147140">element</a> e as</div><div class="line">      p = inpoed[ inedel[e*nepe+i]*2 ]</div><div class="line">      q = inpoed[ inedel[e*nepe+i]*2+1 ]</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> where <em>nepe</em> denotes the number of edges per elements: 3 for triangles, 6 for tetrahedra. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00589">589</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>
<div class="fragment"><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;{</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() on empty container&quot;</span> );</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInedel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInedel() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoed.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() with empty inpoed&quot;</span> );</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  <span class="comment">// First, generate index of star centers. This is necessary to avoid a</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  <span class="comment">// brute-force search for point ids of edges when searching for element edges.</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  <span class="comment">// Note that this is the same as edsup2, generated by genEdsup(). However,</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  <span class="comment">// because the derived data structure generated here, inedel, is intended to</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  <span class="comment">// be used in conjunction with the linear vector inpoed and not with the</span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  <span class="comment">// linked lists edsup1 and edsup2, this function takes inpoed as an argument,</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <span class="comment">// and so edsup2 is temporarily generated here to avoid a brute-force search.</span></div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="comment">// generate stars from inpoed; starting with zero, every even is a star</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  <span class="comment">// center, every odd is a spike</span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;inpoed.size()/2; ++i)</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    star[ inpoed[i*2] ].push_back( inpoed[i*2+1] );</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;  <span class="comment">// store index of star centers in vector; assume non-center points of each</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  <span class="comment">// star have already been sorted</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;  std::vector&lt; std::size_t &gt; edsup2( 1, 0 );</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) edsup2.push_back( edsup2.back() + p.second.size() );</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  <span class="comment">// fill up index array with the last index for points with no new edges</span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>-star.size(); ++i)</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    edsup2.push_back( edsup2.back() );</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  star.clear();</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  <span class="comment">// Second, generate edges of elements</span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  <span class="comment">// map associating elem id with vector of edge ids</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; edges;</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <span class="comment">// generate map of elements associated to edge ids</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;      <span class="keyword">auto</span> p = inpoel[e*nnpe+n];</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup2[p]+1; i&lt;=edsup2[p+1]; ++i)</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;         <span class="keywordflow">for</span> (std::size_t j=0; j&lt;nnpe; ++j)</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keywordflow">if</span> (inpoed[(i-1)*2+1] == inpoel[e*nnpe+j])</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;              edges[e].push_back( i-1 );</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    }</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  <span class="comment">// linear vector to store the edge ids of all elements</span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  std::vector&lt; std::size_t &gt; inedel;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <span class="comment">// store edge ids of elements in linear vector</span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : edges) <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : e.second) inedel.push_back( p );</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  <span class="comment">// Return (move out) vector</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  <span class="keywordflow">return</span> inedel;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a7c8a720dd257388a44d5ca7af7aaec8f_cgraph.svg" width="240" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a559eb56e40ec844767bd2a55da55bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559eb56e40ec844767bd2a55da55bda0">&#9670;&nbsp;</a></span>genInpoed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genInpoed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edge connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear vector storing edge connectivity (point ids p &lt; q) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector and is very similar to the linked lists, <em>edsup1</em> and _edsup2, generated by <a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points. ">genEdsup()</a>. The difference is that in the linear vector, inpoed, generated here, both edge point ids are stored as a pair, p &lt; q, as opposed to the linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end point ids (still associated to edge-start point ids when used together with edsup2). The rationale is that while inpoed is larger in memory, it allows direct access to edges (pair of point ids making up an edge), edsup1 and edsup2 are smaller in memory, still allow accessing the same data (edge point id pairs) but only in a linear fashion, not by direct access to particular edges. Accessing all unique edges using the edge connectivity data structure, inpoed, generated here can be accomplished by </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;inpoed.size()/2; ++e) {</div><div class="line">  <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> point <span class="keywordtype">id</span> p of edge e = inpoed[e*2];</div><div class="line">  <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> point <span class="keywordtype">id</span> q of edge e = inpoed[e*2+1];</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points. ">tk::genEdsup</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00322">322</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_test_error_8h_source.html#l00115">tut::AMRError_common::TestErrorIndicator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() on empty container&quot;</span> );</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInpoed() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInpoed() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup1&quot;</span> );</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup2&quot;</span> );</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges,</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back( q );</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        }</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      }</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  <span class="comment">// linear vector to store edge connectivity and their indices</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  std::vector&lt; std::size_t &gt; inpoed;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  <span class="comment">// sort non-center points of each star and store both start and end points of</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  <span class="comment">// each star in linear vector</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      inpoed.push_back( p.first );</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      inpoed.push_back( e );</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    }</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  }</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="comment">// Return (move out) linear vector</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  <span class="keywordflow">return</span> inpoed;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a559eb56e40ec844767bd2a55da55bda0_cgraph.svg" width="246" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae501950a1a32199708b69a52382f1b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae501950a1a32199708b69a52382f1b1e">&#9670;&nbsp;</a></span>genInpofaTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genInpofaTet </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ntfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nbfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>triinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>esuelTet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, node-face connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ntfac</td><td>Total number of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbfac</td><td>Number of boundary faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Element-node connectivity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triinpoel</td><td>Face-node connectivity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esuelTet</td><td>Elements surrounding elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Points surrounding faces. The unsigned integer vector gives the elements to the left and to the right of each face in the mesh. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01151">1151</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8h_source.html#l00033">lpofa</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>.</p>
<div class="fragment"><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;{</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;  std::vector&lt; std::size_t &gt; inpofa;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;  <span class="keywordflow">if</span> (nbfac &gt; 0)</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;  {</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    <span class="comment">// set tetrahedron geometry</span></div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;    std::size_t nnpe(4), nfpe(4), nnpf(3);</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( esuelTet.size()%nfpe == 0,</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;                    <span class="stringliteral">&quot;Size of esuelTet must be divisible by nfpe&quot;</span> );</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0,</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                    <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    inpofa.resize(nnpf*ntfac);</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="comment">// counters for number of internal and boundary faces</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    std::size_t icoun(nnpf*nbfac);</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    std::size_t mark(0);</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    <span class="comment">// loop over elems to get nodes on faces</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    <span class="comment">// this fills the interior face-node connectivity part</span></div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    {</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;      mark = nnpe*e;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;      <span class="keywordflow">for</span> (std::size_t f=0; f&lt;nfpe ; ++f)</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;      {</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;        <span class="keyword">auto</span> ip = nfpe*e + f;</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;        <span class="keyword">auto</span> jelem = esuelTet[ip];</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;        <span class="keywordflow">if</span> (jelem != -1)</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;        {</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;          <span class="keywordflow">if</span> ( e &lt; static_cast&lt; std::size_t &gt;(jelem) )</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;          {</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;            inpofa[icoun]   = inpoel[mark+<a class="code" href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">lpofa</a>[f][0]];</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;            inpofa[icoun+1] = inpoel[mark+lpofa[f][1]];</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;            inpofa[icoun+2] = inpoel[mark+lpofa[f][2]];</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;            icoun = icoun + nnpf;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;          }</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        }</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;      }</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;    }</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;    <span class="comment">// this fills the boundary face-node connectivity part</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    <span class="comment">// consistent with triinpoel</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    <span class="keywordflow">for</span> (std::size_t f=0; f&lt;nbfac; ++f)</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;    {</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;      icoun = nnpf * f;</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;      inpofa[icoun+0] = triinpoel[icoun+2];</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;      inpofa[icoun+1] = triinpoel[icoun+1];</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;      inpofa[icoun+2] = triinpoel[icoun+0];</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;    }</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;  }</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;  <span class="keywordflow">return</span> inpofa;</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;}</div><div class="ttc" id="namespacetk_html_a30ac7c57927d6134e6563817f5d005a0"><div class="ttname"><a href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0">tk::lpofa</a></div><div class="ttdeci">const std::array&lt; std::array&lt; std::size_t, 3 &gt;, 4 &gt; lpofa</div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8h_source.html#l00033">DerivedData.h:33</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab68c15dd976b0c7420ebee8770fb1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68c15dd976b0c7420ebee8770fb1f9c">&#9670;&nbsp;</a></span>genNbfacTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::genNbfacTet </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tnbfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>triinpoel_complete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bface_complete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::size_t, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>triinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate total number of boundary faces in this chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tnbfac</td><td>Total number of boundary faces in the entire mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triinpoel_complete</td><td>Interconnectivity of points and boundary-face in the entire mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bface_complete</td><td>Map of boundary-face lists mapped to corresponding side set ids for the entire mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lid</td><td>Mapping between the node indices used in the smaller inpoel connectivity (a subset of the entire triinpoel_complete connectivity), e.g., after mesh partitioning. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triinpoel</td><td>Interconnectivity of points and boundary-face in this mesh-partition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bface</td><td>Map of boundary-face lists mapped to corresponding side set ids for this mesh-partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of boundary-faces on this chare/mesh-partition.</dd></dl>
<p>This function takes a mesh by its domain-element (tetrahedron-connectivity) in inpoel and a boundary-face (triangle) connectivity in triinpoel_complete. Based on these two arrays, it searches for those faces of triinpoel_complete that are also in inpoel and as a result it generates (1) the number of boundary faces shared with the mesh in inpoel and (2) the intersection of the triangle element connectivity whose faces are shared with inpoel. An example use case is where triinpoel_complete contains the connectivity for the boundary of the full problem/mesh and inpoel contains the connectivity for only a chunk of an already partitioned mesh. This function then intersects triinpoel_complete with inpoel and returns only those faces that share nodes with inpoel. </p>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00822">822</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_container_util_8h_source.html#l00037">cref_find()</a>, and <a class="el" href="_container_util_8h_source.html#l00023">unique()</a>.</p>
<div class="fragment"><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;{</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;  std::size_t nbfac(0), nnpf(3);</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  <span class="keywordflow">if</span> (tnbfac &gt; 0)</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;  {</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(),</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;          <span class="stringliteral">&quot;Attempt to call genNbfacTet() on empty inpoel container&quot;</span> );</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !triinpoel_complete.empty(),</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;          <span class="stringliteral">&quot;Attempt to call genNbfacTet() on empty triinpoel_complete container&quot;</span> );</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( triinpoel_complete.size()/nnpf == tnbfac, </div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;          <span class="stringliteral">&quot;Incorrect size of triinpoel in genNbfacTet()&quot;</span> );</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;  <span class="keyword">auto</span> nptet = inpoel;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;  <span class="keyword">auto</span> nptri = triinpoel_complete;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;  <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( nptet );</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( nptri );</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;  std::unordered_set&lt; std::size_t &gt; snptet;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;  <span class="comment">// getting the reduced inpoel as a set for quick searches</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;  snptet.insert( begin(nptet), end(nptet));</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;  <span class="comment">// vector to store boundary-face-nodes in this chunk</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;  std::vector&lt; std::size_t &gt; nptri_chunk;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;  <span class="comment">// getting the nodes of the boundary-faces in this chunk</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : nptri)</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    <span class="keywordflow">if</span> (snptet.find(i) != end(snptet))</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;      nptri_chunk.push_back(i);</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;  std::size_t <a class="code" href="namespacetag.html">tag</a>, icoun;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;  <span class="comment">// matching nodes in nptri_chunk with nodes in inpoel and </span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  <span class="comment">// triinpoel_complete to get the number of faces in this chunk</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ss : bface_complete)</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> f : ss.second)</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;      icoun = f*nnpf;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;      tag = 0;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i&lt;nnpf; ++i)</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;      {</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : nptri_chunk)</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        {</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;          <span class="keywordflow">if</span> (triinpoel_complete[icoun+i] == j) ++tag;</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;        }</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;      }</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;      <span class="keywordflow">if</span> (tag == nnpf)</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;      <span class="comment">// this is a boundary face</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;      {</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;        <span class="keywordflow">for</span> (std::size_t i=0; i&lt;nnpf; ++i)</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;        {</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;          <span class="keyword">auto</span> ip = triinpoel_complete[icoun+i];</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;          <span class="comment">// find local renumbered node-id to store in triinpoel</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;          triinpoel.push_back( <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a>(lid,ip) );</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        }</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;        bface[ss.first].push_back(nbfac);</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        ++nbfac;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;      }</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    }</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;  }</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;  }</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;  <span class="keywordflow">return</span> nbfac;</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;}</div><div class="ttc" id="namespacetag_html"><div class="ttname"><a href="namespacetag.html">tag</a></div><div class="ttdoc">Tags used as unique-type labels for compile-time code-generation. </div><div class="ttdef"><b>Definition:</b> <a href="_tags_8h_source.html#l00013">Tags.h:13</a></div></div>
<div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00023">ContainerUtil.h:23</a></div></div>
<div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00037">ContainerUtil.h:37</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab68c15dd976b0c7420ebee8770fb1f9c_cgraph.svg" width="275" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a94114220a51c1ba65f5f1e8314ffc27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94114220a51c1ba65f5f1e8314ffc27e">&#9670;&nbsp;</a></span>genNtfac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::genNtfac </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nfpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nbfac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>esuelTet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, total number of faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfpe</td><td>Number of faces per element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbfac</td><td>Number of boundary faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esuelTet</td><td>Elements surrounding elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of faces in the mesh</dd></dl>
<p>The unsigned integer here gives the total number of faces in </p>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01049">1049</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>.</p>
<div class="fragment"><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;{</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esuelTet.empty(), <span class="stringliteral">&quot;Attempt to call genNtfac() with empty esuelTet&quot;</span> );</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( esuelTet.size()%nfpe == 0,</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;                  <span class="stringliteral">&quot;Size of esuelTet must be divisible by nfpe&quot;</span> );</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nfpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genNtfac() with zero faces per element&quot;</span> );</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;  <span class="keyword">auto</span> nelem = esuelTet.size()/nfpe;</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;  std::size_t nifac = 0;</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;  <span class="keywordflow">if</span> (nbfac &gt; 0) {</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;    <span class="comment">// loop through elements surrounding elements to find number of internal faces</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    {</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;      <span class="keywordflow">for</span> (std::size_t ip=nfpe*e; ip&lt;nfpe*(e+1); ++ip)</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;      {</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;        <span class="keywordflow">if</span> (esuelTet[ip] != -1)</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;        {</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;          <span class="keywordflow">if</span> ( e&lt;static_cast&lt; std::size_t &gt;(esuelTet[ip]) )</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;          {</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;            ++nifac;</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;          }</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;        }</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;      }</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    }</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;  }</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;  <span class="keywordflow">return</span> nifac + nbfac;</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2a88a65102c17149b44660db15d445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a88a65102c17149b44660db15d445b">&#9670;&nbsp;</a></span>genPsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genPsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, points surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing points surrounding points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>psup1</em> and <em>psup2</em>, where <em>psup2</em> holds the indices at which <em>psup1</em> holds the point ids surrounding points. Looping over all points surrounding all points can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i)</div><div class="line">     <a class="code" href="namespacefileconv_1_1cmd.html#aceeec79fedb829b6355c9d0658d9d32d">use</a> point <span class="keywordtype">id</span> psup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --><p> or the length-1 of the generated index list: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> npoin = psup.second.size()-1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00124">124</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_comm_map_8_c_source.html#l00027">poinCommMaps()</a>, <a class="el" href="_partitioner_8_c_source.html#l00958">inciter::Partitioner::refine()</a>, and <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;{</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() on empty container&quot;</span> );</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genPsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup1&quot;</span> );</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup2&quot;</span> );</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = *minmax.second + 1;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="comment">// allocate both of the linked lists storing points surrounding points, we</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <span class="comment">// only know the size of psup2, put in a single zero in psup1</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  std::vector&lt; std::size_t &gt; psup2( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>+1 ), psup1( 1, 0 );</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <span class="comment">// fill both psup1 and psup2</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  psup2[0] = 0;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  std::size_t j = 0;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p) {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i ) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;          ++j;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          psup1.push_back( q );</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        }</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    psup2[p+1] = j;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  }</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="comment">// sort point ids for each point in psup1</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;<a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>; ++p)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    std::sort(</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p]+1) ),</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p+1]+1) ) );</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(psup1), std::move(psup2) );</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ad2a88a65102c17149b44660db15d445b_cgraph.svg" width="235" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a51f7ec47d21ee4be4ef5a6e58fdd4776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f7ec47d21ee4be4ef5a6e58fdd4776">&#9670;&nbsp;</a></span>geoFaceTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tk::Fields tk::geoFaceTri </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geometry of the face given by three vertices. </p>
<p>Compute geometry of the face given by three vertices </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x-coordinates of the three vertices of the triangular face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y-coordinates of the three vertices of the triangular face. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z-coordinates of the three vertices of the triangular face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l01360">1360</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_d_g_8_c_source.html#l00550">inciter::DG::addGeoFace()</a>, <a class="el" href="_derived_data_8_c_source.html#l01294">genGeoFaceTri()</a>, and <a class="el" href="_d_g_8_c_source.html#l00149">inciter::DG::leakyPartition()</a>.</p>
<div class="fragment"><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;{</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;  tk::Fields geoiFace( 1, 7 );</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> xp1, yp1, zp1,</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;           xp2, yp2, zp2,</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;           xp3, yp3, zp3,</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;           ax, ay, az,</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;           bx, by, bz,</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;           nx, ny, nz,</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;           sidea, sideb, sidec,</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;           semip, farea;</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;  xp1 = x[0];</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;  xp2 = x[1];</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;  xp3 = x[2];</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;  yp1 = y[0];</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;  yp2 = y[1];</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;  yp3 = y[2];</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;  zp1 = z[0];</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;  zp2 = z[1];</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;  zp3 = z[2];</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;  sidea = sqrt( (xp2-xp1)*(xp2-xp1)</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;              + (yp2-yp1)*(yp2-yp1)</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;              + (zp2-zp1)*(zp2-zp1) );</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;  sideb = sqrt( (xp3-xp2)*(xp3-xp2)</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;              + (yp3-yp2)*(yp3-yp2)</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;              + (zp3-zp2)*(zp3-zp2) );</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;  sidec = sqrt( (xp1-xp3)*(xp1-xp3)</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;              + (yp1-yp3)*(yp1-yp3)</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;              + (zp1-zp3)*(zp1-zp3) );</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;  semip = 0.5 * (sidea + sideb + sidec);</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;  farea = sqrt( semip</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;              * (semip-sidea)</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;              * (semip-sideb)</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;              * (semip-sidec) );</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;  geoiFace(0,0,0) = farea;</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;  <span class="comment">// get unit normal to face</span></div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;  ax = xp2 - xp1;</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;  ay = yp2 - yp1;</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;  az = zp2 - zp1;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;  bx = xp3 - xp1;</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;  by = yp3 - yp1;</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;  bz = zp3 - zp1;</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;  nx =   ay*bz - az*by;</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;  ny = -(ax*bz - az*bx);</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;  nz =   ax*by - ay*bx;</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;  farea = sqrt(nx*nx + ny*ny + nz*nz);</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;  geoiFace(0,1,0) = nx/farea;</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;  geoiFace(0,2,0) = ny/farea;</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;  geoiFace(0,3,0) = nz/farea;</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;  <span class="comment">// get centroid</span></div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;  geoiFace(0,4,0) = (xp1+xp2+xp3)/3.0;</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;  geoiFace(0,5,0) = (yp1+yp2+yp3)/3.0;</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;  geoiFace(0,6,0) = (zp1+zp2+zp3)/3.0;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;  <span class="keywordflow">return</span> geoiFace;</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;}</div><div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ee7abd71123782d48e2ec04906fe982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee7abd71123782d48e2ec04906fe982">&#9670;&nbsp;</a></span>global2local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt;, std::unordered_map&lt; std::size_t, std::size_t &gt; &gt; tk::global2local </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ginpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ginpoel</td><td>Element connectivity with global node IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) element connectivity with local node IDs, (2) the vector of unique global node IDs (i.e., the mapping between local to global node IDs), and (3) mapping between global to local node IDs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00163">163</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_reorder_8_c_source.html#l00147">assignLid()</a>, <a class="el" href="_container_util_8h_source.html#l00037">cref_find()</a>, and <a class="el" href="_container_util_8h_source.html#l00023">unique()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_face_data_8_c_source.html#l00025">inciter::FaceData::FaceData()</a>, <a class="el" href="_partitioner_8_c_source.html#l00270">inciter::Partitioner::flatten()</a>, and <a class="el" href="_partitioner_8_c_source.html#l00036">inciter::Partitioner::Partitioner()</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;{</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="comment">// Make a copy of the element connectivity with global node ids</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keyword">auto</span> gid = ginpoel;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// Generate a vector that holds only the unique global mesh node ids</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( gid );</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="comment">// Assign local node ids to global node ids</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> lid = <a class="code" href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">tk::assignLid</a>( gid );</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="comment">// Generate element connectivity using local node ids</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  std::vector&lt; std::size_t &gt; inpoel;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : ginpoel) inpoel.push_back( <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a>( lid, p ) );</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="comment">// Return element connectivty with local node IDs</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="keywordflow">return</span> std::make_tuple( inpoel, gid, lid );</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00023">ContainerUtil.h:23</a></div></div>
<div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00037">ContainerUtil.h:37</a></div></div>
<div class="ttc" id="namespacetk_html_acb19d7c5f6c7354614bb457d6b17afde"><div class="ttname"><a href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">tk::assignLid</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, std::size_t &gt; assignLid(const std::vector&lt; std::size_t &gt; &amp;gid)</div><div class="ttdoc">Assign local ids to global ids. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00147">Reorder.C:147</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a0ee7abd71123782d48e2ec04906fe982_cgraph.svg" width="278" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad6260a3dcdcb9a995a4886e566b665c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6260a3dcdcb9a995a4886e566b665c4">&#9670;&nbsp;</a></span>hms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a> tk::hms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>stamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert existing time stamp as a real to Watch (global scope) </p>
<p>Convert existing time stamp as a real to Watch (global-scope) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stamp</td><td>Time stamp as a real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time as hours, minutes, and seconds, as a Watch struct. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_timer_8_c_source.html#l00090">90</a> of file <a class="el" href="_timer_8_c_source.html">Timer.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_file_conv_8_c_source.html#l00092">Main::execute()</a>, <a class="el" href="_file_conv_8_c_source.html#l00099">Main::finalize()</a>, and <a class="el" href="_file_conv_8_c_source.html#l00110">Main::timestamp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;{</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keyword">using</span> std::chrono::duration_cast;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> d = Timer::Dsec( stamp );</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keywordflow">return</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    Timer::Watch( duration_cast&lt; Timer::hours &gt;( d ),</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                  duration_cast&lt; Timer::minutes &gt;( d ) % Timer::hours(1),</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                  duration_cast&lt; Timer::seconds &gt;( d ) % Timer::minutes(1) );</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aeb9673379e599043b13fff369dce1402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9673379e599043b13fff369dce1402">&#9670;&nbsp;</a></span>instantiate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Obj &gt; tk::instantiate </td>
          <td>(</td>
          <td class="paramtype">const Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiate object from factory. Factory must have a mapped_value which must have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This wrapper function can be used to instantiate an derived-class object from a factory, repeatedly filled with wrapper function 'record' above. The factory, as described in the documentation of 'record', stores base class pointers in an associative container, thereby facilitating runtime polymorphism and a simple lookup-and-instantiate-style object creation. The object instantiated is of type Child class. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to instantiate object from (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the object to instantiate from factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr pointing to the object instantiated from factory </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980">record</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00072">72</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, and <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                                                     {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> it = f.find( key );</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( it != end( f ), <span class="stringliteral">&quot;No such object registered in factory&quot;</span> );</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">return</span> std::unique_ptr&lt; Obj &gt;( it-&gt;second() );</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_aeb9673379e599043b13fff369dce1402_cgraph.svg" width="264" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6b203c3a87657090a5c477896ce94bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b203c3a87657090a5c477896ce94bf9">&#9670;&nbsp;</a></span>keyEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::keyEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if all keys of two associative containers are equal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st container to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd container to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the containers have the same size and all keys (and only the keys) of the two containers are equal </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is an error to call this function with unequal-size containers, triggering an exception in DEBUG mode. </dd>
<dd>
Operator != is used to compare the container keys. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00135">135</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_solver_8_c_source.html#l01064">tk::Solver::lowsolve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                                                        {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.size() == b.size(), <span class="stringliteral">&quot;Size mismatch comparing containers&quot;</span> );</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="keyword">auto</span> ia = a.cbegin();</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  <span class="keyword">auto</span> ib = b.cbegin();</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keywordflow">while</span> (ia != a.cend()) {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span> (ia-&gt;first != ib-&gt;first) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    ++ia;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    ++ib;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae484074849c5c9532282fc9fa4e19467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484074849c5c9532282fc9fa4e19467">&#9670;&nbsp;</a></span>linearLoadDistributor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t tk::linearLoadDistributor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>virtualization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>chunksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute linear load distribution for given total work and virtualization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualization</td><td>Degree of virtualization [0.0...1.0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load</td><td>Total load, e.g., number of particles, number of mesh cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npe</td><td>Number of processing elements to distribute the load to </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chunksize</td><td>Chunk size, see detailed description </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">remainder</td><td>Remainder, see detailed description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of work units</dd></dl>
<p>Compute load distibution (number of chares and chunksize) based on total work (e.g., total number of particles) and virtualization</p>
<p>The virtualization parameter, specified by the user, is a real number between 0.0 and 1.0, inclusive, which controls the degree of virtualization or over-decomposition. Independent of the value of virtualization the work is approximately evenly distributed among the available processing elements, given by npe. For zero virtualization (no over-decomposition), the work is simply decomposed into total_work/numPEs, which yields the smallest number of Charm++ chares and the largest chunks of work units. The other extreme is unity virtualization, which decomposes the total work into the smallest size work units possible, yielding the largest number of Charm++ chares. Obviously, the optimum will be between 0.0 and 1.0, depending on the problem.</p>
<p>The formula implemented uses a linear relationship between the virtualization parameter and the number of work units with the extremes described above. The formula is given by</p>
<p>chunksize = (1 - n) * v + n;</p>
<p>where</p><ul>
<li>v = degree of virtualization</li>
<li>n = load/npes</li>
<li>load = total work, e.g., number of particles, number of mesh cells</li>
<li>npes = number of hardware processing elements </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_load_distributor_8_c_source.html#l00020">20</a> of file <a class="el" href="_load_distributor_8_c_source.html">LoadDistributor.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_distributor_8_c_source.html#l00051">walker::Distributor::Distributor()</a>, and <a class="el" href="_transporter_8_c_source.html#l00300">inciter::Transporter::load()</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;{</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( virtualization &gt; -std::numeric_limits&lt; tk::real &gt;::epsilon() &amp;&amp;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;          virtualization &lt; 1.0+std::numeric_limits&lt; tk::real &gt;::epsilon(),</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;          <span class="stringliteral">&quot;Virtualization parameter must be between [0.0...1.0]&quot;</span> );</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( npe &gt; 0, <span class="stringliteral">&quot;Number of processing elements must be larger than zero&quot;</span> );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="comment">// Compute minimum number of work units</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span> <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> <span class="keyword">&gt;</span>( load ) / npe;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="comment">// Compute work unit size based on the linear formula above</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  chunksize = <span class="keyword">static_cast&lt;</span> uint64_t <span class="keyword">&gt;</span>( (1.0 - n) * virtualization + n );</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Compute number of work units with size computed ignoring remainder</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  uint64_t nchare = load / chunksize;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// Compute remainder of work if the above number of units were to be created</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  remainder = load - nchare * chunksize;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="comment">// Redistribute remainder among the work units for a more equal distribution</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  chunksize += remainder / nchare;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// Compute new remainder (after redistribution of the previous remainder)</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  remainder = load - nchare * chunksize;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// Return number of work units (number of Charm++ chares)</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keywordflow">return</span> nchare;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div><div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af9d21933fc9e1a656db37419b2173f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d21933fc9e1a656db37419b2173f5f">&#9670;&nbsp;</a></span>Main()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class Printer , class CmdLine &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Driver tk::Main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmdLine &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output. ">Main()</a> used for all executables for code-reuse and a uniform output. </p>
<p>The template arguments configure this <a class="el" href="class_main.html" title="Charm++ main chare for the file converter executable, fileconv. ">Main</a> class that is practically used instead of the usual <a class="el" href="_unit_test_8_c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="UnitTest main() ">main()</a>. This allows code-reuse and a unfirom screen-output. The template arguments are:</p><ul>
<li>Driver, specializaing the driver type to be created, see tk::Driver</li>
<li>Printer, specializaing the pretty printer type to use, see <a class="el" href="classtk_1_1_print.html">tk::Print</a></li>
<li>CmdLine, specializing the command line object storing data parsed from the command line <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>Command line object storing data parsed from the command line arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which executable header to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instantiated driver object which can then be used to <a class="el" href="classexecute.html" title="Charm++ chare execute. ">execute()</a> whatever it is intended to drive </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00179">179</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_init_8h_source.html#l00101">echoBuildEnv()</a>, <a class="el" href="_init_8h_source.html#l00078">echoHeader()</a>, and <a class="el" href="_init_8h_source.html#l00131">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <span class="comment">// Echo program header</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <a class="code" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">echoHeader</a>( print, header );</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">// Echo environment</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  print.part( <span class="stringliteral">&quot;Environment&quot;</span> );</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// Build environment</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <a class="code" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">echoBuildEnv</a>( print, executable );</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="comment">// Runtime environment</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <a class="code" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">echoRunEnv</a>( print, argc, argv, cmdline.template get&lt; tag::verbose &gt;() );</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// Create and return driver</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="keywordflow">return</span> Driver( print, cmdline );</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;}</div><div class="ttc" id="namespacetk_html_ab72923dba604ccbf4233af3ccafc70b3"><div class="ttname"><a href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">tk::echoBuildEnv</a></div><div class="ttdeci">static void echoBuildEnv(const Print &amp;print, const std::string &amp;executable)</div><div class="ttdoc">Echo build environment. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00101">Init.h:101</a></div></div>
<div class="ttc" id="namespacetk_html_a991ea7a4015fef3262bdb056f840bf82"><div class="ttname"><a href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">tk::echoRunEnv</a></div><div class="ttdeci">static void echoRunEnv(const Print &amp;print, int argc, char **argv, bool verbose)</div><div class="ttdoc">Echo runtime environment. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00131">Init.h:131</a></div></div>
<div class="ttc" id="namespacetk_html_afbbf10b984ba3f66b55cc8363c6a2341"><div class="ttname"><a href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">tk::echoHeader</a></div><div class="ttdeci">static void echoHeader(const Print &amp;print, HeaderType header)</div><div class="ttdoc">Echo program header. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00078">Init.h:78</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_af9d21933fc9e1a656db37419b2173f5f_cgraph.svg" width="491" height="479"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac9a26e30d19b940a12990a866a514cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a26e30d19b940a12990a866a514cb5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; tk::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator max between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object containing the maximum of all values for each value in <em>a</em> and <em>b</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties. </dd>
<dd>
As opposed to std::max, this function creates and returns a new object instead of returning a reference to one of the operands. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00589">589</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_data_8h_source.html#l00266">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00186">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00181">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node__connectivity_8h_source.html#l00130">AMR::node_connectivity_t::add()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00027">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00338">inciter::FluxCorrector::alw()</a>, <a class="el" href="_p_d_f_writer_8h_source.html#l00084">tk::PDFWriter::assertSampleSpaceExtents()</a>, <a class="el" href="_c_g_euler_8h_source.html#l00065">inciter::cg::CompFlowPhysicsEuler::conduct_dt()</a>, <a class="el" href="_d_g_euler_8h_source.html#l00065">inciter::dg::CompFlowPhysicsEuler::conduct_dt()</a>, <a class="el" href="_c_g_navier_stokes_8h_source.html#l00176">inciter::cg::CompFlowPhysicsNavierStokes::conduct_dt()</a>, <a class="el" href="_d_g_navier_stokes_8h_source.html#l00176">inciter::dg::CompFlowPhysicsNavierStokes::conduct_dt()</a>, <a class="el" href="_c_g_advection_8h_source.html#l00047">inciter::cg::TransportPhysicsAdvection::diffusion_dt()</a>, <a class="el" href="_d_g_advection_8h_source.html#l00047">inciter::dg::TransportPhysicsAdvection::diffusion_dt()</a>, <a class="el" href="_c_g_adv_diff_8h_source.html#l00071">inciter::cg::TransportPhysicsAdvDiff::diffusion_dt()</a>, <a class="el" href="_mat_c_g_8_c_source.html#l00136">inciter::MatCG::dt()</a>, <a class="el" href="_d_g_comp_flow_8h_source.html#l00087">inciter::dg::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_d_g_8_c_source.html#l00685">inciter::DG::dt()</a>, <a class="el" href="_diag_c_g_8_c_source.html#l00223">inciter::DiagCG::dt()</a>, <a class="el" href="_d_g_transport_8h_source.html#l00178">inciter::dg::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_c_g_transport_8h_source.html#l00303">inciter::cg::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00328">inciter::cg::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="edge_8h_source.html#l00025">edge_t::edge_t()</a>, <a class="el" href="_p_d_f_writer_8_c_source.html#l01170">tk::PDFWriter::extents()</a>, <a class="el" href="node__connectivity_8h_source.html#l00112">AMR::node_connectivity_t::find()</a>, <a class="el" href="id__generator_8h_source.html#l00122">AMR::morton_id_generator_t::get_child_id()</a>, <a class="el" href="_inciter_2_input_deck_2_input_deck_8h_source.html#l00148">inciter::ctr::InputDeck::InputDeck()</a>, <a class="el" href="_walker_2_input_deck_2_input_deck_8h_source.html#l00222">walker::ctr::InputDeck::InputDeck()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00388">inciter::FluxCorrector::lim()</a>, <a class="el" href="_random123_8h_source.html#l00045">tk::Random123&lt; CBRNG &gt;::Adaptor::max()</a>, <a class="el" href="_dist_f_c_t_8_c_source.html#l00109">inciter::DistFCT::next()</a>, <a class="el" href="_progress_8h_source.html#l00073">tk::Progress&lt; 6 &gt;::start()</a>, <a class="el" href="_discretization_8_c_source.html#l00263">inciter::Discretization::stat()</a>, <a class="el" href="_c_g_euler_8h_source.html#l00049">inciter::cg::CompFlowPhysicsEuler::viscous_dt()</a>, <a class="el" href="_d_g_euler_8h_source.html#l00049">inciter::dg::CompFlowPhysicsEuler::viscous_dt()</a>, <a class="el" href="_c_g_navier_stokes_8h_source.html#l00118">inciter::cg::CompFlowPhysicsNavierStokes::viscous_dt()</a>, <a class="el" href="_d_g_navier_stokes_8h_source.html#l00118">inciter::dg::CompFlowPhysicsNavierStokes::viscous_dt()</a>, and <a class="el" href="_p_d_f_writer_8_c_source.html#l00049">tk::PDFWriter::writeTxt()</a>.</p>
<div class="fragment"><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                                                                       {</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nunk() == b.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nprop() == b.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  Data&lt; Layout &gt; r( a.nunk(), a.nprop() );</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  std::transform( a.data().cbegin(), a.data().cend(),</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                  b.data().cbegin(), r.data().begin(),</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                  []( <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> s, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d ){ <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">std::max</a>(s,d); } );</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;}</div><div class="ttc" id="namespacetk_html_ac9a26e30d19b940a12990a866a514cb5"><div class="ttname"><a href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">tk::max</a></div><div class="ttdeci">Data&lt; Layout &gt; max(const Data&lt; Layout &gt; &amp;a, const Data&lt; Layout &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_data_8h_source.html#l00589">Data.h:589</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac9a26e30d19b940a12990a866a514cb5_cgraph.svg" width="243" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab7f02155bc2945a0a0c82c1be5cad041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f02155bc2945a0a0c82c1be5cad041">&#9670;&nbsp;</a></span>maxdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; tk::maxdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the maximum difference between the elements of two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index, i.e., the raw position, of and the largest absolute value of the difference between all corresponding elements of <em>lhs</em> and <em>rhs</em>.</dd></dl>
<p>The position returned is the position in the underlying raw data structure, independent of components, offsets, etc. If lhs == rhs with precision std::numeric_limits&lt; tk::real &gt;::epsilon(), a pair of (0,0.0) is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>lhs</em> and <em>rhs</em> must have the same number of unknowns and properties. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00638">638</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_data_8h_source.html#l00266">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00186">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00181">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00173">inciter::FluxCorrector::verify()</a>.</p>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                                                                {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( lhs.nunk() == rhs.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( lhs.nprop() == rhs.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  <span class="keyword">auto</span> l = lhs.data().cbegin();</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="keyword">auto</span> r = rhs.data().cbegin();</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  std::pair&lt; std::size_t, tk::real &gt; m( 0, std::abs(*l - *r) );</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  ++l; ++r;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  <span class="keywordflow">while</span> (l != lhs.data().cend()) {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> d = std::abs(*l - *r);</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    <span class="keywordflow">if</span> (d &gt; m.second) m = { std::distance(lhs.data().cbegin(),l), d };</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    ++l; ++r;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  }</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="keywordflow">return</span> m;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab7f02155bc2945a0a0c82c1be5cad041_cgraph.svg" width="264" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac371117af5d2009dca83a8cb5539a43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371117af5d2009dca83a8cb5539a43f">&#9670;&nbsp;</a></span>mergeHashMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg* tk::mergeHashMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized maps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated std::unordered_maps built for further aggregation if needed</dd></dl>
<p>During aggregation the map keys are inserted, i.e., the keys remain unique and the mapped values, assuming containers defining begin() and end() iterators() are concatenated. </p><dl class="section note"><dt>Note</dt><dd>The mapped type must be a container, i.e., must provide iterators begin() and end(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="_hash_map_reducer_8h_source.html#l00061">61</a> of file <a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00029">serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_solver_8_c_source.html#l00117">tk::Solver::registerReducers()</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                                {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// Will store deserialized map</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; p;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// Deserialize map from raw stream</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  creator | p;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// Unpack map</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; u;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    curCreator | u;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// Concatenate maps</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : u) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      <span class="keyword">auto</span>&amp; b = p[ c.first ];</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      b.insert( end(b), begin(c.second), end(c.second) );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  }</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// Serialize concatenated maps to raw stream</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( p );</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="comment">// Forward serialized hash map</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00029">HashMapReducer.h:29</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac371117af5d2009dca83a8cb5539a43f_cgraph.svg" width="294" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab8753a2df233c9b1327d5682940ddcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8753a2df233c9b1327d5682940ddcbf">&#9670;&nbsp;</a></span>mergePDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg * tk::mergePDF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging PDFs during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized PDFs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated PDFs built for further aggregation if needed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00106">106</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00029">serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_collector_8h_source.html#l00084">walker::Collector::registerPDFMerger()</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;{</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="comment">// Will store deserialized uni-, bi-, and tri-variate PDFs</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  std::vector&lt; tk::UniPDF &gt; updf;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  std::vector&lt; tk::BiPDF &gt; bpdf;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  std::vector&lt; tk::TriPDF &gt; tpdf;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="comment">// Deserialize PDFs from raw stream</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  creator | updf;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  creator | bpdf;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  creator | tpdf;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// Unpack PDFs</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    std::vector&lt; tk::UniPDF &gt; u;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    std::vector&lt; tk::BiPDF &gt; b;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    std::vector&lt; tk::TriPDF &gt; t;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    curCreator | u;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    curCreator | b;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    curCreator | t;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">// Merge PDFs</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    std::size_t i = 0;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : u) updf[i++].addPDF( p );</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    i = 0;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : b) bpdf[i++].addPDF( p );</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    i = 0;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : t) tpdf[i++].addPDF( p );</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// Serialize vector of merged PDFs to raw stream</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( updf, bpdf, tpdf );</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// Forward serialized PDFs</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00029">HashMapReducer.h:29</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab8753a2df233c9b1327d5682940ddcbf_cgraph.svg" width="259" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a24204b4ddfb41147330f02a8e6e7b760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24204b4ddfb41147330f02a8e6e7b760">&#9670;&nbsp;</a></span>mergeUniPDFs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg * tk::mergeUniPDFs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging a univariate PDF during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized PDF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated PDF built for further aggregation if needed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00039">39</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00029">serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_discretization_8_c_source.html#l00128">inciter::Discretization::registerReducers()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="comment">// Will store deserialized univariate PDFs</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  std::vector&lt; tk::UniPDF &gt; updf;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="comment">// Deserialize PDFs from raw stream</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  creator | updf;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// Unpack PDF</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::vector&lt; tk::UniPDF &gt; u;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    curCreator | u;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="comment">// Merge PDFs</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    std::size_t i = 0;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : u) updf[i++].addPDF( p );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  }</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// Serialize vector of merged PDF to raw stream</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( updf );</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="comment">// Forward serialized PDFs</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00029">HashMapReducer.h:29</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a24204b4ddfb41147330f02a8e6e7b760_cgraph.svg" width="286" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adb0ded68a9723df3debe38af3634e139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0ded68a9723df3debe38af3634e139">&#9670;&nbsp;</a></span>mergeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg * tk::mergeVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging std::vectors during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated std::vectors built for further aggregation if needed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_vector_reducer_8_c_source.html#l00041">41</a> of file <a class="el" href="_vector_reducer_8_c_source.html">VectorReducer.C</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00029">serialize()</a>, and <a class="el" href="_container_util_8h_source.html#l00023">unique()</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="comment">// Will store deserialized vector</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  std::vector&lt; std::size_t &gt; v;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// Deserialize vector from raw stream</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  creator | v;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="comment">// Unpack vector</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    std::vector&lt; std::size_t &gt; u;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    curCreator | u;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="comment">// Concatenate vector and make it unique</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    v.insert( end(v), begin(u), end(u) );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( v );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  }</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// Serialize concatenated vectors to raw stream</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( v );</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="comment">// Forward serialized vector</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00023">ContainerUtil.h:23</a></div></div>
<div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00029">HashMapReducer.h:29</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_adb0ded68a9723df3debe38af3634e139_cgraph.svg" width="275" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afd730d099e698f124362ef8c01483e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd730d099e698f124362ef8c01483e0f">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; tk::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator min between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object containing the minimum of all values for each value in <em>a</em> and <em>b</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties. </dd>
<dd>
As opposed to std::min, this function creates and returns a new object instead of returning a reference to one of the operands. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00568">568</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_data_8h_source.html#l00266">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00186">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00181">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="node__connectivity_8h_source.html#l00130">AMR::node_connectivity_t::add()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00027">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00338">inciter::FluxCorrector::alw()</a>, <a class="el" href="_p_d_f_writer_8h_source.html#l00084">tk::PDFWriter::assertSampleSpaceExtents()</a>, <a class="el" href="_c_g_transport_8h_source.html#l00303">inciter::cg::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00328">inciter::cg::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="edge_8h_source.html#l00025">edge_t::edge_t()</a>, <a class="el" href="_timer_8_c_source.html#l00041">tk::Timer::eta()</a>, <a class="el" href="_p_d_f_writer_8_c_source.html#l01170">tk::PDFWriter::extents()</a>, <a class="el" href="node__connectivity_8h_source.html#l00112">AMR::node_connectivity_t::find()</a>, <a class="el" href="_tracker_8_c_source.html#l00022">tk::Tracker::genpar()</a>, <a class="el" href="_diff_eq_2_init_policy_8h_source.html#l00116">walker::InitDelta::init()</a>, <a class="el" href="_diff_eq_2_init_policy_8h_source.html#l00159">walker::InitBeta::init()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00388">inciter::FluxCorrector::lim()</a>, <a class="el" href="_tracker_8_c_source.html#l00105">tk::Tracker::parinel()</a>, <a class="el" href="_slot_cyl_8h_source.html#l00042">inciter::TransportProblemSlotCyl::solution()</a>, <a class="el" href="_discretization_8_c_source.html#l00263">inciter::Discretization::stat()</a>, and <a class="el" href="_p_d_f_writer_8_c_source.html#l00049">tk::PDFWriter::writeTxt()</a>.</p>
<div class="fragment"><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                                                                       {</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nunk() == b.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nprop() == b.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  Data&lt; Layout &gt; r( a.nunk(), a.nprop() );</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  std::transform( a.data().cbegin(), a.data().cend(),</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                  b.data().cbegin(), r.data().begin(),</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                  []( <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> s, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d ){ <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">std::min</a>(s,d); } );</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;}</div><div class="ttc" id="namespacetk_html_afd730d099e698f124362ef8c01483e0f"><div class="ttname"><a href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">tk::min</a></div><div class="ttdeci">Data&lt; Layout &gt; min(const Data&lt; Layout &gt; &amp;a, const Data&lt; Layout &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_data_8h_source.html#l00568">Data.h:568</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_afd730d099e698f124362ef8c01483e0f_cgraph.svg" width="240" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aae5766a4d0dae70d561c514f2758072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5766a4d0dae70d561c514f2758072e">&#9670;&nbsp;</a></span>nodegrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, 3 &gt; tk::nodegrad </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tk::Fields &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4">ncomp_t</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient at a mesh node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node id at which to compute gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coord</td><td>Mesh node coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Mesh element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Linked lists storing elements surrounding points, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>Field vector whose component gradient to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Scalar component to compute gradient of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gradient of U(c) at mesh node </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gradients_8_c_source.html#l00018">18</a> of file <a class="el" href="_gradients_8_c_source.html">Gradients.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_base_2_vector_8h_source.html#l00033">crossdiv()</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00062">triple()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_error_8_c_source.html#l00076">AMR::Error::error_hessian()</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;{</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( c &lt; U.nprop(), <span class="stringliteral">&quot;Indexing out of field data&quot;</span> );</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = coord[0];</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; y = coord[1];</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; z = coord[2];</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="comment">// storage for gradient and volume at the mesh node</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  std::array&lt; tk::real, 3 &gt; g{{ 0.0, 0.0, 0.0 }};</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> vol = 0.0;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="comment">// loop over cells surrounding mesh node</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> k=esup.second[node]+1; k&lt;=esup.second[node+1]; ++k) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;     <span class="comment">// access element id</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;     <span class="keyword">auto</span> e = esup.first[k];</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;     <span class="comment">// access node IDs</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;     <span class="keyword">const</span> std::array&lt; std::size_t, 4 &gt; N{{ inpoel[e*4+0], inpoel[e*4+1],</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                                            inpoel[e*4+2], inpoel[e*4+3] }};</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;     <span class="comment">// compute element Jacobi determinant</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;     <span class="keyword">const</span> std::array&lt; tk::real, 3 &gt;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;       ba{{ x[N[1]]-x[N[0]], y[N[1]]-y[N[0]], z[N[1]]-z[N[0]] }},</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;       ca{{ x[N[2]]-x[N[0]], y[N[2]]-y[N[0]], z[N[2]]-z[N[0]] }},</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;       da{{ x[N[3]]-x[N[0]], y[N[3]]-y[N[0]], z[N[3]]-z[N[0]] }};</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;     <span class="keyword">const</span> <span class="keyword">auto</span> J = <a class="code" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a>( ba, ca, da );        <span class="comment">// J = 6V</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;     <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( J &gt; 0, <span class="stringliteral">&quot;Element Jacobian non-positive&quot;</span> );</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;     <span class="comment">// shape function derivatives, nnode*ndim [4][3]</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;     std::array&lt; std::array&lt; tk::real, 3 &gt;, 4 &gt; grad;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;     grad[1] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( ca, da, J );</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;     grad[2] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( da, ba, J );</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;     grad[3] = <a class="code" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a>( ba, ca, J );</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;     <span class="keywordflow">for</span> (std::size_t i=0; i&lt;3; ++i)</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;       grad[0][i] = -grad[1][i]-grad[2][i]-grad[3][i];</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;     <span class="comment">// access field data for scalar component c at nodes of element</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;     <span class="keyword">auto</span> u = U.extract( c, 0, N );</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;     <span class="comment">// compute nodal volume: every element contributes their volume / 4</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;     vol += 5.0*J/120.0;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;     <span class="comment">// compute gradient over element weighed by cell volume / 4 and sum to node</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;     <span class="keywordflow">for</span> (std::size_t j=0; j&lt;3; ++j) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;       <span class="keywordflow">for</span> (std::size_t i=0; i&lt;4; ++i) {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;         g[j] += grad[i][j] * u[i] * 5.0*J/120.0;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;       }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;     }</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   <span class="comment">// divide components of nodal gradient by nodal volume</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   <span class="keywordflow">for</span> (std::size_t j=0; j&lt;3; ++j) g[j] /= vol;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   <span class="keywordflow">return</span> g;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;}</div><div class="ttc" id="namespacetk_html_a77ef9600b5075a8bbee89b6e4991fd69"><div class="ttname"><a href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a></div><div class="ttdeci">std::array&lt; T, 3 &gt; crossdiv(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00033">Vector.h:33</a></div></div>
<div class="ttc" id="namespacetk_html_ae5b04b00aa51667b944b7188545ec5ae"><div class="ttname"><a href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a></div><div class="ttdeci">T triple(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00062">Vector.h:62</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_aae5766a4d0dae70d561c514f2758072e_cgraph.svg" width="382" height="108"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abdd71f3e10edf6e1a8d047478abd488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd71f3e10edf6e1a8d047478abd488c">&#9670;&nbsp;</a></span>npoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::npoin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute number of points (nodes) in mesh from connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of mesh points (nodes) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00028">28</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_derived_data_8_c_source.html#l00219">genEdsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00709">genEsued()</a>, <a class="el" href="_derived_data_8_c_source.html#l00933">genEsuelTet()</a>, <a class="el" href="_derived_data_8_c_source.html#l00041">genEsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00589">genInedel()</a>, <a class="el" href="_derived_data_8_c_source.html#l00322">genInpoed()</a>, <a class="el" href="_derived_data_8_c_source.html#l00124">genPsup()</a>, <a class="el" href="_partitioner_8_c_source.html#l00958">inciter::Partitioner::refine()</a>, <a class="el" href="_reorder_8_c_source.html#l00099">renumber()</a>, and <a class="el" href="_test_error_8h_source.html#l00115">tut::AMRError_common::TestErrorIndicator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">return</span> *minmax.second + 1;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac38f5055c45cd35b8ce00151cea4c1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38f5055c45cd35b8ce00151cea4c1d3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator != between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries are unequal up to epsilon </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00622">622</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;{ <span class="keywordflow">return</span> !(lhs == rhs); }</div></div><!-- fragment -->
</div>
</div>
<a id="adc362fc7a89c617e1ab8f57f1dbd100a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc362fc7a89c617e1ab8f57f1dbd100a">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; tk::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator * multiplying all items by a scalar from the left </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Scalar to multiply with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Date object to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object with all items multipled with lhs </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00554">554</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                                                                   {</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="keywordflow">return</span> Data&lt; Layout &gt;( rhs ) *= lhs;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad47c993218d9384828fcce2794850ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47c993218d9384828fcce2794850ac7">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T, Allocator &gt;&amp; tk::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all elements of a vector to another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>Destination vector, i.e., left-hand side of v1 += v2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source vector, i.e., righ-hand side of v1 += v2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destination containing v1[0] += v2[0], v1[1] += v2[1], ...</dd></dl>
<p>If src.size() &gt; dst.size() will grow dst to that of src.size() padding with zeros. </p><dl class="section note"><dt>Note</dt><dd>Will throw exception in DEBUG if src is empty (to warn on no-op), and if src.size() &lt; dst.size() (to warn on loosing data). </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00102">102</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;{</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !src.empty(), <span class="stringliteral">&quot;src empty in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( src.size() &gt;= dst.size(), <span class="stringliteral">&quot;src.size() &lt; dst.size() would loose data &quot;</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          <span class="stringliteral">&quot;in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> );</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  dst.resize( src.size() );</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  std::transform( src.begin(), src.end(), dst.begin(), dst.begin(),</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                  []( <span class="keyword">const</span> T&amp; s, T&amp; d ){ <span class="keywordflow">return</span> d += s; } );</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="keywordflow">return</span> dst;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bbb9b08d37f6f5f3bed45effc8fc64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbb9b08d37f6f5f3bed45effc8fc64e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt;&amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for writing std::vector&lt; T &gt; to output streams; for debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>std::vector of arbitrary type T to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00036">36</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                                                                       {</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : t) os &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;&#39; s:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aabd06aee13370660ff0109b8f8b1958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd06aee13370660ff0109b8f8b1958e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt; &amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for writing enum class value to output streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of enum class to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream for chain-use of the operator</dd></dl>
<p>Delegate operator &lt;&lt; to default for writing non-enums to output streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which t is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Value of arbitrary non-enum-class type to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream for chain-use of the operator </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00023">23</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                                                          {</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  os &lt;&lt; static_cast&lt; unsigned int &gt;( e );</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7adfa2dfb8b3a38f60ac0edf5666b6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for rvalues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated string </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00059">59</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                                           {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">return</span> lhs &lt;&lt; e;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa160d13ea2e4a3498916472c3b6cdbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160d13ea2e4a3498916472c3b6cdbb0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for lvalues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated string </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00046">46</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                                                          {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  std::stringstream ss;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  ss &lt;&lt; lhs &lt;&lt; e;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  lhs = ss.str();</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="keywordflow">return</span> lhs;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac0a63cccd84b6bd8b998cb4282adac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a63cccd84b6bd8b998cb4282adac23">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::ostream&amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output univariate PDF to output stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>Stream to output to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>PDF to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated stream </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used for debugging. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_uni_p_d_f_8h_source.html#l00121">121</a> of file <a class="el" href="_uni_p_d_f_8h_source.html">UniPDF.h</a>.</p>

<p class="reference">References <a class="el" href="_uni_p_d_f_8h_source.html#l00083">tk::UniPDF::binsize()</a>, <a class="el" href="_uni_p_d_f_8h_source.html#l00079">tk::UniPDF::map()</a>, and <a class="el" href="_uni_p_d_f_8h_source.html#l00056">tk::UniPDF::nsample()</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                                                             {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  os &lt;&lt; p.<a class="code" href="classtk_1_1_uni_p_d_f.html#a83519a7b7b48c14694c5d683218d3419">binsize</a>() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; p.<a class="code" href="classtk_1_1_uni_p_d_f.html#af0075606b7c787a66c9fade95f22ecb6">nsample</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  std::map&lt; typename tk::UniPDF::key_type, tk::real &gt;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    sorted( p.<a class="code" href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">map</a>().begin(), p.<a class="code" href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">map</a>().end() );</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : sorted) os &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; b.first &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; b.second &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div><div class="ttc" id="classtk_1_1_uni_p_d_f_html_a83519a7b7b48c14694c5d683218d3419"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#a83519a7b7b48c14694c5d683218d3419">tk::UniPDF::binsize</a></div><div class="ttdeci">tk::real binsize() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00083">UniPDF.h:83</a></div></div>
<div class="ttc" id="classtk_1_1_uni_p_d_f_html_af0075606b7c787a66c9fade95f22ecb6"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#af0075606b7c787a66c9fade95f22ecb6">tk::UniPDF::nsample</a></div><div class="ttdeci">std::size_t nsample() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00056">UniPDF.h:56</a></div></div>
<div class="ttc" id="classtk_1_1_uni_p_d_f_html_ae3cc1ee45721ada30dcc808c227e179a"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">tk::UniPDF::map</a></div><div class="ttdeci">const map_type &amp; map() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00079">UniPDF.h:79</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac0a63cccd84b6bd8b998cb4282adac23_cgraph.svg" width="323" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a21669e4d06c62a58cd0f4bf63868ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21669e4d06c62a58cd0f4bf63868ab7e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator == between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries are equal up to epsilon </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00604">604</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_data_8h_source.html#l00266">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00186">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00181">tk::Data&lt; Layout &gt;::nunk()</a>.</p>
<div class="fragment"><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                                                                         {</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( rhs.nunk() == lhs.nunk(), <span class="stringliteral">&quot;Incorrect number of unknowns&quot;</span> );</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( rhs.nprop() == lhs.nprop(), <span class="stringliteral">&quot;Incorrect number of properties&quot;</span> );</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  <span class="keyword">auto</span> l = lhs.data().cbegin();</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;  <span class="keyword">auto</span> r = rhs.data().cbegin();</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  <span class="keywordflow">while</span> (l != lhs.data().cend()) {</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <span class="keywordflow">if</span> (std::abs(*l - *r) &gt; std::numeric_limits&lt; tk::real &gt;::epsilon())</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;     <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    ++l; ++r;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  }</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a21669e4d06c62a58cd0f4bf63868ab7e_cgraph.svg" width="294" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a64b09f52ea3b4314e449e70255837836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b09f52ea3b4314e449e70255837836">&#9670;&nbsp;</a></span>pickOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a> tk::pickOutput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine output mesh file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to pick its type based on extension given </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum specifying the mesh writer type </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00066">66</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, and <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;{</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="comment">// Get extension of input file name</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  std::string fn = filename;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  std::string ext( fn.substr(fn.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1) );</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;msh&quot;</span> ) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> MeshWriter::GMSH;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;exo&quot;</span> || ext == <span class="stringliteral">&quot;h5&quot;</span> ) {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">return</span> MeshWriter::EXODUSII;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;mesh&quot;</span> ) {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">return</span> MeshWriter::NETGEN;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Output mesh file type could not be determined from extension of &quot;</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;           <span class="stringliteral">&quot;filename &#39;&quot;</span> + filename + <span class="stringliteral">&quot;&#39;; valid extensions are: &quot;</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;           <span class="stringliteral">&quot;&#39;msh&#39; for Gmsh, &#39;exo&#39; or &#39;h5&#39; for ExodusII, &#39;mesh&#39; for Netgen&#39;s &quot;</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;           <span class="stringliteral">&quot;neutral&quot;</span> );</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abcbeb1245c469101fb0f280aa51fe0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbeb1245c469101fb0f280aa51fe0c9">&#9670;&nbsp;</a></span>poinCommMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; tk::poinCommMaps </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>graphsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>toofine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-based communication maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graphsize</td><td>Size of unstructured mesh graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toofine</td><td>Error message to print triggered for too large overdecomposition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point-based communication map for all chares</dd></dl>
<p>This is a <em>point-based</em> export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns a mesh point. This is for algorithms that work by computing data on the mesh by looping over mesh points and their surrounding points, e.g., edge-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p><dl class="section note"><dt>Note</dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_comm_map_8_c_source.html#l00027">27</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>, <a class="el" href="_exception_8h_source.html#l00054">ErrChk</a>, <a class="el" href="_derived_data_8_c_source.html#l00041">genEsup()</a>, and <a class="el" href="_derived_data_8_c_source.html#l00124">genPsup()</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;{</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// unique global point ids sent (export map)</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  std::map&lt; std::size_t,</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <span class="comment">// Generate points surrounding points</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a>( tetinpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>(tetinpoel,4) );</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="comment">// Construct point-based export maps</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;graphsize; ++p)  <span class="comment">// for all mesh points</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i) {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      <span class="keyword">auto</span> q = psup.first[i];</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <span class="keywordflow">if</span> (chp[p] != chp[q])   <span class="comment">// if the point-colors differ, store global id</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        comm[ chp[p] ][ chp[q] ].insert( p );</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="comment">// This check should always be done, as it can result from incorrect user</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="comment">// input compared to the mesh size and not due to programmer error.</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <a class="code" href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f">ErrChk</a>( comm.size() == nchare, std::move(toofine) );</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="preprocessor">  #ifndef NDEBUG</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  std::size_t c = 0;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( e.first == c++,</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="stringliteral">&quot;Export/import maps should not be missing for chare id &quot;</span> +</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            std::to_string(c-1) );</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="comment">// Construct final product: a vector of export maps associating receiver</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    pcomm( nchare );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm) {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        pcomm[ e.first ][ x.first ].push_back( p );</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( pcomm.size() == nchare,</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;          <span class="stringliteral">&quot;Number of export/import maps must equal the number of chares&quot;</span> );</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">//   std::size_t h = 0;</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">//   for (const auto&amp; m : pcomm) {</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; p-&gt; &quot;;</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">//     for (const auto&amp; x : m) {</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">//       for (auto p : x.second)</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keywordflow">return</span> pcomm;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;}</div><div class="ttc" id="namespacetk_html_ad2a88a65102c17149b44660db15d445b"><div class="ttname"><a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genPsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</div><div class="ttdoc">Generate derived data structure, points surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00124">DerivedData.C:124</a></div></div>
<div class="ttc" id="_exception_8h_html_ac75cd6578896829d2bfbccf5de71de4f"><div class="ttname"><a href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f">ErrChk</a></div><div class="ttdeci">#define ErrChk(expr,...)</div><div class="ttdoc">ErrChk macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00054">Exception.h:54</a></div></div>
<div class="ttc" id="namespacetk_html_a66a2889d5d8aeb4a836842c6a1010463"><div class="ttname"><a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genEsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</div><div class="ttdoc">Generate derived data structure, elements surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00041">DerivedData.C:41</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_abcbeb1245c469101fb0f280aa51fe0c9_cgraph.svg" width="424" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af04df49334286e653e440035c499a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04df49334286e653e440035c499a8d1">&#9670;&nbsp;</a></span>processExceptionCharm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::processExceptionCharm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an exception from the Charm++ runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00087">87</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8_c_source.html#l00170">tk::Exception::handleException()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_file_conv_8_c_source.html#l00092">Main::execute()</a>, <a class="el" href="_file_conv_8_c_source.html#l00099">Main::finalize()</a>, <a class="el" href="_file_conv_8_c_source.html#l00063">Main::Main()</a>, and <a class="el" href="_file_conv_8_c_source.html#l00110">Main::timestamp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;{</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">try</span> {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  }</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="comment">// Catch tk::Exception</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html">tk::Exception</a>&amp; qe ) {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  }</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="comment">// file:line:func information</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( se.what() );</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  }</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// Catch uncaught exception</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Tell the runtime system to exit with a message</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  CkAbort( <span class="stringliteral">&quot;Exception caught&quot;</span> );</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div><div class="ttc" id="classtk_1_1_exception_html"><div class="ttname"><a href="classtk_1_1_exception.html">tk::Exception</a></div><div class="ttdoc">Basic exception class for producing file:func:line info + call trace. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00067">Exception.h:67</a></div></div>
<div class="ttc" id="classtk_1_1_exception_html_aef3989f5d076c0282329daa2a646b1c6"><div class="ttname"><a href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">tk::Exception::handleException</a></div><div class="ttdeci">virtual ErrCode handleException() noexcept</div><div class="ttdoc">Handle Exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8_c_source.html#l00170">Exception.C:170</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_af04df49334286e653e440035c499a8d1_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a2a62b5b6880fbd0a011cedf8896b19dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a62b5b6880fbd0a011cedf8896b19dc">&#9670;&nbsp;</a></span>processExceptionMPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::processExceptionMPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an exception from the MPI runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00118">118</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00059">FAILURE</a>, and <a class="el" href="_exception_8_c_source.html#l00170">tk::Exception::handleException()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_unit_test_8_c_source.html#l00287">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;{</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordtype">int</span> peid;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic push</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  MPI_Comm_rank( MPI_COMM_WORLD, &amp;peid );  </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic pop</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="keywordflow">try</span> {</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="comment">// Catch tk::Exception</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html">tk::Exception</a>&amp; qe ) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="comment">// file:line:func information</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( se.what() );</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  }</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">// Catch uncaught exception</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic push</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="comment">// Tell the runtime system to exit with error code</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  MPI_Abort( MPI_COMM_WORLD, <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::ErrCode::FAILURE</a> );</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic pop</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div><div class="ttc" id="classtk_1_1_exception_html"><div class="ttname"><a href="classtk_1_1_exception.html">tk::Exception</a></div><div class="ttdoc">Basic exception class for producing file:func:line info + call trace. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00067">Exception.h:67</a></div></div>
<div class="ttc" id="classtk_1_1_exception_html_aef3989f5d076c0282329daa2a646b1c6"><div class="ttname"><a href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">tk::Exception::handleException</a></div><div class="ttdeci">virtual ErrCode handleException() noexcept</div><div class="ttdoc">Handle Exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8_c_source.html#l00170">Exception.C:170</a></div></div>
<div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::FAILURE</a></div><div class="ttdoc">Exceptions occurred. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00059">Exception.h:59</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a2a62b5b6880fbd0a011cedf8896b19dc_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="af947865970b76333655208aea71ceb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af947865970b76333655208aea71ceb71">&#9670;&nbsp;</a></span>readUnsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> tk::readUnsMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unstructured mesh from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to read mesh from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>A time stamp consisting of a timer label (a string), and a time state (a <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" title="Real number type used throughout the whole code. ">tk::real</a> in seconds) measuring the mesh read time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unstructured mesh object </dd></dl>
<p>Create unstructured mesh to store mesh </p>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00092">92</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ac6e421eaad140c1bc1a39980502df80c">ASC</a>, <a class="el" href="_mesh_factory_8_c_source.html#l00031">detectInput()</a>, <a class="el" href="_print_8h_source.html#l00302">tk::Print::diagend()</a>, <a class="el" href="_print_8h_source.html#l00296">tk::Print::diagstart()</a>, <a class="el" href="_timer_8h_source.html#l00063">tk::Timer::dsec()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">tut::ExodusIIMeshReader()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a74f67c0302d5888253dce0a5e2462ade">HYPER</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00025">tk::NetgenMeshReader::readMesh()</a>, <a class="el" href="_hyper_mesh_reader_8_c_source.html#l00024">tk::HyperMeshReader::readMesh()</a>, <a class="el" href="_a_s_c_mesh_reader_8_c_source.html#l00053">tk::ASCMeshReader::readMesh()</a>, and <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00029">tk::GmshMeshReader::readMesh()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00043">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;{</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Reading mesh from file ...&quot;</span> );</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="comment">// Read in mesh</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; <span class="comment"></span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">  //! Create unstructured mesh to store mesh</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"></span>  UnsMesh mesh;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">detectInput</a>( filename );</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keywordflow">if</span> (meshtype == MeshReader::GMSH)</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    GmshMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::NETGEN)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    NetgenMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::EXODUSII)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <a class="code" href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">ExodusIIMeshReader</a>( filename ).readMesh( mesh );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::ASC)</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    ASCMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::HYPER)</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    HyperMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  timestamp = std::make_pair( <span class="stringliteral">&quot;Read mesh from file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="comment">// Return (move out) mesh object</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keywordflow">return</span> mesh;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div><div class="ttc" id="classtk_1_1_timer_html"><div class="ttname"><a href="classtk_1_1_timer.html">tk::Timer</a></div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00028">Timer.h:28</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a569d68d17038fa38b83d5bb229500c40"><div class="ttname"><a href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">tk::Timer::dsec</a></div><div class="ttdeci">real dsec() const</div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00063">Timer.h:63</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_a9a3bb2dc7c5ea1d979dcec5528c37a66"><div class="ttname"><a href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">tk::Print::diagend</a></div><div class="ttdeci">void diagend(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00302">Print.h:302</a></div></div>
<div class="ttc" id="namespacetut_html_a88f40e8bb56ea7c640a69bb6a75fa769"><div class="ttname"><a href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">tut::ExodusIIMeshReader</a></div><div class="ttdeci">static ExodusIIMeshReader_group ExodusIIMeshReader(&quot;IO/ExodusIIMeshReader&quot;)</div><div class="ttdoc">Define test group. </div></div>
<div class="ttc" id="classtk_1_1_print_html_ae1f93831127fb7d45c33ad3cdf3604fd"><div class="ttname"><a href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">tk::Print::diagstart</a></div><div class="ttdeci">void diagstart(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00296">Print.h:296</a></div></div>
<div class="ttc" id="namespacetk_html_a08e7ddf794b944c7d2095c1222f4244a"><div class="ttname"><a href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">tk::detectInput</a></div><div class="ttdeci">MeshReader detectInput(const std::string &amp;filename)</div><div class="ttdoc">Detect input mesh file type. </div><div class="ttdef"><b>Definition:</b> <a href="_mesh_factory_8_c_source.html#l00031">MeshFactory.C:31</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_af947865970b76333655208aea71ceb71_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ad986ef5558d44d5e0c6650c589499980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad986ef5558d44d5e0c6650c589499980">&#9670;&nbsp;</a></span>record()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::record </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstructorArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register class into factory with given key. This is used to register a derived-class object's constructor (deriving from some base class) to a factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;, i.e., an associative container, associating some key to a std::function object holding a pointer of Child's base class constructor. The constructor and its bound arguments are stored via boost::factory, which, in this use-case, yields the correct function object of type Base constructor pointer and thus facilitates runtime polymorphism. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using reference semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by function instantiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00047">47</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                                                                     {</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  f.emplace( key,</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;             std::bind( boost::factory&lt; C* &gt;(),</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                        std::forward&lt; ConstructorArgs &gt;( args )... ) );</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ad986ef5558d44d5e0c6650c589499980_cgraph.svg" width="235" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4bd6374b4792dbd3c626dad60bcef168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6374b4792dbd3c626dad60bcef168">&#9670;&nbsp;</a></span>recordCharmModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordCharmModel </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register Charm++ model class of host into factory with given key. We bind a host constructor to its arguments of which the first one is a std::function holding a model constructor type (modeling, i.e., used polymorhically with host), followed by an optional number of others (possibly zero) with arbitrary types. Note that the model constructor is a nullptr (default- constructed) and only used to forward its type to the call site inside std::function. The host constructor function is then placed into the factory. This is because Charm++ chares do not explicitly invoke constructors, only call ckNew() on their proxy, which requires all constructor arguments to be present and forwarded to the actual constructor that is only called at a later point in time. This can then be used by those constructors of hosts that invoke the model constructors' proxies' ckNew() and ignore the std::function. See, e.g., <a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery()</a> and the associated unit tests in UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00177">177</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                                                                               {</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(),</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                             std::function&lt; ModelConstructor() &gt;(), <span class="comment">// nullptr</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                             std::forward&lt; ModelConstrArgs &gt;( args )...) );</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a24170c3146caaa7b79d78d4aa1d98f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24170c3146caaa7b79d78d4aa1d98f66">&#9670;&nbsp;</a></span>recordModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordModel </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register "model" class of "host" into factory with given key. This wrapper can be used to in a similar manner to 'record', but uses boost::value_factory to bind the model object constructor to its arguments and place it in the associative container storing host class objects. The container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e., associating a key to a function holding a constructor (and not its pointer). Runtime polymorphism here is realized entirely within the "base" class. See <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation. ">walker::DiffEq</a> in <a class="el" href="_diff_eq_2_diff_eq_8h.html" title="Differential equation. ">DiffEq/DiffEq.h</a> for an example and more information on runtime polymorphism without client-side inheritance. As a result, this wrapper works with factories that use value semantics, as opposed to 'record' and instantiate which work with reference semantics factories. In order to differentiate between runtime polymorphic classes using reference semantics, consistent with classes realizing runtime polymorphism without client-side inheritance, we call Host as the "Base" class and Model as the "derived" (or child) class. This wrapper function works in conjunction with boost::value_factory, i.e., uses value semantics (works with storing objects instead of object pointers). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using value semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by simply calling the function call operator () on the mapped value. For an example, <a class="el" href="classtk_1_1_r_n_g_stack.html#ab1c30742819f7c22826dcce8c620539f" title="Instantiate selected RNGs. ">RNGStack::selected()</a> in <a class="el" href="_r_n_g_stack_8_c.html" title="Stack of random number generators. ">RNG/RNGStack.C</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00108">108</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_r_n_g_stack_8_c_source.html#l00081">tk::RNGStack::selected()</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                                                                          {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// Bind model constructor to its arguments</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  std::function&lt; ModelConstructor() &gt; c =</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    std::bind( boost::value_factory&lt; ModelConstructor &gt;(),</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;               std::forward&lt; ModelConstrArgs &gt;( args )... );</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Bind host to std::function of model constructor and place in factory</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(), std::move(c) ) );</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a24170c3146caaa7b79d78d4aa1d98f66_cgraph.svg" width="272" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae98b4e55f14339c707622a8da43d8ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98b4e55f14339c707622a8da43d8ce9">&#9670;&nbsp;</a></span>recordModelLate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordModelLate </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArg&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register model class of host into factory with given key using late binding. This variant of 'record' is very similar to 'recordModel', but registers a model class constructor to a factory with late binding of the constructor argument. Late binding allows specifying the constructor argument at the time when the object is instantiated instead of at the time when it is registered. This has all the benefits of using a factory and allows passing information into the model object only when it is available. The late bind is facilitated via boost::bind instead of std::bind using a placeholder, _1, which stands for the first argument (bound later, i.e., not here). The value of the model constructor argument is then not used here, only its type, used to perform the late binding. The binding happens to both the model constructor via std::function (passed to the host constructor) as well as explicitly to the host constructor. Prescribing late binding to the model constructor ensures that the compiler requires the argument to the model constructor, i.e., ensures that the host constructor is required to pass the argument to the model constructor. Prescribing late binding to the host constructor puts in the actual request that an argument (with the correct type) must be passed to the host constructor at instantiate time, which then will forward it to the model constructor. See also, for example, <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation. ">walker::DiffEq</a>'s corresponding constructor. An example of client-side code is in <a class="el" href="structwalker_1_1_diff_eq_stack_1_1register_diff_eq.html" title="Function object for registering a differential equation into the differential equation factory...">walker::DiffEqStack::registerDiffEq</a> for registration into factory, and DiffEqStack::createDiffEq for instantiation late-passing the argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only works with a single constructor argument </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00145">145</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                                                                   {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="comment">// Prescribe late binding the model constructor to its single argument</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  std::function&lt; ModelConstructor(const ModelConstrArg&amp;) &gt; c =</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    boost::bind( boost::value_factory&lt; ModelConstructor &gt;(), boost::arg&lt;1&gt;() );</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">// Bind host to std::function of model constructor and place in factory and</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="comment">// also explicitly bind single model constructor argument to host constructor</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  f.emplace( key,</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    boost::bind( boost::value_factory&lt; Host &gt;(), std::move(c), boost::arg&lt;1&gt;() )</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  );</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ae98b4e55f14339c707622a8da43d8ce9_cgraph.svg" width="299" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab2aac5f0fd93d5119cfe50a39f3515c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aac5f0fd93d5119cfe50a39f3515c9">&#9670;&nbsp;</a></span>ref_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::ref_find </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Container::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename Container::mapped_type&amp;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00053">53</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00037">cref_find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_test_timer_8h_source.html#l00155">tut::CharmTimer::CharmTimer()</a>, <a class="el" href="_d_g_8_c_source.html#l00251">inciter::DG::comfac()</a>, <a class="el" href="_solver_8_c_source.html#l00735">tk::Solver::lhsbc()</a>, <a class="el" href="_solver_8_c_source.html#l01064">tk::Solver::lowsolve()</a>, <a class="el" href="_partitioner_8_c_source.html#l00439">inciter::Partitioner::mask()</a>, <a class="el" href="_partitioner_8_c_source.html#l01049">inciter::Partitioner::reordered()</a>, and <a class="el" href="_solver_8_c_source.html#l00837">tk::Solver::rhsbc()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> typename Container::mapped_type&amp; <span class="keyword">&gt;</span>( <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">cref_find</a>(map,key) );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div><div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00037">ContainerUtil.h:37</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab2aac5f0fd93d5119cfe50a39f3515c9_cgraph.svg" width="243" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a261ac7b3e006f7fa6621ad910b6553cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261ac7b3e006f7fa6621ad910b6553cc">&#9670;&nbsp;</a></span>remap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::remap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply new mapping to vector of indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">id</td><td>Vector of integer IDs to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Array of indices creating a new order</td></tr>
  </table>
  </dd>
</dl>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed between the array index ands its value. The function overwrites every value, i, of vector id with map[i]. </p><dl class="section note"><dt>Note</dt><dd>The sizes of id and map need not equal. Only the maximum index in id must be lower than the size of map. </dd>
<dd>
It is okay to call this function with either of the containers empty; it will simply return without throwing an exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00047">47</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.empty() || map.empty()) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *max_element( begin(<span class="keywordtype">id</span>), end(<span class="keywordtype">id</span>) ) &lt; map.size(),</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;          <span class="stringliteral">&quot;Indexing out of bounds&quot;</span> );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// remap integer IDs in vector id</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; i : <span class="keywordtype">id</span>) i = map[i];</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af808bcf55ee4b5e910f68ecb0fe2f8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd">&#9670;&nbsp;</a></span>remap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::remap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply new mapping to vector of real numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r</td><td>Vector of real numbers to remap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Array of indices creating a new order</td></tr>
  </table>
  </dd>
</dl>
<p>This function applies a mapping (reordering) to the real values passed in using the map passed in. The mapping is expressed between the array index ands its value. The function moves every value r[i] to r[ map[i] ]. </p><dl class="section note"><dt>Note</dt><dd>The sizes of r and map must be equal and the maximum index in map must be lower than the size of map. </dd>
<dd>
It is okay to call this function with either of the containers empty; it will simply return without throwing an exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00072">72</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;{</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">if</span> (r.empty() || map.empty()) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( r.size() == map.size(), <span class="stringliteral">&quot;Size mismatch&quot;</span> );</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *max_element( begin(map), end(map) ) &lt; map.size(),</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;          <span class="stringliteral">&quot;Indexing out of bounds&quot;</span> );</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// remap real numbers in vector</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keyword">auto</span> m = r;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;map.size(); ++i) r[ map[i] ] = m[i];</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a22a8b455edb4f8453d5a6173319f9c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a8b455edb4f8453d5a6173319f9c80">&#9670;&nbsp;</a></span>renumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::renumber </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder mesh points with the advancing front technique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psup</td><td>Points surrounding points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mapping created by renumbering (reordering) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00099">99</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_derived_data_8_c_source.html#l00028">npoin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;{</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// Find out number of nodes in graph</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="keyword">auto</span> <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a> = psup.second.size()-1;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// Construct mapping using advancing front</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  std::vector&lt; int &gt; hpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, -1 ), lpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  std::vector&lt; std::size_t &gt; map( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, 0 );</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  hpoin[0] = 0;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  lpoin[0] = 1;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  std::size_t num = 1;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">while</span> (num &lt; <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>) {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    std::size_t cnt = 0;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    std::size_t i = 0;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    std::vector&lt; int &gt; kpoin( <a class="code" href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">npoin</a>, -1 );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="keywordtype">int</span> p;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">while</span> ((p = hpoin[i]) != -1) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      ++i;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      <span class="keyword">auto</span> P = <span class="keyword">static_cast&lt;</span> std::size_t <span class="keyword">&gt;</span>( p );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=psup.second[P]+1; j&lt;=psup.second[P+1]; ++j) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keyword">auto</span> q = psup.first[j];</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">if</span> (lpoin[q] != 1) {    <span class="comment">// consider points not yet counted</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          map[q] = num++;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          kpoin[cnt] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>( q ); <span class="comment">// register point as counted</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;          lpoin[q] = 1;                         <span class="comment">// register the point as counted</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;          ++cnt;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        }</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      }</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    }</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    hpoin = kpoin;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">//   // Construct new-&gt;old id map</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">//   std::size_t i = 0;</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">//   std::vector&lt; std::size_t &gt; oldmap( npoin );</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">//   for (auto n : map) oldmap[n] = i++;</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">// Return old-&gt;new and new-&gt;old maps</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="keywordflow">return</span> map;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div><div class="ttc" id="namespacetk_html_abdd71f3e10edf6e1a8d047478abd488c"><div class="ttname"><a href="namespacetk.html#abdd71f3e10edf6e1a8d047478abd488c">tk::npoin</a></div><div class="ttdeci">std::size_t npoin(const std::vector&lt; std::size_t &gt; &amp;inpoel)</div><div class="ttdoc">Compute number of points (nodes) in mesh from connectivity. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00028">DerivedData.C:28</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a22a8b455edb4f8453d5a6173319f9c80_cgraph.svg" width="240" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4d5bfee8e8bdea2bc60e5d725672af09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5bfee8e8bdea2bc60e5d725672af09">&#9670;&nbsp;</a></span>rm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::rm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove file from file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name to delete (shell wildcards NOT expanded)</td></tr>
  </table>
  </dd>
</dl>
<p>Since we use pstream's basic_ipstream constructor with signature ( const std::string &amp; file, const argv_type &amp; argv, pmode mode = pstdout ) and the file argument doesn't contain a slash, the actions of the shell are duplicated in searching for an executable in PATH. The shell will not interpret the other arguments, so wildcard expansion will not take place. </p>

<p class="definition">Definition at line <a class="el" href="_process_control_8_c_source.html#l00031">31</a> of file <a class="el" href="_process_control_8_c_source.html">ProcessControl.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_test_mesh_8h_source.html#l00033">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                 {</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  std::vector&lt; std::string &gt; argv;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  argv.push_back( <span class="stringliteral">&quot;rm&quot;</span> );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  argv.push_back( file );</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  redi::ipstream in( <span class="stringliteral">&quot;rm&quot;</span>, argv, redi::pstreambuf::pstderr );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  std::string e;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  std::string error;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">while</span> ( std::getline( in, e ) ) error += e + <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="keywordflow">if</span> (!error.empty()) <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( std::move(error) );</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28a553d30e4fd16f06342dd643d26c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a553d30e4fd16f06342dd643d26c25">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> tk::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample a discrete y = f(x) function at x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value of abscissa at which to sample y = f(x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td><a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021" title="Type alias for declaring, defining, and storing a discrete y = f(x) function. ">tk::Table</a> to sample</td></tr>
  </table>
  </dd>
</dl>
<p>If x is lower than the first x value in the function table, the first function value is returned. If x is larger than the last x value in the function table, the last function value is returned. In other words, no extrapolation is performed. If x falls between the first/lowest and the last/largest value in the table, linear interpolation is used to compute a sample between the two closest x values of the table around the abscissa given. </p><dl class="section return"><dt>Returns</dt><dd>Sampled value from discrete table </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The x column in the table is assumed to be in increasing order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewalker.html#ac381e784e9a620a33f67921a2068146e" title="Inverse equilibrium hydrodynamics time scale from DNS of homogeneous Rayleigh-Taylor instability...">walker::invhts_eq_A005H</a>, <a class="el" href="namespacewalker.html#ae994182cfb7ee4ba2c578217620016ed" title="Hydrodynamics (turbulent kinetic energy) production divided by the dissipatation rate evolution from ...">walker::prod_A005H</a> for example tables </dd></dl>

<p class="definition">Definition at line <a class="el" href="_table_8_c_source.html#l00018">18</a> of file <a class="el" href="_table_8_c_source.html">Table.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00698">walker::MixMassFracBetaCoeffHydroTimeScaleHomDecay::hydroproduction()</a>, <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00691">walker::MixMassFracBetaCoeffHydroTimeScaleHomDecay::hydrotimescale()</a>, and <a class="el" href="_distributor_8_c_source.html#l00313">walker::Distributor::outStat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">if</span> (x &lt; table.front().first) <span class="keywordflow">return</span> table.front().second;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;table.size()-1; ++i) {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">if</span> (table[i].first &lt; x &amp;&amp; x &lt; table[i+1].first) {</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;      <span class="keyword">auto</span> t1 = table[i].first;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;      <span class="keyword">auto</span> y1 = table[i].second;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      <span class="keyword">auto</span> t2 = table[i+1].first;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <span class="keyword">auto</span> y2 = table[i+1].second;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="keywordflow">return</span> y1 + (y2-y1)/(t2-t1)*(x-t1);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    }</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  }</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="keywordflow">return</span> table.back().second;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1f585439fa7abf61b26704881e98a168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f585439fa7abf61b26704881e98a168">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize univariate PDF to raw memory stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Univariate PDFs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized PDFs </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00016">16</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;{</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="comment">// Prepare for serializing PDF to a raw binary stream, compute size</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="comment">// Create raw character stream to store the serialized PDF</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="comment">// Serialize PDF, the message will contain a univariate PDF</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab33ea32478ab229dc49f14585c74fec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33ea32478ab229dc49f14585c74fec2">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize std::vector to raw memory stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="_vector_reducer_8_c_source.html#l00017">17</a> of file <a class="el" href="_vector_reducer_8_c_source.html">VectorReducer.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;{</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <span class="comment">// Prepare for serializing vectors to a raw binary stream, compute size</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; std::size_t &gt;&amp; <span class="keyword">&gt;</span>( v );</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="comment">// Create raw character stream to store the serialized vectors</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="comment">// Serialize vector, each message will contain a vector</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; std::size_t &gt;&amp; <span class="keyword">&gt;</span>( v );</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8a928cb4648630899f34ee7ad08fd754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a928cb4648630899f34ee7ad08fd754">&#9670;&nbsp;</a></span>serialize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt;char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize std::unordered_map to raw memory stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Hash map to serialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized map </dd></dl>

<p class="definition">Definition at line <a class="el" href="_hash_map_reducer_8h_source.html#l00029">29</a> of file <a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_solver_8_c_source.html#l00621">tk::Solver::charebc()</a>, <a class="el" href="_collector_8_c_source.html#l00095">walker::Collector::chareCen()</a>, <a class="el" href="_collector_8_c_source.html#l00032">walker::Collector::chareOrd()</a>, <a class="el" href="_hash_map_reducer_8h_source.html#l00061">mergeHashMap()</a>, <a class="el" href="_p_d_f_reducer_8_c_source.html#l00106">mergePDF()</a>, <a class="el" href="_p_d_f_reducer_8_c_source.html#l00039">mergeUniPDFs()</a>, <a class="el" href="_vector_reducer_8_c_source.html#l00041">mergeVector()</a>, and <a class="el" href="_discretization_8_c_source.html#l00263">inciter::Discretization::stat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                                                 {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   <span class="comment">// Prepare for serializing map to a raw binary stream, compute size</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::unordered_map&lt; Key, T, Hash, KeyEqual &gt;&amp; <span class="keyword">&gt;</span>( m );</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="comment">// Create raw character stream to store the serialized map</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="comment">// Serialize map, each message will contain a map</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::unordered_map&lt; Key, T, Hash, KeyEqual &gt;&amp; <span class="keyword">&gt;</span>( m );</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a95434266ed0be6503251e90e0fe60823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95434266ed0be6503251e90e0fe60823">&#9670;&nbsp;</a></span>serialize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_bi_p_d_f.html">tk::BiPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_tri_p_d_f.html">tk::TriPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize vectors of PDFs to raw memory stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Vector of univariate PDFs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Vector of bivariate PDFs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Vector of trivariate PDFs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized PDFs </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00075">75</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;{</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="comment">// Prepare for serializing PDFs to a raw binary stream, compute size</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::BiPDF &gt;&amp; <span class="keyword">&gt;</span>( b );</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::TriPDF &gt;&amp; <span class="keyword">&gt;</span>( t );</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// Create raw character stream to store the serialized PDFs</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// Serialize PDFs, each message will contain a vector of PDFs</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::BiPDF &gt;&amp; <span class="keyword">&gt;</span>( b );</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::TriPDF &gt;&amp; <span class="keyword">&gt;</span>( t );</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5e8c72da5967d8fb725ff4a26294a871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c72da5967d8fb725ff4a26294a871">&#9670;&nbsp;</a></span>setSignalHandlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tk::setSignalHandlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc. </p>
<dl class="section return"><dt>Returns</dt><dd>Ignore, used for calling in a constructor's initializer list </dd></dl>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00072">72</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="_process_exception_8_c_source.html#l00031">signalHandler()</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  signal( SIGABRT, <a class="code" href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">tk::signalHandler</a> );</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  signal( SIGSEGV, <a class="code" href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">tk::signalHandler</a> );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  signal( SIGILL,  <a class="code" href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">tk::signalHandler</a> );</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  signal( SIGFPE,  <a class="code" href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">tk::signalHandler</a> );</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="ttc" id="namespacetk_html_ad0ed65df66049a89a8a5055895ae417a"><div class="ttname"><a href="namespacetk.html#ad0ed65df66049a89a8a5055895ae417a">tk::signalHandler</a></div><div class="ttdeci">void signalHandler(int signum)</div><div class="ttdoc">Signal handler for multiple signals, SIGABRT, SIGSEGV, etc. </div><div class="ttdef"><b>Definition:</b> <a href="_process_exception_8_c_source.html#l00031">ProcessException.C:31</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5e8c72da5967d8fb725ff4a26294a871_cgraph.svg" width="502" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a293dd6fafcc3b8f4b28bef4f3ef050e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1">&#9670;&nbsp;</a></span>shiftToZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::shiftToZero </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift node IDs to start with zero in element connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount shifted</dd></dl>
<p>This function implements a simple reordering of the node ids of the element connectivity in inpoel by shifting the node ids so that the smallest is zero. </p><dl class="section note"><dt>Note</dt><dd>It is okay to call this function with an empty container; it will simply return without throwing an exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00023">23</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00212">tk::ExodusIIMeshReader::readAllElements()</a>, <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00063">tk::NetgenMeshReader::readElements()</a>, <a class="el" href="_a_s_c_mesh_reader_8_c_source.html#l00096">tk::ASCMeshReader::readElements()</a>, <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00155">tk::GmshMeshReader::readElements()</a>, <a class="el" href="_test_error_8h_source.html#l00115">tut::AMRError_common::TestErrorIndicator()</a>, and <a class="el" href="_test_mesh_8h_source.html#l00033">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">if</span> (inpoel.empty()) <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="comment">// find smallest node id</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keyword">auto</span> minId = *std::min_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// shift node ids to start from zero</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; n : inpoel) n -= minId;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="keywordflow">return</span> minId;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad0ed65df66049a89a8a5055895ae417a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ed65df66049a89a8a5055895ae417a">&#9670;&nbsp;</a></span>signalHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::signalHandler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal handler for multiple signals, SIGABRT, SIGSEGV, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signum</td><td>Signal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://oroboro.com/stack-trace-on-crash">https://oroboro.com/stack-trace-on-crash</a></dd></dl>
<p>Signals caught: SIGABRT is generated when the program calls the abort() function, such as when an assert() triggers SIGSEGV is generated when the program makes an illegal memory access, such as reading unaligned memory, dereferencing a null pointer, reading memory out of bounds etc. SIGILL is generated when the program tries to execute a malformed instruction. This happens when the execution pointer starts reading non-program data, or when a pointer to a function is corrupted. SIGFPE is generated when executing an illegal floating point instruction, most commonly division by zero or floating point overflow. </p>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00031">31</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#ae0d1896e351ef5e325425d71cfca833d">tut::Exception()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_process_exception_8_c_source.html#l00072">setSignalHandlers()</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="comment">// associate each signal with a signal name string.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordflow">switch</span>( signum ) {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">case</span> SIGABRT: name = <span class="stringliteral">&quot;SIGABRT&quot;</span>;  <span class="keywordflow">break</span>;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">case</span> SIGSEGV: name = <span class="stringliteral">&quot;SIGSEGV&quot;</span>;  <span class="keywordflow">break</span>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">case</span> SIGILL:  name = <span class="stringliteral">&quot;SIGILL&quot;</span>;   <span class="keywordflow">break</span>;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">case</span> SIGFPE:  name = <span class="stringliteral">&quot;SIGFPE&quot;</span>;   <span class="keywordflow">break</span>;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="comment">// Echo what signal is caught</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="keywordflow">if</span> ( name )</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    fprintf( stderr, <span class="stringliteral">&quot;Caught signal %d (%s)\n&quot;</span>, signum, name );</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    fprintf( stderr, <span class="stringliteral">&quot;Caught signal %d\n&quot;</span>, signum );</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="comment">// Get and display backtrace</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <a class="code" href="namespacetut.html#ae0d1896e351ef5e325425d71cfca833d">tk::Exception</a>(<span class="stringliteral">&quot;signal&quot;</span>).handleException();</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// Tell the runtime system to exit with a message</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  CkAbort( <span class="stringliteral">&quot;Signal caught&quot;</span> );</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div><div class="ttc" id="namespacetut_html_ae0d1896e351ef5e325425d71cfca833d"><div class="ttname"><a href="namespacetut.html#ae0d1896e351ef5e325425d71cfca833d">tut::Exception</a></div><div class="ttdeci">static Exception_group Exception(&quot;Base/Exception&quot;)</div><div class="ttdoc">Define test group. </div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ad0ed65df66049a89a8a5055895ae417a_cgraph.svg" width="296" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a20ee8c554da198c14efbb80a0b623a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ee8c554da198c14efbb80a0b623a4a">&#9670;&nbsp;</a></span>SiloError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::SiloError </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Silo error handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Error message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_silo_writer_8_c_source.html#l00022">22</a> of file <a class="el" href="_silo_writer_8_c_source.html">SiloWriter.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_silo_writer_8_c_source.html#l00040">tk::SiloWriter::SiloWriter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="comment">// Take out newlines from error message coming from library</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  std::string str(msg);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  std::replace(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39; &#39;</span>);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="comment">// Echo and throw</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  std::stringstream ss;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  ss &lt;&lt; <span class="stringliteral">&quot;Silo library writer error: &quot;</span> &lt;&lt; str;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( ss.str() );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f319a47a6a5b983e161aa5f4d8f7b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c">&#9670;&nbsp;</a></span>sumsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::sumsize </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the sizes of a container of containers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Container of containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the sizes of the containers of the container </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00153">153</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00262">tk::ExodusIIMeshReader::readElements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                                        {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  std::size_t sum = 0;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : c) sum += s.size();</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="keywordflow">return</span> sum;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa7d376e7f0dd51a64632432345dd4423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d376e7f0dd51a64632432345dd4423">&#9670;&nbsp;</a></span>swap_endian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tk::swap_endian </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap endianness of an integral type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Integral type to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted integer </dd></dl>

<p class="definition">Definition at line <a class="el" href="_q_endian_8h_source.html#l00023">23</a> of file <a class="el" href="_q_endian_8h_source.html">QEndian.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                     {</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  static_assert (CHAR_BIT == 8, <span class="stringliteral">&quot;CHAR_BIT != 8&quot;</span>);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keyword">union </span>{</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    T u;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> u8[<span class="keyword">sizeof</span>(T)];</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  } source, dest;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  source.u = u;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; <span class="keyword">sizeof</span>(T); k++)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    dest.u8[k] = source.u8[ <span class="keyword">sizeof</span>(T) - k - 1 ];</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="keywordflow">return</span> dest.u;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a550509206419175e2b2277bc5c18016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550509206419175e2b2277bc5c18016e">&#9670;&nbsp;</a></span>swap_endian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double tk::swap_endian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap endianness of a double </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Double to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted double </dd></dl>

<p class="definition">Definition at line <a class="el" href="_q_endian_8h_source.html#l00051">51</a> of file <a class="el" href="_q_endian_8h_source.html">QEndian.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                               {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  uint64_t mem = swap_endian&lt; uint64_t&gt;( *(uint64_t*)&amp;u );</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordflow">return</span> *(<span class="keywordtype">double</span>*)&amp;mem;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae5b04b00aa51667b944b7188545ec5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b04b00aa51667b944b7188545ec5ae">&#9670;&nbsp;</a></span>triple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tk::triple </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the triple-product of three vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v3</td><td>3rd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Triple-product </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00062">62</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">References <a class="el" href="_base_2_vector_8h_source.html#l00018">cross()</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00049">dot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00027">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00280">inciter::FluxCorrector::diff()</a>, <a class="el" href="_c_g_transport_8h_source.html#l00303">inciter::cg::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00328">inciter::cg::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_gradients_8_c_source.html#l00094">edgegrad()</a>, <a class="el" href="_derived_data_8_c_source.html#l01445">genGeoElemTet()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00081">inciter::cg::CompFlow&lt; Physics, Problem &gt;::lhs()</a>, <a class="el" href="_c_g_transport_8h_source.html#l00089">inciter::cg::Transport&lt; Physics, Problem &gt;::lhs()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00237">inciter::FluxCorrector::lump()</a>, <a class="el" href="_gradients_8_c_source.html#l00018">nodegrad()</a>, <a class="el" href="_c_g_comp_flow_8h_source.html#l00160">inciter::cg::CompFlow&lt; Physics, Problem &gt;::rhs()</a>, <a class="el" href="_c_g_transport_8h_source.html#l00167">inciter::cg::Transport&lt; Physics, Problem &gt;::rhs()</a>, <a class="el" href="_discretization_8_c_source.html#l00263">inciter::Discretization::stat()</a>, and <a class="el" href="_discretization_8_c_source.html#l00159">inciter::Discretization::vol()</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;{</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a>( v1, <a class="code" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a>(v2,v3) );</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;}</div><div class="ttc" id="namespacetk_html_ab602857e33f89cab4cc3788576ab1519"><div class="ttname"><a href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">tk::cross</a></div><div class="ttdeci">std::array&lt; T, 3 &gt; cross(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00018">Vector.h:18</a></div></div>
<div class="ttc" id="namespacetk_html_aeaca2df70ee950c576f6d74e1eb42caa"><div class="ttname"><a href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">tk::dot</a></div><div class="ttdeci">T dot(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00049">Vector.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ae5b04b00aa51667b944b7188545ec5ae_cgraph.svg" width="211" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a87af1b002bc711716bd170a714bda211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87af1b002bc711716bd170a714bda211">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::unique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make elements of container unique </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>Container </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00023">23</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00045">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_discretization_8_c_source.html#l00038">inciter::Discretization::Discretization()</a>, <a class="el" href="_partitioner_8_c_source.html#l00270">inciter::Partitioner::flatten()</a>, <a class="el" href="_derived_data_8_c_source.html#l00822">genNbfacTet()</a>, <a class="el" href="_reorder_8_c_source.html#l00163">global2local()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00247">tk::UnsMesh::graphsize()</a>, <a class="el" href="_walker_2_input_deck_2_parser_8_c_source.html#l00034">walker::InputDeckParser::InputDeckParser()</a>, <a class="el" href="_vector_reducer_8_c_source.html#l00041">mergeVector()</a>, <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00439">tk::ExodusIIMeshReader::readSidesets()</a>, <a class="el" href="_print_8h_source.html#l00709">tk::Print::splitLines()</a>, <a class="el" href="_inciter_print_8h_source.html#l00085">inciter::InciterPrint::Policies::unique()</a>, and <a class="el" href="_walker_print_8h_source.html#l00119">walker::WalkerPrint::Policies::unique()</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;{</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  std::sort( begin(c), end(c) );</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="keyword">auto</span> it = <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">std::unique</a>( begin(c), end(c) );</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="keyword">auto</span> d = std::distance( begin(c), it );</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( d &gt;= 0, <span class="stringliteral">&quot;Distance must be non-negative in tk::unique()&quot;</span> );</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  c.resize( static_cast&lt; std::size_t &gt;( d ) );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00023">ContainerUtil.h:23</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00045">Exception.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d61711de49d010da4785f7cb6ad2d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d61711de49d010da4785f7cb6ad2d9b">&#9670;&nbsp;</a></span>waitfor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Msg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a> tk::waitfor </td>
          <td>(</td>
          <td class="paramtype">const CkFuture &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for and return future. Concept: <a class="el" href="structtk_1_1_msg.html" title="Charm++ message type for sending a single T, T must be POD. ">Msg</a> must have public function get() returning <a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a>. </p>

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00107">107</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p class="reference">References <a class="el" href="_msg_8h_source.html#l00048">tk::Msg&lt; T &gt;::get()</a>, and <a class="el" href="_msg_8h_source.html#l00050">tk::Msg&lt; T &gt;::value</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                                    {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  Msg* m = <span class="keyword">static_cast&lt;</span> Msg* <span class="keyword">&gt;</span>( CkWaitFuture( f ) );</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="keyword">typename</span> Msg::value_type value( m-&gt;get() );</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="keyword">delete</span> m;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="keywordflow">return</span> value;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5d61711de49d010da4785f7cb6ad2d9b_cgraph.svg" width="240" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8e567fa9a72a1d5d02cea9eb020b192a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e567fa9a72a1d5d02cea9eb020b192a">&#9670;&nbsp;</a></span>workdir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tk::workdir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for POSIX API's getcwd() from unistd.h. </p>
<dl class="section return"><dt>Returns</dt><dd>A stirng containing the current working directory </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00036">36</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00031">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00131">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;{</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordtype">char</span> cwd[1024];</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="keywordflow">if</span> ( getcwd(cwd, <span class="keyword">sizeof</span>(cwd)) != <span class="keyword">nullptr</span> )</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">return</span> std::string( cwd );</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Error from POSIX API&#39;s getcwd()&quot;</span> );</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00031">Exception.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a92ff858133bdb654de9b95c279427325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ff858133bdb654de9b95c279427325">&#9670;&nbsp;</a></span>writeUnsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt; tk::writeUnsMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unstructured mesh to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to write mesh to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Unstructured mesh object to write from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder</td><td>Whether to also reorder mesh nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of time stamps consisting of a timer label (a string), and a time state (a <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" title="Real number type used throughout the whole code. ">tk::real</a> in seconds) measuring the renumber and the mesh write time </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00134">134</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">CREATE</a>, <a class="el" href="_print_8h_source.html#l00302">tk::Print::diagend()</a>, <a class="el" href="_print_8h_source.html#l00296">tk::Print::diagstart()</a>, <a class="el" href="_timer_8h_source.html#l00063">tk::Timer::dsec()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="_derived_data_8_c_source.html#l00041">genEsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00124">genPsup()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="_mesh_factory_8_c_source.html#l00066">pickOutput()</a>, <a class="el" href="_reorder_8_c_source.html#l00047">remap()</a>, <a class="el" href="_reorder_8_c_source.html#l00099">renumber()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00219">tk::UnsMesh::tetinpoel()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00212">tk::UnsMesh::triinpoel()</a>, <a class="el" href="_netgen_mesh_writer_8_c_source.html#l00027">tk::NetgenMeshWriter::writeMesh()</a>, <a class="el" href="_gmsh_mesh_writer_8_c_source.html#l00061">tk::GmshMeshWriter::writeMesh()</a>, <a class="el" href="_exodus_i_i_mesh_writer_8_c_source.html#l00075">tk::ExodusIIMeshWriter::writeMesh()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00173">tk::UnsMesh::x()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00174">tk::UnsMesh::y()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00175">tk::UnsMesh::z()</a>, and <a class="el" href="_timer_8h_source.html#l00059">tk::Timer::zero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00043">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  std::vector&lt; std::pair&lt; std::string, tk::real &gt; &gt; times;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="keywordflow">if</span> (reorder) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Reordering mesh nodes ...&quot;</span> );</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="comment">// If mesh has tetrahedra elements, reorder based on those</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordflow">if</span> (!mesh.tetinpoel().empty()) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;      <span class="keyword">auto</span>&amp; inpoel = mesh.tetinpoel();</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a>( inpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>( inpoel, 4 ) );</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      <span class="keyword">auto</span> map = <a class="code" href="namespacetk.html#a22a8b455edb4f8453d5a6173319f9c80">tk::renumber</a>( psup );</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( inpoel, map );</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.triinpoel(), map );</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.x(), map );</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.y(), map );</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.z(), map );</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="comment">// If mesh has no tetrahedra elements, reorder based on triangle mesh if any</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!mesh.triinpoel().empty()) {</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      <span class="keyword">auto</span>&amp; inpoel = mesh.triinpoel();</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a>( inpoel, 3, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>( inpoel, 3 ) );</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keyword">auto</span> map = <a class="code" href="namespacetk.html#a22a8b455edb4f8453d5a6173319f9c80">tk::renumber</a>( psup );</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( inpoel, map );</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.x(), map );</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.y(), map );</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <a class="code" href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a>( mesh.z(), map );</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    times.emplace_back( <span class="stringliteral">&quot;Reorder mesh&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    t.<a class="code" href="classtk_1_1_timer.html#a35be14a9a4bdbbaa93565c4abe9b25d0">zero</a>();</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  }</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Writing mesh to file ...&quot;</span> );</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">pickOutput</a>( filename );</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="keywordflow">if</span> (meshtype == MeshWriter::GMSH)</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    GmshMeshWriter( filename ).writeMesh( mesh );</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshWriter::NETGEN)</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    NetgenMeshWriter( filename ).writeMesh( mesh );</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype== MeshWriter::EXODUSII)</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    ExodusIIMeshWriter( filename, ExoWriter::CREATE ).writeMesh( mesh );</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  times.emplace_back( <span class="stringliteral">&quot;Write mesh to file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="keywordflow">return</span> times;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div><div class="ttc" id="classtk_1_1_timer_html"><div class="ttname"><a href="classtk_1_1_timer.html">tk::Timer</a></div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00028">Timer.h:28</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a35be14a9a4bdbbaa93565c4abe9b25d0"><div class="ttname"><a href="classtk_1_1_timer.html#a35be14a9a4bdbbaa93565c4abe9b25d0">tk::Timer::zero</a></div><div class="ttdeci">void zero()</div><div class="ttdoc">Zero timer. </div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00059">Timer.h:59</a></div></div>
<div class="ttc" id="namespacetk_html_ad2a88a65102c17149b44660db15d445b"><div class="ttname"><a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genPsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</div><div class="ttdoc">Generate derived data structure, points surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00124">DerivedData.C:124</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a569d68d17038fa38b83d5bb229500c40"><div class="ttname"><a href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">tk::Timer::dsec</a></div><div class="ttdeci">real dsec() const</div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00063">Timer.h:63</a></div></div>
<div class="ttc" id="namespacetk_html_a64b09f52ea3b4314e449e70255837836"><div class="ttname"><a href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">tk::pickOutput</a></div><div class="ttdeci">MeshWriter pickOutput(const std::string &amp;filename)</div><div class="ttdoc">Determine output mesh file type. </div><div class="ttdef"><b>Definition:</b> <a href="_mesh_factory_8_c_source.html#l00066">MeshFactory.C:66</a></div></div>
<div class="ttc" id="namespacetk_html_a261ac7b3e006f7fa6621ad910b6553cc"><div class="ttname"><a href="namespacetk.html#a261ac7b3e006f7fa6621ad910b6553cc">tk::remap</a></div><div class="ttdeci">void remap(std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;map)</div><div class="ttdoc">Apply new mapping to vector of indices. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00047">Reorder.C:47</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_a9a3bb2dc7c5ea1d979dcec5528c37a66"><div class="ttname"><a href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">tk::Print::diagend</a></div><div class="ttdeci">void diagend(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00302">Print.h:302</a></div></div>
<div class="ttc" id="namespacetk_html_a66a2889d5d8aeb4a836842c6a1010463"><div class="ttname"><a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genEsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</div><div class="ttdoc">Generate derived data structure, elements surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00041">DerivedData.C:41</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_ae1f93831127fb7d45c33ad3cdf3604fd"><div class="ttname"><a href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">tk::Print::diagstart</a></div><div class="ttdeci">void diagstart(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00296">Print.h:296</a></div></div>
<div class="ttc" id="namespacetk_html_a22a8b455edb4f8453d5a6173319f9c80"><div class="ttname"><a href="namespacetk.html#a22a8b455edb4f8453d5a6173319f9c80">tk::renumber</a></div><div class="ttdeci">std::vector&lt; std::size_t &gt; renumber(const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)</div><div class="ttdoc">Reorder mesh points with the advancing front technique. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00099">Reorder.C:99</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a92ff858133bdb654de9b95c279427325_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1320fa5c795146f9a4ac4fc2eb4e2606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1320fa5c795146f9a4ac4fc2eb4e2606">&#9670;&nbsp;</a></span>BCMapMerger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CkReduction::reducerType tk::BCMapMerger</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_solver_8_c_source.html#l00033">33</a> of file <a class="el" href="_solver_8_c_source.html">Solver.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_solver_8_c_source.html#l00621">tk::Solver::charebc()</a>, and <a class="el" href="_solver_8_c_source.html#l00117">tk::Solver::registerReducers()</a>.</p>

</div>
</div>
<a id="af9ca17aedbef10f63fdfdee06f57e29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ca17aedbef10f63fdfdee06f57e29c">&#9670;&nbsp;</a></span>CSTYLE_STRLEN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int tk::CSTYLE_STRLEN = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00028">28</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_msg_8h_source.html#l00057">tk::StringsMsg::StringsMsg()</a>, and <a class="el" href="_msg_8h_source.html#l00083">tk::VecStrsMsg&lt; Size &gt;::VecStrsMsg()</a>.</p>

</div>
</div>
<a id="a9aaf71501378c00aad4f847942cdef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaf71501378c00aad4f847942cdef6d">&#9670;&nbsp;</a></span>EqCompUnk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t tk::EqCompUnk = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00030">30</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

</div>
</div>
<a id="a30ac7c57927d6134e6563817f5d005a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ac7c57927d6134e6563817f5d005a0">&#9670;&nbsp;</a></span>lpofa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::array&lt; std::size_t, 3 &gt;, 4 &gt; tk::lpofa {{ {{1,2,3}}, {{2,0,3}}, {{3,0,1}}, {{0,2,1}} }}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const array defining the node ordering convention for a tetrahedron cell</p>
<p>This two-dimensional array stores the naming/ordering convention of the node indices of a tetrahedron (tet) element. The dimensions are 4x3 as a tetrahedron has a total of 4 nodes and each (triangle) face has 3 nodes. Thus the array below associates tet node 0 with nodes {1,2,3}, tet node 1 with {2,0,3}, tet node 2 with {3,0,1}, and tet node 3 with {0,2,1}. Note that not only these mappings are important, but also the order of the nodes within the triplets as this specific order also defines the outwards normal of each face. </p>

<p class="definition">Definition at line <a class="el" href="_derived_data_8h_source.html#l00033">33</a> of file <a class="el" href="_derived_data_8h_source.html">DerivedData.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_partitioner_8_c_source.html#l00270">inciter::Partitioner::flatten()</a>, <a class="el" href="_derived_data_8_c_source.html#l00933">genEsuelTet()</a>, and <a class="el" href="_derived_data_8_c_source.html#l01151">genInpofaTet()</a>.</p>

</div>
</div>
<a id="a78da814ef7132a0958c47f987e3e711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78da814ef7132a0958c47f987e3e711c">&#9670;&nbsp;</a></span>UnkEqComp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t tk::UnkEqComp = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags for selecting data layout policies. </p>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00029">29</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 17 2018 19:11:09 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
