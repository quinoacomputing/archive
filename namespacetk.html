<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tk namespace | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>tk <span class="m-thin">namespace</span></h1>
        <p>Toolkit declarations and definitions for general purpose utilities.</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#namespaces">Namespaces</a></li>
                <li><a href="#nested-classes">Classes</a></li>
                <li><a href="#enum-members">Enums</a></li>
                <li><a href="#typedef-members">Typedefs</a></li>
                <li><a href="#func-members">Functions</a></li>
                <li><a href="#var-members">Variables</a></li>
              </ul>
            </li>
          </ul>
        </div>
        <section id="namespaces">
          <h2><a href="#namespaces">Namespaces</a></h2>
          <dl class="m-dox">
            <dt>namespace <a href="namespacetk_1_1ctr.html" class="m-dox">ctr</a></dt>
            <dd>Toolkit control, general purpose user input to internal data transfer.</dd>
            <dt>namespace <a href="namespacetk_1_1grm.html" class="m-dox">grm</a></dt>
            <dd>Toolkit general purpose grammar definition.</dd>
            <dt>namespace <a href="namespacetk_1_1mkl.html" class="m-dox">mkl</a></dt>
            <dd>Toolkit, grammar definition for Intel&#x27;s Math Kernel Library.</dd>
            <dt>namespace <a href="namespacetk_1_1random123.html" class="m-dox">random123</a></dt>
            <dd>Toolkit, grammar definition for the <a href="classtk_1_1_random123.html" class="m-dox">Random123</a> library.</dd>
            <dt>namespace <a href="namespacetk_1_1rngsse.html" class="m-dox">rngsse</a></dt>
            <dd>Toolkit, grammar definition for the <a href="classtk_1_1_r_n_g_s_s_e.html" class="m-dox">RNGSSE</a> library.</dd>
            <dt>namespace <a href="namespacetk_1_1tuple.html" class="m-dox">tuple</a></dt>
            <dd>Tagged tuple allowing tag-based access to tuple members.</dd>
            <dt>namespace <a href="namespacetk_1_1zoltan.html" class="m-dox">zoltan</a></dt>
            <dd>Interoperation with the Zoltan library, used for static mesh partitioning.</dd>
          </dl>
        </section>
        <section id="nested-classes">
          <h2><a href="#nested-classes">Classes</a></h2>
          <dl class="m-dox">
            <dt>
              class <a href="classtk_1_1_around.html" class="m-dox">Around</a>
            </dt>
            <dd>Helper class simplifying client code for iterating on entries surrounding entries via linked lists derived from unstructured mesh connectivity.</dd>
            <dt>
              class <a href="classtk_1_1_a_s_c_mesh_reader.html" class="m-dox">ASCMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_a_s_c_mesh_reader.html" class="m-dox">ASCMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_bi_p_d_f.html" class="m-dox">BiPDF</a>
            </dt>
            <dd>Joint bivariate PDF estimator.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename... Ts&gt;</div>
              class <a href="classtk_1_1_control.html" class="m-dox">Control</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              class <a href="classtk_1_1_data.html" class="m-dox">Data</a>
            </dt>
            <dd>Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch.</dd>
            <dt>
              class <a href="classtk_1_1_diag_writer.html" class="m-dox">DiagWriter</a>
            </dt>
            <dd><a href="classtk_1_1_diag_writer.html" class="m-dox">DiagWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">tk::<wbr />Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_exception.html" class="m-dox">Exception</a>
            </dt>
            <dd>Basic exception class for producing <a href="file:func:line">file:func:line</a> info + call trace.</dd>
            <dt>
              class <a href="classtk_1_1_exodus_i_i_mesh_reader.html" class="m-dox">ExodusIIMeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_exodus_i_i_mesh_writer.html" class="m-dox">ExodusIIMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_file_parser.html" class="m-dox">FileParser</a>
            </dt>
            <dd><a href="classtk_1_1_file_parser.html" class="m-dox">FileParser</a>.</dd>
            <dt>
              class <a href="classtk_1_1_gmsh_mesh_reader.html" class="m-dox">GmshMeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_gmsh_mesh_writer.html" class="m-dox">GmshMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_h5_part_writer.html" class="m-dox">H5PartWriter</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_function_expect_choices.html" class="m-dox">HasFunctionExpectChoices</a>
            </dt>
            <dd>Detect if T defines function &quot;expect::choices&quot;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_function_expect_description.html" class="m-dox">HasFunctionExpectDescription</a>
            </dt>
            <dd>Detect if T defines function &quot;expect::description&quot;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_typedef_alias.html" class="m-dox">HasTypedefAlias</a>
            </dt>
            <dd>Detect if T defines type &quot;alias&quot;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_typedef_code.html" class="m-dox">HasTypedefCode</a>
            </dt>
            <dd>Detect if T defines type &quot;code&quot;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_typedef_expect_type.html" class="m-dox">HasTypedefExpectType</a>
            </dt>
            <dd>Detect if T defines type &quot;expect::type&quot;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_has_typedef_proxy.html" class="m-dox">HasTypedefProxy</a>
            </dt>
            <dd>Detect if T defines type &quot;Proxy&quot;.</dd>
            <dt>
              class <a href="classtk_1_1_hyper_mesh_reader.html" class="m-dox">HyperMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_hyper_mesh_reader.html" class="m-dox">HyperMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class ProxyElem&gt;</div>
              struct <a href="structtk_1_1_idx.html" class="m-dox">Idx</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;bool Condition, typename Then, typename Else = void&gt;</div>
              struct <a href="structtk_1_1if__.html" class="m-dox">if_</a>
            </dt>
            <dd>Type selection: <a href="structtk_1_1if__.html#a456b6172591b18a1bd516f30b653444d" class="m-dox">if_&lt; Condition, Then, Else &gt;::<wbr />type</a>.</dd>
            <dt>
              class <a href="classtk_1_1_linear_map.html" class="m-dox">LinearMap</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_mesh_reader.html" class="m-dox">MeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_m_k_l_r_n_g.html" class="m-dox">MKLRNG</a>
            </dt>
            <dd>MKL-based random number generator used polymorphically with <a href="classtk_1_1_r_n_g.html" class="m-dox">tk::<wbr />RNG</a>.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              struct <a href="structtk_1_1_msg.html" class="m-dox">Msg</a>
            </dt>
            <dd>Charm++ message type for sending a single T, T must be POD.</dd>
            <dt>
              class <a href="classtk_1_1_netgen_mesh_reader.html" class="m-dox">NetgenMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_netgen_mesh_reader.html" class="m-dox">NetgenMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_netgen_mesh_writer.html" class="m-dox">NetgenMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_omega__h___mesh_reader.html" class="m-dox">Omega_h_MeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class HostProxy&gt;</div>
              class <a href="classtk_1_1_particle_writer.html" class="m-dox">ParticleWriter</a>
            </dt>
            <dd>Charm++ group used to output particle data to file in parallel using H5Part and MPI-IO.</dd>
            <dt>
              class <a href="classtk_1_1_p_d_f_writer.html" class="m-dox">PDFWriter</a>
            </dt>
            <dd><a href="classtk_1_1_p_d_f_writer.html" class="m-dox">PDFWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_print.html" class="m-dox">Print</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;std::size_t N&gt;</div>
              class <a href="classtk_1_1_progress.html" class="m-dox">Progress</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class CBRNG&gt;</div>
              class <a href="classtk_1_1_random123.html" class="m-dox">Random123</a>
            </dt>
            <dd><a href="classtk_1_1_random123.html" class="m-dox">Random123</a>-based random number generator used polymorphically with <a href="classtk_1_1_r_n_g.html" class="m-dox">tk::<wbr />RNG</a>.</dd>
            <dt>
              class <a href="classtk_1_1_reader.html" class="m-dox">Reader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_r_n_g.html" class="m-dox">RNG</a>
            </dt>
            <dd>Random number generator.</dd>
            <dt>
              class <a href="classtk_1_1_r_n_g_print.html" class="m-dox">RNGPrint</a>
            </dt>
            <dd><a href="classtk_1_1_r_n_g_print.html" class="m-dox">RNGPrint</a> : <a href="classtk_1_1_print.html" class="m-dox">Print</a>.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class State, typename SeqNumType, unsigned int(*)(State*) Generate&gt;</div>
              class <a href="classtk_1_1_r_n_g_s_s_e.html" class="m-dox">RNGSSE</a>
            </dt>
            <dd><a href="classtk_1_1_r_n_g_s_s_e.html" class="m-dox">RNGSSE</a>-based random number generator used polymorphically with <a href="classtk_1_1_r_n_g.html" class="m-dox">tk::<wbr />RNG</a>.</dd>
            <dt>
              class <a href="classtk_1_1_r_n_g_stack.html" class="m-dox">RNGStack</a>
            </dt>
            <dd>Random number generator stack.</dd>
            <dt>
              class <a href="classtk_1_1_silo_writer.html" class="m-dox">SiloWriter</a>
            </dt>
            <dd><a href="classtk_1_1_silo_writer.html" class="m-dox">SiloWriter</a>.</dd>
            <dt>
              class <a href="classtk_1_1_solver.html" class="m-dox">Solver</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_solver_shadow.html" class="m-dox">SolverShadow</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_statistics.html" class="m-dox">Statistics</a>
            </dt>
            <dd><a href="classtk_1_1_statistics.html" class="m-dox">Statistics</a> estimator.</dd>
            <dt>
              class <a href="classtk_1_1_s_t_l_mesh.html" class="m-dox">STLMesh</a>
            </dt>
            <dd><a href="classtk_1_1_s_t_l_mesh.html" class="m-dox">STLMesh</a>.</dd>
            <dt>
              class <a href="classtk_1_1_s_t_l_txt_mesh_reader.html" class="m-dox">STLTxtMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_s_t_l_txt_mesh_reader.html" class="m-dox">STLTxtMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1str__const.html" class="m-dox">str_const</a>
            </dt>
            <dd>constexpr string</dd>
            <dt>
              class <a href="classtk_1_1_string_parser.html" class="m-dox">StringParser</a>
            </dt>
            <dd><a href="classtk_1_1_string_parser.html" class="m-dox">StringParser</a>.</dd>
            <dt>
              struct <a href="structtk_1_1_strings_msg.html" class="m-dox">StringsMsg</a>
            </dt>
            <dd>Charm++ message type for sending a string of strings separated by &#x27;;&#x27;.</dd>
            <dt>
              class <a href="classtk_1_1_timer.html" class="m-dox">Timer</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Enum&gt;</div>
              class <a href="classtk_1_1_toggle.html" class="m-dox">Toggle</a>
            </dt>
            <dd><a href="classtk_1_1_toggle.html" class="m-dox">Toggle</a> is the base for an Option, doing generic searches.</dd>
            <dt>
              class <a href="classtk_1_1_tracker.html" class="m-dox">Tracker</a>
            </dt>
            <dd><a href="classtk_1_1_tracker.html" class="m-dox">Tracker</a> advances Lagrangian particles in state space.</dd>
            <dt>
              class <a href="classtk_1_1_tri_p_d_f.html" class="m-dox">TriPDF</a>
            </dt>
            <dd>Joint trivariate PDF estimator.</dd>
            <dt>
              class <a href="classtk_1_1_txt_stat_writer.html" class="m-dox">TxtStatWriter</a>
            </dt>
            <dd><a href="classtk_1_1_txt_stat_writer.html" class="m-dox">TxtStatWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">tk::<wbr />Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">UniPDF</a>
            </dt>
            <dd>Univariate PDF estimator.</dd>
            <dt>
              class <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>
            </dt>
            <dd>3D unstructured mesh class</dd>
            <dt>
              class <a href="classtk_1_1_uns_mesh_map.html" class="m-dox">UnsMeshMap</a>
            </dt>
            <dd>Charm++ array map for initial placement of array elements using an unstructured grid.</dd>
            <dt>
              <div class="m-dox-template">template&lt;std::size_t Size = 1&gt;</div>
              struct <a href="structtk_1_1_vec_strs_msg.html" class="m-dox">VecStrsMsg</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_writer.html" class="m-dox">Writer</a>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section id="enum-members">
          <h2><a href="#enum-members">Enums</a></h2>
          <dl class="m-dox">
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#afcc275d91d4368505f221061b9ba822a" class="m-dox">ErrCode</a> { </span><span class="m-dox-wrap"><a href="#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" class="m-dox">SUCCESS</a> = EXIT_SUCCESS,
              <a href="#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" class="m-dox">FAILURE</a> = EXIT_FAILURE }</span>
            </dt>
            <dd>Error codes for the OS (or whatever calls us)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#a1d172b64b84ff0554f0e87475f4541b4" class="m-dox-self" name="a1d172b64b84ff0554f0e87475f4541b4">Style</a> { </span><span class="m-dox-wrap"><a href="#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e" class="m-dox">QUIET</a> =0,
              <a href="#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2" class="m-dox">VERBOSE</a> =1 }</span>
            </dt>
            <dd>Output verbosity. C-style enum as this is used for template argument.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox">ExoElemType</a>: int { </span><span class="m-dox-wrap"><a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox">TET</a> = 0,
              <a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox">TRI</a> = 1 }</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#aea4fb4c5b5f9f99675ec2f39d25a3482" class="m-dox-self" name="aea4fb4c5b5f9f99675ec2f39d25a3482">ExoWriter</a> { </span><span class="m-dox-wrap"><a href="#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d" class="m-dox">CREATE</a>,
              <a href="#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3" class="m-dox">OPEN</a> }</span>
            </dt>
            <dd>ExodusII writer constructor modes.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#a85016961456a798f65e4e5a451e44242" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242">GmshElemType</a> { </span><span class="m-dox-wrap"><a href="#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d" class="m-dox">LIN</a> = 1,
              <a href="#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674" class="m-dox">TRI</a> = 2,
              <a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox">TRI</a> = 1,
              <a href="#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1" class="m-dox">TET</a> = 4,
              <a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox">TET</a> = 0,
              <a href="#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125" class="m-dox">PNT</a> = 15 }</span>
            </dt>
            <dd>Identifiers of supported Gmsh elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#af910e1a2aff3119022dea29cf3d898c1" class="m-dox-self" name="af910e1a2aff3119022dea29cf3d898c1">GmshFileType</a> { </span><span class="m-dox-wrap"><a href="#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3" class="m-dox">UNDEFINED</a> = -1,
              <a href="#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc" class="m-dox">ASCII</a> = 0,
              <a href="#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452" class="m-dox">BINARY</a> = 1 }</span>
            </dt>
            <dd>Supported Gmsh mesh file types.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a8e37e8d13562df3379a730217f735255" class="m-dox-self" name="a8e37e8d13562df3379a730217f735255">MeshReaderType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#a8e37e8d13562df3379a730217f735255ad8e85cdb6ef83caac7fa35c22dda2153" class="m-dox">GMSH</a> =0,
              <a href="#a8e37e8d13562df3379a730217f735255a8d2dc7a7e41c392a0da416ec0626e676" class="m-dox">NETGEN</a>,
              <a href="#a8e37e8d13562df3379a730217f735255a834c8a77b335ad1c7bb2b632b6857339" class="m-dox">EXODUSII</a>,
              <a href="#a8e37e8d13562df3379a730217f735255a74f67c0302d5888253dce0a5e2462ade" class="m-dox">HYPER</a>,
              <a href="#a8e37e8d13562df3379a730217f735255ac6e421eaad140c1bc1a39980502df80c" class="m-dox">ASC</a>,
              <a href="#a8e37e8d13562df3379a730217f735255ae29e9370fcc76113c2afa7c1ab1289c2" class="m-dox">OMEGA_H</a> }</span>
            </dt>
            <dd>Supported mesh readers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox-self" name="ab4676f2ab442a552c4409d65b5d1b751">MeshWriterType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#ab4676f2ab442a552c4409d65b5d1b751ad8e85cdb6ef83caac7fa35c22dda2153" class="m-dox">GMSH</a> =0,
              <a href="#ab4676f2ab442a552c4409d65b5d1b751a8d2dc7a7e41c392a0da416ec0626e676" class="m-dox">NETGEN</a>,
              <a href="#ab4676f2ab442a552c4409d65b5d1b751a834c8a77b335ad1c7bb2b632b6857339" class="m-dox">EXODUSII</a> }</span>
            </dt>
            <dd>Supported mesh writers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox-self" name="a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd" class="m-dox">INCITER</a> =0,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928" class="m-dox">RNGTEST</a>,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247" class="m-dox">UNITTEST</a>,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35" class="m-dox">MESHCONV</a>,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da3c5b5eb34a3900ce1f87dd1efe07cf1a" class="m-dox">FILECONV</a>,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa" class="m-dox">WALKER</a> }</span>
            </dt>
            <dd>Executable types for which an ascii logo is available in <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>.</dd>
          </dl>
        </section>
        <section id="typedef-members">
          <h2><a href="#typedef-members">Typedefs</a></h2>
          <dl class="m-dox">
            <dt>
              <div class="m-dox-template">template&lt;class li, class lo&gt;</div>
              using <a href="#a30c00988310413e9b96e131f8332b2b0" class="m-dox">cartesian_product</a> = brigand::reverse_fold&lt;brigand::list&lt;li, lo&gt;, brigand::list&lt;brigand::list&lt;&gt;&gt;, brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::_2, brigand::defer&lt;brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::parent&lt;brigand::_1&gt;, brigand::defer&lt;brigand::bind&lt;brigand::list, brigand::bind&lt;brigand::push_front, brigand::_1, brigand::parent&lt;brigand::_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a4a3683fffc858642385d1292c3817021" class="m-dox-self" name="a4a3683fffc858642385d1292c3817021">Table</a> = std::vector&lt;std::pair&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;
            </dt>
            <dd>Type alias for declaring, defining, and storing a discrete y = f(x) function.</dd>
            <dt>
              using <a href="#a1a96ada94b7e2911ecca0a360f305575" class="m-dox-self" name="a1a96ada94b7e2911ecca0a360f305575">real</a> = double
            </dt>
            <dd>Real number type used throughout the whole code.</dd>
            <dt>
              using <a href="#a40ff0a76887b93164712b9ce9192fdd2" class="m-dox-self" name="a40ff0a76887b93164712b9ce9192fdd2">SiloErrorHandler</a> = void(*)(char*)
            </dt>
            <dd>Silo error handler function type.</dd>
            <dt>
              using <a href="#a74de56fa53c55c0a8f35b764729cdf20" class="m-dox-self" name="a74de56fa53c55c0a8f35b764729cdf20">RNGFactory</a> = std::map&lt;<a href="namespacetk_1_1ctr.html#aa1b0831f9e998d8133473f63480b3ecb" class="m-dox">ctr::<wbr />RNGType</a>, std::function&lt;<a href="classtk_1_1_r_n_g.html" class="m-dox">RNG</a>()&gt;&gt;
            </dt>
            <dd>Random number generator factory: keys associated to their constructors.</dd>
          </dl>
        </section>
        <section id="func-members">
          <h2><a href="#func-members">Functions</a></h2>
          <dl class="m-dox">
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a87af1b002bc711716bd170a714bda211" class="m-dox">unique</a>(</span><span class="m-dox-wrap">Container&amp; c)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a33be2bf221a519d736333a9f18c8ffdc" class="m-dox">uniquecopy</a>(</span><span class="m-dox-wrap">const Container&amp; src) -&gt; Container</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#af0de4157a7818da7a9deb1476099bd8d" class="m-dox">extents</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; vec) -&gt; std::array&lt;T, 2&gt;</span>
            </dt>
            <dd>Return minimum and maximum values of a vector.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class T, class Allocator&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ad47c993218d9384828fcce2794850ac7" class="m-dox">operator+=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src) -&gt; std::vector&lt;T, Allocator&gt;&amp;</span>
            </dt>
            <dd>Add all elements of a vector to another one.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class C1, class C2&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a05866fa57031940dc4ba5d4665847016" class="m-dox">keyEqual</a>(</span><span class="m-dox-wrap">const C1&amp; a,
              const C2&amp; b) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c" class="m-dox">sumsize</a>(</span><span class="m-dox-wrap">const Container&amp; c) -&gt; std::size_t</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Map&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a357e40550c113066882bc3e3c3cf52b8" class="m-dox">sumvalsize</a>(</span><span class="m-dox-wrap">const Map&amp; c) -&gt; std::size_t</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a9140b408dcbd2eaef58f9c3a54fa104a" class="m-dox">destroy</a>(</span><span class="m-dox-wrap">Container&amp; c)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Container, typename Predicate&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a38a390b2dd9f091d2ca7465208a960ed" class="m-dox">erase_if</a>(</span><span class="m-dox-wrap">Container&amp; items,
              const Predicate&amp; predicate)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#adc362fc7a89c617e1ab8f57f1dbd100a" class="m-dox">operator*</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#afd730d099e698f124362ef8c01483e0f" class="m-dox">min</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac9a26e30d19b940a12990a866a514cb5" class="m-dox">max</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a21669e4d06c62a58cd0f4bf63868ab7e" class="m-dox">operator==</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac38f5055c45cd35b8ce00151cea4c1d3" class="m-dox">operator!=</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ab7f02155bc2945a0a0c82c1be5cad041" class="m-dox">maxdiff</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; std::pair&lt;std::size_t, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class C, class Key, class Factory, typename... ConstructorArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ad986ef5558d44d5e0c6650c589499980" class="m-dox">record</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ConstructorArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Factory, class Key, class Obj = typename std::remove_pointer&lt;                       typename Factory::mapped_type::result_type&gt;::type&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aeb9673379e599043b13fff369dce1402" class="m-dox">instantiate</a>(</span><span class="m-dox-wrap">const Factory&amp; f,
              const Key&amp; key) -&gt; std::unique_ptr&lt;Obj&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a24170c3146caaa7b79d78d4aa1d98f66" class="m-dox">recordModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key, typename ModelConstrArg&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ae98b4e55f14339c707622a8da43d8ce9" class="m-dox">recordModelLate</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArg)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a4bd6374b4792dbd3c626dad60bcef168" class="m-dox">recordCharmModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename A, typename B&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac2323b3c43edbcc32d55d91100ffc3a6" class="m-dox">flip_pair</a>(</span><span class="m-dox-wrap">const std::pair&lt;A, B&gt;&amp; p) -&gt; std::pair&lt;B, A&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename A, typename B&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a42982d289f8edfffa60fa4da8b7b9fdf" class="m-dox">flip_map</a>(</span><span class="m-dox-wrap">const std::map&lt;A, B&gt;&amp; src) -&gt; std::multimap&lt;B, A&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ae89ad400e8727632059aab318889c52c" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::unordered_map&lt;Key, T, Hash, Eq&gt;&amp; m) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a83a3ea3cbfff05077720e57248499285" class="m-dox">concat</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; src,
              std::vector&lt;T&gt;&amp; dst)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#af231098ad11edf863aa62151ba458522" class="m-dox">concat</a>(</span><span class="m-dox-wrap">const std::unordered_set&lt;Key, Hash, Eq&gt;&amp; src,
              std::unordered_set&lt;Key, Hash, Eq&gt;&amp; dst)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac371117af5d2009dca83a8cb5539a43f" class="m-dox">mergeHashMap</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae484074849c5c9532282fc9fa4e19467" class="m-dox">linearLoadDistributor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> virtualization,
              uint64_t load,
              int npe,
              uint64_t&amp; chunksize,
              uint64_t&amp; remainder) -&gt; uint64_t</span>
            </dt>
            <dd>Compute linear load distribution for given total work and virtualization.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a1bbb9b08d37f6f5f3bed45effc8fc64e" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::vector&lt;T&gt;&amp; t) -&gt; std::basic_ostream&lt;Ch, Tr&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Msg&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a5d61711de49d010da4785f7cb6ad2d9b" class="m-dox">waitfor</a>(</span><span class="m-dox-wrap">const CkFuture&amp; f) -&gt; <a href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41" class="m-dox">Msg::<wbr />value_type</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a4d5bfee8e8bdea2bc60e5d725672af09" class="m-dox">rm</a>(</span><span class="m-dox-wrap">const std::string&amp; file)</span>
            </dt>
            <dd>Remove file from file system.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad0ed65df66049a89a8a5055895ae417a" class="m-dox">signalHandler</a>(</span><span class="m-dox-wrap">int signum)</span>
            </dt>
            <dd>Signal handler for multiple signals, SIGABRT, SIGSEGV, etc.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5e8c72da5967d8fb725ff4a26294a871" class="m-dox">setSignalHandlers</a>(</span><span class="m-dox-wrap">) -&gt; int</span>
            </dt>
            <dd>Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#af04df49334286e653e440035c499a8d1" class="m-dox">processExceptionCharm</a>(</span><span class="m-dox-wrap">)</span>
            </dt>
            <dd>Process an exception from the Charm++ runtime system.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a2a62b5b6880fbd0a011cedf8896b19dc" class="m-dox">processExceptionMPI</a>(</span><span class="m-dox-wrap">)</span>
            </dt>
            <dd>Process an exception from the MPI runtime system.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aa7d376e7f0dd51a64632432345dd4423" class="m-dox">swap_endian</a>(</span><span class="m-dox-wrap">T u) -&gt; T</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a550509206419175e2b2277bc5c18016e" class="m-dox">swap_endian</a>(</span><span class="m-dox-wrap">double u) -&gt; double</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr, typename std::enable_if&lt;!std::is_enum&lt;T&gt;::value, int&gt;::type = 0&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a573c983b9ed9b0e4fd05ba46121aee50" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const T&amp; e) -&gt; std::basic_ostream&lt;Ch, Tr&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aa160d13ea2e4a3498916472c3b6cdbb0" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp; lhs,
              const T&amp; e) -&gt; std::basic_string&lt;Ch, Tr&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp;&amp; lhs,
              const T&amp; e) -&gt; std::basic_string&lt;Ch, Tr&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a28a553d30e4fd16f06342dd643d26c25" class="m-dox">sample</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> x,
              const <a href="namespacetk.html#a4a3683fffc858642385d1292c3817021" class="m-dox">tk::<wbr />Table</a>&amp; table) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a></span>
            </dt>
            <dd>Sample a discrete y = f(x) function at x.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad6260a3dcdcb9a995a4886e566b665c4" class="m-dox">hms</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> stamp) -&gt; <a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">Timer::<wbr />Watch</a></span>
            </dt>
            <dd>Convert existing time stamp as a real to Watch (global scope)</dd>
            <dt>
              <div class="m-dox-template">template&lt;class ProxyElem, class Proxy&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a928d7dd976738fc1e3de5f4ee6147140" class="m-dox">element</a>(</span><span class="m-dox-wrap">const Proxy&amp; proxy,
              const CkArrayIndex1D&amp; x) -&gt; ProxyElem</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ab602857e33f89cab4cc3788576ab1519" class="m-dox">cross</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2) -&gt; std::array&lt;T, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a77ef9600b5075a8bbee89b6e4991fd69" class="m-dox">crossdiv</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2,
              T j) -&gt; std::array&lt;T, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aeaca2df70ee950c576f6d74e1eb42caa" class="m-dox">dot</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2) -&gt; T</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ae5b04b00aa51667b944b7188545ec5ae" class="m-dox">triple</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2,
              const std::array&lt;T, 3&gt;&amp; v3) -&gt; T</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab33ea32478ab229dc49f14585c74fec2" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; v) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd>Serialize std::vector to raw memory stream.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adb0ded68a9723df3debe38af3634e139" class="m-dox">mergeVector</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging std::vectors during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a485fc849f142f0ee38055fad224206d6" class="m-dox">detectInput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename) -&gt; <a href="namespacetk.html#a8e37e8d13562df3379a730217f735255" class="m-dox">MeshReaderType</a></span>
            </dt>
            <dd>Detect input mesh file type.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6bcaad9b4f5b0aa6e5792f9ccacf8d79" class="m-dox">pickOutput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename) -&gt; <a href="namespacetk.html#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox">MeshWriterType</a></span>
            </dt>
            <dd>Determine output mesh file type.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af947865970b76333655208aea71ceb71" class="m-dox">readUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; timestamp) -&gt; <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a></span>
            </dt>
            <dd>Read unstructured mesh from file.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a92ff858133bdb654de9b95c279427325" class="m-dox">writeUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>&amp; mesh,
              bool reorder) -&gt; std::vector&lt;std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Write unstructured mesh to file.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a20ee8c554da198c14efbb80a0b623a4a" class="m-dox">SiloError</a>(</span><span class="m-dox-wrap">char* msg)</span>
            </dt>
            <dd>Silo error handler.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static auto <a href="#a8e567fa9a72a1d5d02cea9eb020b192a" class="m-dox">workdir</a>(</span><span class="m-dox-wrap">) -&gt; std::string</span>
            </dt>
            <dd>Wrapper for POSIX API&#x27;s getcwd() from unistd.h.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static auto <a href="#a69ebefad09fa900014b6271b30e8bd5f" class="m-dox">curtime</a>(</span><span class="m-dox-wrap">) -&gt; std::string</span>
            </dt>
            <dd>Wrapper for the standard C library&#x27;s gettimeofday() from.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static void <a href="#afbbf10b984ba3f66b55cc8363c6a2341" class="m-dox">echoHeader</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header)</span>
            </dt>
            <dd>Echo program header.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static void <a href="#ab72923dba604ccbf4233af3ccafc70b3" class="m-dox">echoBuildEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              const std::string&amp; executable)</span>
            </dt>
            <dd>Echo build environment.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static void <a href="#a575873ee9074d8c75f3e82f2ece02c3b" class="m-dox">echoRunEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              int argc,
              char** argv,
              bool verbose,
              bool quiescence)</span>
            </dt>
            <dd>Echo runtime environment.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class Driver, class Printer, class CmdLine&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#af9d21933fc9e1a656db37419b2173f5f" class="m-dox">Main</a>(</span><span class="m-dox-wrap">int argc,
              char* argv[],
              const CmdLine&amp; cmdline,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header,
              const std::string&amp; executable,
              const Printer&amp; print) -&gt; Driver</span>
            </dt>
            <dd>Generic <a href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" class="m-dox">Main()</a> used for all executables for code-reuse and a uniform output.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#abdd71f3e10edf6e1a8d047478abd488c" class="m-dox">npoin</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel) -&gt; std::size_t</span>
            </dt>
            <dd>Compute number of points (nodes) in mesh from connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">genEsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad2a88a65102c17149b44660db15d445b" class="m-dox">genPsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, points surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">genEdsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, edges surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">genInpoed</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, edge connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9d835a7a93970d17a66356b64f3291af" class="m-dox">genEsupel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding points of elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7b12aff8f884c70e45c6037b4f37e662" class="m-dox">genEsuel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7c8a720dd257388a44d5ca7af7aaec8f" class="m-dox">genInedel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::vector&lt;std::size_t&gt;&amp; inpoed) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, edges of elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#abff39252e99681eebb5ccf0078b7b924" class="m-dox">genEsued</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding edges.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab68c15dd976b0c7420ebee8770fb1f9c" class="m-dox">genNbfacTet</a>(</span><span class="m-dox-wrap">std::size_t tnbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel_complete,
              const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface_complete,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; lid,
              std::vector&lt;std::size_t&gt;&amp; triinpoel,
              std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface) -&gt; std::size_t</span>
            </dt>
            <dd>Generate total number of boundary faces in this chunk.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5b61b3cb6492e71ff9853404440fddcc" class="m-dox">genEsuelTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;int&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a94114220a51c1ba65f5f1e8314ffc27e" class="m-dox">genNtfac</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nbfac,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::size_t</span>
            </dt>
            <dd>Generate derived data structure, total number of faces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae2d934afca4d36661acc1b3e6f863f05" class="m-dox">genEsuf</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t ntfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; belem,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::vector&lt;int&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding faces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae501950a1a32199708b69a52382f1b1e" class="m-dox">genInpofaTet</a>(</span><span class="m-dox-wrap">std::size_t ntfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, node-face connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888" class="m-dox">genBelemTet</a>(</span><span class="m-dox-wrap">std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, host/boundary element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a61a2eebfe3b1f67bafb3131442ffffa1" class="m-dox">genGeoFaceTri</a>(</span><span class="m-dox-wrap">std::size_t ntfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; tk::Fields</span>
            </dt>
            <dd>Generate derived data structure, face geometry.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a33792d596875801d33c16acc28eb497f" class="m-dox">normal</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; z) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute the unit normal vector of a triangle.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a51f7ec47d21ee4be4ef5a6e58fdd4776" class="m-dox">geoFaceTri</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; z) -&gt; tk::Fields</span>
            </dt>
            <dd>Compute geometry of the face given by three vertices.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af33c6a2dc1649b840ab82bfcd3d1617a" class="m-dox">genGeoElemTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; tk::Fields</span>
            </dt>
            <dd>Generate derived data structure, element geometry.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8b04469b1f0015a5322697e83617ca6d" class="m-dox">leakyPartition</a>(</span><span class="m-dox-wrap">const std::vector&lt;int&gt;&amp; esueltet,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; bool</span>
            </dt>
            <dd>Perform leak-test on mesh (partition)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aae5766a4d0dae70d561c514f2758072e" class="m-dox">nodegrad</a>(</span><span class="m-dox-wrap">std::size_t node,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4" class="m-dox">ncomp_<wbr />t</a> c) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute gradient at a mesh node.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8deceeef86846672dd872bb7e975bb13" class="m-dox">edgegrad</a>(</span><span class="m-dox-wrap">std::size_t edge,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esued,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4" class="m-dox">ncomp_<wbr />t</a> c) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute gradient at a mesh edge.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1" class="m-dox">shiftToZero</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; inpoel) -&gt; std::size_t</span>
            </dt>
            <dd>Shift node IDs to start with zero in element connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a261ac7b3e006f7fa6621ad910b6553cc" class="m-dox">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; id,
              const std::vector&lt;std::size_t&gt;&amp; map)</span>
            </dt>
            <dd>Apply new mapping to vector of indices.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd" class="m-dox">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; r,
              const std::vector&lt;std::size_t&gt;&amp; map)</span>
            </dt>
            <dd>Apply new mapping to vector of real numbers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a22a8b455edb4f8453d5a6173319f9c80" class="m-dox">renumber</a>(</span><span class="m-dox-wrap">const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; psup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Reorder mesh points with the advancing front technique.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#acb19d7c5f6c7354614bb457d6b17afde" class="m-dox">assignLid</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; gid) -&gt; std::unordered_map&lt;std::size_t, std::size_t&gt;</span>
            </dt>
            <dd>Assign local ids to global ids.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0ee7abd71123782d48e2ec04906fe982" class="m-dox">global2local</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ginpoel) -&gt; std::tuple&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;, std::unordered_map&lt;std::size_t, std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6c5589db5d1caeac294a0b1569b65ebd" class="m-dox">positiveJacobians</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord) -&gt; bool</span>
            </dt>
            <dd>Test positivity of the Jacobian for all cells in a mesh.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a1f585439fa7abf61b26704881e98a168" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd>Serialize univariate PDF to raw memory stream.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a24204b4ddfb41147330f02a8e6e7b760" class="m-dox">mergeUniPDFs</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging a univariate PDF during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a95434266ed0be6503251e90e0fe60823" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u,
              const std::vector&lt;<a href="classtk_1_1_bi_p_d_f.html" class="m-dox">tk::<wbr />BiPDF</a>&gt;&amp; b,
              const std::vector&lt;<a href="classtk_1_1_tri_p_d_f.html" class="m-dox">tk::<wbr />TriPDF</a>&gt;&amp; t) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd>Serialize vectors of PDFs to raw memory stream.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab8753a2df233c9b1327d5682940ddcbf" class="m-dox">mergePDF</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging PDFs during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static auto <a href="#ac0a63cccd84b6bd8b998cb4282adac23" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&amp; p) -&gt; std::ostream&amp;</span>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section id="var-members">
          <h2><a href="#var-members">Variables</a></h2>
          <dl class="m-dox">
            <dt>const uint8_t <a href="#a78da814ef7132a0958c47f987e3e711c" class="m-dox-self" name="a78da814ef7132a0958c47f987e3e711c">UnkEqComp</a></dt>
            <dd>Tags for selecting data layout policies.</dd>
            <dt>const std::array&lt;std::size_t, 2&gt; <a href="#afc6a4dbf99954fbde58f895283a8de43" class="m-dox">ExoNnpe</a></dt>
            <dd></dd>
            <dt>const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; <a href="#a9445a95368496196e7c7560eccadbb09" class="m-dox">expofa</a></dt>
            <dd></dd>
            <dt>const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; <a href="#a30ac7c57927d6134e6563817f5d005a0" class="m-dox">lpofa</a></dt>
            <dd></dd>
            <dt>static highwayhash::HH_U64 <a href="#a07af9a3d86b90e1861bd16ded6a6ae87" class="m-dox">hh_key</a> <span class="m-label m-flat m-primary">constexpr</span></dt>
            <dd></dd>
          </dl>
        </section>
        <section>
          <h2>Enum documentation</h2>
          <section class="m-dox-details" id="afcc275d91d4368505f221061b9ba822a"><div>
            <h3>
              enum tk::<wbr /><a href="#afcc275d91d4368505f221061b9ba822a" class="m-dox-self">ErrCode</a>
            </h3>
            <p>Error codes for the OS (or whatever calls us)</p>
            <table class="m-table m-fullwidth m-flat m-dox">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" class="m-dox-self" name="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a></td>
                  <td>
                  <p>Everything went fine.</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" class="m-dox-self" name="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a></td>
                  <td>
                  <p>Exceptions occurred.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a3781b50ef71ead8dd0bd286455c6030c"><div>
            <h3>
              enum class tk::<wbr /><a href="#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox-self">ExoElemType</a>: int
            </h3>
<p>Supported ExodusII mesh cell types</p><aside class="m-note m-default"><h4>See also</h4><p><a href="classtk_1_1_exodus_i_i_mesh_reader.html#afe8144814a95bbb94d87e04091042918" class="m-dox">ExodusIIMeshReader::<wbr />readElemBlockIDs()</a></p></aside>
            <table class="m-table m-fullwidth m-flat m-dox">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a></td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a></td>
                  <td>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
        </section>
        <section>
          <h2>Typedef documentation</h2>
          <section class="m-dox-details" id="a30c00988310413e9b96e131f8332b2b0"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class li, class lo&gt;
              </div>
              using tk::<wbr /><a href="#a30c00988310413e9b96e131f8332b2b0" class="m-dox-self">cartesian_product</a> = brigand::reverse_fold&lt;brigand::list&lt;li, lo&gt;, brigand::list&lt;brigand::list&lt;&gt;&gt;, brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::_2, brigand::defer&lt;brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::parent&lt;brigand::_1&gt;, brigand::defer&lt;brigand::bind&lt;brigand::list, brigand::bind&lt;brigand::push_front, brigand::_1, brigand::parent&lt;brigand::_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            </h3>
<p>Cartesian product of two brigand lists</p><aside class="m-note m-default"><h4>See also</h4><p>brigand_source/test/apply.cpp</p></aside>
          </div></section>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-dox-details" id="a87af1b002bc711716bd170a714bda211"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a87af1b002bc711716bd170a714bda211" class="m-dox-self">unique</a>(</span><span class="m-dox-wrap">Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Container</td>
                </tr>
              </tbody>
            </table>
<p>Make elements of container unique (in-place, overwriting source container)</p>
          </div></section>
          <section class="m-dox-details" id="a33be2bf221a519d736333a9f18c8ffdc"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">Container tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a33be2bf221a519d736333a9f18c8ffdc" class="m-dox-self">uniquecopy</a>(</span><span class="m-dox-wrap">const Container&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Container containing only unique elements compared to src</td>
                </tr>
              </tfoot>
            </table>
<p>Make elements of container unique (on a copy, leaving the source as is)</p>
          </div></section>
          <section class="m-dox-details" id="af0de4157a7818da7a9deb1476099bd8d"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;T, 2&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af0de4157a7818da7a9deb1476099bd8d" class="m-dox-self">extents</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; vec)</span></span>
            </h3>
            <p>Return minimum and maximum values of a vector.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">vec&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector whose extents to compute</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of two values with the minimum and maximum values</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This function should not be called with heavy T types, as the a copy of a std::array&lt; T, 2 &gt; is created and returned.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad47c993218d9384828fcce2794850ac7"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T, class Allocator&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::vector&lt;T, Allocator&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad47c993218d9384828fcce2794850ac7" class="m-dox-self">operator+=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src)</span></span>
            </h3>
            <p>Add all elements of a vector to another one.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector, i.e., left-hand side of v1 += v2</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source vector, i.e., righ-hand side of v1 += v2</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Destination containing v1[0] += v2[0], v1[1] += v2[1], ...</td>
                </tr>
              </tfoot>
            </table>
<p>If src.size() &gt; dst.size() will grow dst to that of src.size() padding with zeros.</p><aside class="m-note m-info"><h4>Note</h4><p>Will throw exception in DEBUG if src is empty (to warn on no-op), and if src.size() &lt; dst.size() (to warn on loosing data).</p></aside>
          </div></section>
          <section class="m-dox-details" id="a05866fa57031940dc4ba5d4665847016"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class C1, class C2&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a05866fa57031940dc4ba5d4665847016" class="m-dox-self">keyEqual</a>(</span><span class="m-dox-wrap">const C1&amp; a,
              const C2&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st container to compare</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd container to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if the containers have the same size and all keys (and only the keys) of the two containers are equal</td>
                </tr>
              </tfoot>
            </table>
<p>Test if all keys of two associative containers are equal</p><aside class="m-note m-info"><h4>Note</h4><p>It is an error to call this function with unequal-size containers, triggering an exception in DEBUG mode.</p><p>Operator != is used to compare the container keys.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a0f319a47a6a5b983e161aa5f4d8f7b6c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c" class="m-dox-self">sumsize</a>(</span><span class="m-dox-wrap">const Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container of containers</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Sum of the sizes of the containers of the container</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the sum of the sizes of a container of containers</p>
          </div></section>
          <section class="m-dox-details" id="a357e40550c113066882bc3e3c3cf52b8"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Map&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a357e40550c113066882bc3e3c3cf52b8" class="m-dox-self">sumvalsize</a>(</span><span class="m-dox-wrap">const Map&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Map</td>
                  <td>Container of containers type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container of containers</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Sum of the sizes of the values of the associative container</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the sum of the sizes of the values of an associative container</p>
          </div></section>
          <section class="m-dox-details" id="a9140b408dcbd2eaef58f9c3a54fa104a"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9140b408dcbd2eaef58f9c3a54fa104a" class="m-dox-self">destroy</a>(</span><span class="m-dox-wrap">Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container defining a swap() member function</td>
                </tr>
              </tbody>
            </table>
<p>Free memory of a container 
See <a href="http://stackoverflow.com/a/10465032">http:/<wbr />/<wbr />stackoverflow.com/<wbr />a/<wbr />10465032</a> as to why this is done with the swap() member function of the container.</p><aside class="m-note m-default"><h4>See also</h4><p>Specializations of std::swap are documented at <a href="http://en.cppreference.com/w/cpp/algorithm/swap">http:/<wbr />/<wbr />en.cppreference.com/<wbr />w/<wbr />cpp/<wbr />algorithm/<wbr />swap</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="a38a390b2dd9f091d2ca7465208a960ed"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Container, typename Predicate&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a38a390b2dd9f091d2ca7465208a960ed" class="m-dox-self">erase_if</a>(</span><span class="m-dox-wrap">Container&amp; items,
              const Predicate&amp; predicate)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Container</td>
                  <td>Type of container to remove from</td>
                </tr>
                <tr>
                  <td>Predicate</td>
                  <td>Type for functor defining the predicate</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>items</td>
                  <td>Container object to remove from</td>
                </tr>
                <tr>
                  <td>predicate</td>
                  <td>Predicate object instance to use</td>
                </tr>
              </tbody>
            </table>
<p>Remove items from container based on predicate</p>
          </div></section>
          <section class="m-dox-details" id="adc362fc7a89c617e1ab8f57f1dbd100a"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adc362fc7a89c617e1ab8f57f1dbd100a" class="m-dox-self">operator*</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar to multiply with</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Date object to multiply</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object with all items multipled with lhs</td>
                </tr>
              </tfoot>
            </table>
<p>Operator * multiplying all items by a scalar from the left</p>
          </div></section>
          <section class="m-dox-details" id="afd730d099e698f124362ef8c01483e0f"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#afd730d099e698f124362ef8c01483e0f" class="m-dox-self">min</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object containing the minimum of all values for each value in <em>a</em> and <em>b</em></td>
                </tr>
              </tfoot>
            </table>
<p>Operator min between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties.</p><p>As opposed to std::min, this function creates and returns a new object instead of returning a reference to one of the operands.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ac9a26e30d19b940a12990a866a514cb5"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac9a26e30d19b940a12990a866a514cb5" class="m-dox-self">max</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object containing the maximum of all values for each value in <em>a</em> and <em>b</em></td>
                </tr>
              </tfoot>
            </table>
<p>Operator max between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties.</p><p>As opposed to std::max, this function creates and returns a new object instead of returning a reference to one of the operands.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a21669e4d06c62a58cd0f4bf63868ab7e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a21669e4d06c62a58cd0f4bf63868ab7e" class="m-dox-self">operator==</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if all entries are equal up to epsilon</td>
                </tr>
              </tfoot>
            </table>
<p>Operator == between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p>
          </div></section>
          <section class="m-dox-details" id="ac38f5055c45cd35b8ce00151cea4c1d3"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac38f5055c45cd35b8ce00151cea4c1d3" class="m-dox-self">operator!=</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if all entries are unequal up to epsilon</td>
                </tr>
              </tfoot>
            </table>
<p>Operator != between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p>
          </div></section>
          <section class="m-dox-details" id="ab7f02155bc2945a0a0c82c1be5cad041"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::size_t, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab7f02155bc2945a0a0c82c1be5cad041" class="m-dox-self">maxdiff</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The index, i.e., the raw position, of and the largest absolute value of the difference between all corresponding elements of <em>lhs</em> and <em>rhs</em>.</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the maximum difference between the elements of two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects 

The position returned is the position in the underlying raw data structure, independent of components, offsets, etc. If lhs == rhs with precision std::numeric_limits&lt; tk::real &gt;::epsilon(), a pair of (0,0.0) is returned.</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>lhs</em> and <em>rhs</em> must have the same number of unknowns and properties.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad986ef5558d44d5e0c6650c589499980"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class C, class Key, class Factory, typename... ConstructorArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad986ef5558d44d5e0c6650c589499980" class="m-dox-self">record</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ConstructorArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using reference semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using reference semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by function instantiate.</td>
                </tr>
              </tbody>
            </table>
<p>Register class into factory with given key. This is used to register a derived-class object&#x27;s constructor (deriving from some base class) to a factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;, i.e., an associative container, associating some key to a std::function object holding a pointer of Child&#x27;s base class constructor. The constructor and its bound arguments are stored via boost::factory, which, in this use-case, yields the correct function object of type Base constructor pointer and thus facilitates runtime polymorphism. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h.</p><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#aeb9673379e599043b13fff369dce1402" class="m-dox">instantiate</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="aeb9673379e599043b13fff369dce1402"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Factory, class Key, class Obj = typename std::remove_pointer&lt;                       typename Factory::mapped_type::result_type&gt;::type&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::unique_ptr&lt;Obj&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aeb9673379e599043b13fff369dce1402" class="m-dox-self">instantiate</a>(</span><span class="m-dox-wrap">const Factory&amp; f,
              const Key&amp; key)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to instantiate object from (std::map with value using reference semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the object to instantiate from factory</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::unique_ptr pointing to the object instantiated from factory</td>
                </tr>
              </tfoot>
            </table>
<p>Instantiate object from factory. Factory must have a mapped_value which must have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This wrapper function can be used to instantiate an derived-class object from a factory, repeatedly filled with wrapper function &#x27;record&#x27; above. The factory, as described in the documentation of &#x27;record&#x27;, stores base class pointers in an associative container, thereby facilitating runtime polymorphism and a simple lookup-and-instantiate-style object creation. The object instantiated is of type Child class. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h.</p><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980" class="m-dox">record</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="a24170c3146caaa7b79d78d4aa1d98f66"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a24170c3146caaa7b79d78d4aa1d98f66" class="m-dox-self">recordModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using value semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by simply calling the function call operator () on the mapped value. For an example, <a href="classtk_1_1_r_n_g_stack.html#ab1c30742819f7c22826dcce8c620539f" class="m-dox">RNGStack::<wbr />selected()</a> in <a href="_r_n_g_stack_8_c.html" class="m-dox">RNG/<wbr />RNGStack.C</a>.</td>
                </tr>
              </tbody>
            </table>
<p>Register &quot;model&quot; class of &quot;host&quot; into factory with given key. This wrapper can be used to in a similar manner to &#x27;record&#x27;, but uses boost::value_factory to bind the model object constructor to its arguments and place it in the associative container storing host class objects. The container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e., associating a key to a function holding a constructor (and not its pointer). Runtime polymorphism here is realized entirely within the &quot;base&quot; class. See <a href="classwalker_1_1_diff_eq.html" class="m-dox">walker::<wbr />DiffEq</a> in <a href="_diff_eq_2_diff_eq_8h.html" class="m-dox">DiffEq/<wbr />DiffEq.h</a> for an example and more information on runtime polymorphism without client-side inheritance. As a result, this wrapper works with factories that use value semantics, as opposed to &#x27;record&#x27; and instantiate which work with reference semantics factories. In order to differentiate between runtime polymorphic classes using reference semantics, consistent with classes realizing runtime polymorphism without client-side inheritance, we call Host as the &quot;Base&quot; class and Model as the &quot;derived&quot; (or child) class. This wrapper function works in conjunction with boost::value_factory, i.e., uses value semantics (works with storing objects instead of object pointers). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h.</p>
          </div></section>
          <section class="m-dox-details" id="ae98b4e55f14339c707622a8da43d8ce9"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key, typename ModelConstrArg&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae98b4e55f14339c707622a8da43d8ce9" class="m-dox-self">recordModelLate</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArg)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
              </tbody>
            </table>
<p>Register model class of host into factory with given key using late binding. This variant of &#x27;record&#x27; is very similar to &#x27;recordModel&#x27;, but registers a model class constructor to a factory with late binding of the constructor argument. Late binding allows specifying the constructor argument at the time when the object is instantiated instead of at the time when it is registered. This has all the benefits of using a factory and allows passing information into the model object only when it is available. The late bind is facilitated via boost::bind instead of std::bind using a placeholder, _1, which stands for the first argument (bound later, i.e., not here). The value of the model constructor argument is then not used here, only its type, used to perform the late binding. The binding happens to both the model constructor via std::function (passed to the host constructor) as well as explicitly to the host constructor. Prescribing late binding to the model constructor ensures that the compiler requires the argument to the model constructor, i.e., ensures that the host constructor is required to pass the argument to the model constructor. Prescribing late binding to the host constructor puts in the actual request that an argument (with the correct type) must be passed to the host constructor at instantiate time, which then will forward it to the model constructor. See also, for example, <a href="classwalker_1_1_diff_eq.html" class="m-dox">walker::<wbr />DiffEq</a>&#x27;s corresponding constructor. An example of client-side code is in walker::DiffEqStack::registerDiffEq for registration into factory, and DiffEqStack::createDiffEq for instantiation late-passing the argument.</p><aside class="m-note m-danger"><h4>Warning</h4><p>Only works with a single constructor argument</p></aside>
          </div></section>
          <section class="m-dox-details" id="a4bd6374b4792dbd3c626dad60bcef168"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a4bd6374b4792dbd3c626dad60bcef168" class="m-dox-self">recordCharmModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered.</td>
                </tr>
              </tbody>
            </table>
<p>Register Charm++ model class of host into factory with given key. We bind a host constructor to its arguments of which the first one is a std::function holding a model constructor type (modeling, i.e., used polymorhically with host), followed by an optional number of others (possibly zero) with arbitrary types. Note that the model constructor is a nullptr (default- constructed) and only used to forward its type to the call site inside std::function. The host constructor function is then placed into the factory. This is because Charm++ chares do not explicitly invoke constructors, only call ckNew() on their proxy, which requires all constructor arguments to be present and forwarded to the actual constructor that is only called at a later point in time. This can then be used by those constructors of hosts that invoke the model constructors&#x27; proxies&#x27; ckNew() and ignore the std::function. See, e.g., <a href="classrngtest_1_1_battery.html" class="m-dox">rngtest::<wbr />Battery()</a> and the associated unit tests in UnitTest/tests/Base/Factory.h.</p>
          </div></section>
          <section class="m-dox-details" id="ac2323b3c43edbcc32d55d91100ffc3a6"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename A, typename B&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;B, A&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac2323b3c43edbcc32d55d91100ffc3a6" class="m-dox-self">flip_pair</a>(</span><span class="m-dox-wrap">const std::pair&lt;A, B&gt;&amp; p)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">p&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>std::pair of arbitrary types, A and B</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::pair of arbitrary types, B and A</td>
                </tr>
              </tfoot>
            </table>
<p>Flip a std::pair of arbitrary types</p>
          </div></section>
          <section class="m-dox-details" id="a42982d289f8edfffa60fa4da8b7b9fdf"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename A, typename B&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::multimap&lt;B, A&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a42982d289f8edfffa60fa4da8b7b9fdf" class="m-dox-self">flip_map</a>(</span><span class="m-dox-wrap">const std::map&lt;A, B&gt;&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>std::map of arbitrary key and value pairs of types A and B</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::multimap of arbitrary key and value pairs of types B and A</td>
                </tr>
              </tfoot>
            </table>
<p>Flip a std::map of arbitrary types, yielding a std::multimap sorted by std::map::value_type.</p>
          </div></section>
          <section class="m-dox-details" id="ae89ad400e8727632059aab318889c52c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae89ad400e8727632059aab318889c52c" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::unordered_map&lt;Key, T, Hash, Eq&gt;&amp; m)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Map key</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>Map value</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Map hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Map equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>m&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Hash map to serialize</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized map</td>
                </tr>
              </tfoot>
            </table>
<p>Serialize std::unordered_map to raw memory stream</p>
          </div></section>
          <section class="m-dox-details" id="a83a3ea3cbfff05077720e57248499285"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a83a3ea3cbfff05077720e57248499285" class="m-dox-self">concat</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; src,
              std::vector&lt;T&gt;&amp; dst)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>Vector value type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source vector</td>
                </tr>
                <tr>
                  <td>dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector</td>
                </tr>
              </tbody>
            </table>
<p>Concatenate vectors</p>
          </div></section>
          <section class="m-dox-details" id="af231098ad11edf863aa62151ba458522"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af231098ad11edf863aa62151ba458522" class="m-dox-self">concat</a>(</span><span class="m-dox-wrap">const std::unordered_set&lt;Key, Hash, Eq&gt;&amp; src,
              std::unordered_set&lt;Key, Hash, Eq&gt;&amp; dst)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Set key</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Set hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Set equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source set</td>
                </tr>
                <tr>
                  <td>dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination set</td>
                </tr>
              </tbody>
            </table>
<p>Concatenate unordered sets</p>
          </div></section>
          <section class="m-dox-details" id="ac371117af5d2009dca83a8cb5539a43f"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac371117af5d2009dca83a8cb5539a43f" class="m-dox-self">mergeHashMap</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Map key</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>Map value</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Map hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Map equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized maps</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated std::unordered_maps built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
<p>During aggregation the map keys are inserted, i.e., the keys remain unique and the mapped values, assuming containers defining begin() and end() iterators() are concatenated.</p><aside class="m-note m-info"><h4>Note</h4><p>The mapped type must be a container, i.e., must provide iterators begin() and end().</p></aside>
          </div></section>
          <section class="m-dox-details" id="ae484074849c5c9532282fc9fa4e19467"><div>
            <h3>
              <span class="m-dox-wrap-bumper">uint64_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae484074849c5c9532282fc9fa4e19467" class="m-dox-self">linearLoadDistributor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> virtualization,
              uint64_t load,
              int npe,
              uint64_t&amp; chunksize,
              uint64_t&amp; remainder)</span></span>
            </h3>
            <p>Compute linear load distribution for given total work and virtualization.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">virtualization&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Degree of virtualization [0.0...1.0]</td>
                </tr>
                <tr>
                  <td>load&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total load, e.g., number of particles, number of mesh cells</td>
                </tr>
                <tr>
                  <td>npe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of processing elements to distribute the load to</td>
                </tr>
                <tr>
                  <td>chunksize&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Chunk size, see detailed description</td>
                </tr>
                <tr>
                  <td>remainder&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Remainder, see detailed description</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of work units</td>
                </tr>
              </tfoot>
            </table>
<p>Compute load distibution (number of chares and chunksize) based on total work (e.g., total number of particles) and virtualization</p><p>The virtualization parameter, specified by the user, is a real number between 0.0 and 1.0, inclusive, which controls the degree of virtualization or over-decomposition. Independent of the value of virtualization the work is approximately evenly distributed among the available processing elements, given by npe. For zero virtualization (no over-decomposition), the work is simply decomposed into total_work/numPEs, which yields the smallest number of Charm++ chares and the largest chunks of work units. The other extreme is unity virtualization, which decomposes the total work into the smallest size work units possible, yielding the largest number of Charm++ chares. Obviously, the optimum will be between 0.0 and 1.0, depending on the problem.</p><p>The formula implemented uses a linear relationship between the virtualization parameter and the number of work units with the extremes described above. The formula is given by</p><p>chunksize = (1 - n) * v + n;</p><p>where</p><ul><li>v = degree of virtualization</li><li>n = load/npes</li><li>load = total work, e.g., number of particles, number of mesh cells</li><li>npes = number of hardware processing elements</li></ul>
          </div></section>
          <section class="m-dox-details" id="a1bbb9b08d37f6f5f3bed45effc8fc64e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_ostream&lt;Ch, Tr&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1bbb9b08d37f6f5f3bed45effc8fc64e" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::vector&lt;T&gt;&amp; t)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output stream to write to</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>std::vector of arbitrary type T to write to stream</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for writing std::vector&lt; T &gt; to output streams; for debugging.</p>
          </div></section>
          <section class="m-dox-details" id="a5d61711de49d010da4785f7cb6ad2d9b"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Msg&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41" class="m-dox">Msg::<wbr />value_type</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5d61711de49d010da4785f7cb6ad2d9b" class="m-dox-self">waitfor</a>(</span><span class="m-dox-wrap">const CkFuture&amp; f)</span></span>
            </h3>
<p>Wait for and return future. Concept: <a href="structtk_1_1_msg.html" class="m-dox">Msg</a> must have public function get() returning <a href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41" class="m-dox">Msg::<wbr />value_type</a>.</p>
          </div></section>
          <section class="m-dox-details" id="a4d5bfee8e8bdea2bc60e5d725672af09"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a4d5bfee8e8bdea2bc60e5d725672af09" class="m-dox-self">rm</a>(</span><span class="m-dox-wrap">const std::string&amp; file)</span></span>
            </h3>
            <p>Remove file from file system.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">file&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>File name to delete (shell wildcards NOT expanded)</td>
                </tr>
              </tbody>
            </table>
<p>Since we use pstream&#x27;s basic_ipstream constructor with signature ( const std::string &amp; file, const argv_type &amp; argv, pmode mode = pstdout ) and the file argument doesn&#x27;t contain a slash, the actions of the shell are duplicated in searching for an executable in PATH. The shell will not interpret the other arguments, so wildcard expansion will not take place.</p>
          </div></section>
          <section class="m-dox-details" id="ad0ed65df66049a89a8a5055895ae417a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad0ed65df66049a89a8a5055895ae417a" class="m-dox-self">signalHandler</a>(</span><span class="m-dox-wrap">int signum)</span></span>
            </h3>
            <p>Signal handler for multiple signals, SIGABRT, SIGSEGV, etc.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">signum&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Signal number</td>
                </tr>
              </tbody>
            </table>
<aside class="m-note m-default"><h4>See also</h4><p><a href="https://oroboro.com/stack-trace-on-crash">https:/<wbr />/<wbr />oroboro.com/<wbr />stack-trace-on-crash</a></p></aside><p>Signals caught: SIGABRT is generated when the program calls the abort() function, such as when an assert() triggers SIGSEGV is generated when the program makes an illegal memory access, such as reading unaligned memory, dereferencing a null pointer, reading memory out of bounds etc. SIGILL is generated when the program tries to execute a malformed instruction. This happens when the execution pointer starts reading non-program data, or when a pointer to a function is corrupted. SIGFPE is generated when executing an illegal floating point instruction, most commonly division by zero or floating point overflow.</p>
          </div></section>
          <section class="m-dox-details" id="a5e8c72da5967d8fb725ff4a26294a871"><div>
            <h3>
              <span class="m-dox-wrap-bumper">int tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5e8c72da5967d8fb725ff4a26294a871" class="m-dox-self">setSignalHandlers</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>Ignore, used for calling in a constructor&#x27;s initializer list</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="af04df49334286e653e440035c499a8d1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af04df49334286e653e440035c499a8d1" class="m-dox-self">processExceptionCharm</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Process an exception from the Charm++ runtime system.</p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012.</p>
          </div></section>
          <section class="m-dox-details" id="a2a62b5b6880fbd0a011cedf8896b19dc"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a2a62b5b6880fbd0a011cedf8896b19dc" class="m-dox-self">processExceptionMPI</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Process an exception from the MPI runtime system.</p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012.</p>
          </div></section>
          <section class="m-dox-details" id="aa7d376e7f0dd51a64632432345dd4423"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">T tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa7d376e7f0dd51a64632432345dd4423" class="m-dox-self">swap_endian</a>(</span><span class="m-dox-wrap">T u)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Integral type to convert</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Converted integer</td>
                </tr>
              </tfoot>
            </table>
<p>Swap endianness of an integral type</p>
          </div></section>
          <section class="m-dox-details" id="a550509206419175e2b2277bc5c18016e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">double tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a550509206419175e2b2277bc5c18016e" class="m-dox-self">swap_endian</a>(</span><span class="m-dox-wrap">double u)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Double to convert</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Converted double</td>
                </tr>
              </tfoot>
            </table>
<p>Swap endianness of a double</p>
          </div></section>
          <section class="m-dox-details" id="a573c983b9ed9b0e4fd05ba46121aee50"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr, typename std::enable_if&lt;!std::is_enum&lt;T&gt;::value, int&gt;::type = 0&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_ostream&lt;Ch, Tr&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a573c983b9ed9b0e4fd05ba46121aee50" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const T&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output stream into which t is written</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of arbitrary non-enum-class type to write to stream</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream for chain-use of the operator</td>
                </tr>
              </tfoot>
            </table>
<p>Delegate operator &lt;&lt; to default for writing non-enums to output streams.</p>
          </div></section>
          <section class="m-dox-details" id="aa160d13ea2e4a3498916472c3b6cdbb0"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_string&lt;Ch, Tr&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa160d13ea2e4a3498916472c3b6cdbb0" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp; lhs,
              const T&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output std::basic_string into which e is written</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of arbitrary type to write to string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated string</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for lvalues.</p>
          </div></section>
          <section class="m-dox-details" id="a7adfa2dfb8b3a38f60ac0edf5666b6c4"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_string&lt;Ch, Tr&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp;&amp; lhs,
              const T&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output std::basic_string into which e is written</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of arbitrary type to write to string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated string</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for rvalues.</p>
          </div></section>
          <section class="m-dox-details" id="a28a553d30e4fd16f06342dd643d26c25"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a28a553d30e4fd16f06342dd643d26c25" class="m-dox-self">sample</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> x,
              const <a href="namespacetk.html#a4a3683fffc858642385d1292c3817021" class="m-dox">tk::<wbr />Table</a>&amp; table)</span></span>
            </h3>
            <p>Sample a discrete y = f(x) function at x.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of abscissa at which to sample y = f(x)</td>
                </tr>
                <tr>
                  <td>table&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="namespacetk.html#a4a3683fffc858642385d1292c3817021" class="m-dox">tk::<wbr />Table</a> to sample</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Sampled value from discrete table</td>
                </tr>
              </tfoot>
            </table>
<p>If x is lower than the first x value in the function table, the first function value is returned. If x is larger than the last x value in the function table, the last function value is returned. In other words, no extrapolation is performed. If x falls between the first/lowest and the last/largest value in the table, linear interpolation is used to compute a sample between the two closest x values of the table around the abscissa given.</p><aside class="m-note m-info"><h4>Note</h4><p>The x column in the table is assumed to be in increasing order.</p></aside><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacewalker.html#ac381e784e9a620a33f67921a2068146e" class="m-dox">walker::<wbr />invhts_eq_A005H</a>, <a href="namespacewalker.html#ae994182cfb7ee4ba2c578217620016ed" class="m-dox">walker::<wbr />prod_A005H</a> for example tables</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad6260a3dcdcb9a995a4886e566b665c4"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">Timer::<wbr />Watch</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad6260a3dcdcb9a995a4886e566b665c4" class="m-dox-self">hms</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> stamp)</span></span>
            </h3>
            <p>Convert existing time stamp as a real to Watch (global scope)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">stamp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Time stamp as a real number</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Time as hours, minutes, and seconds, as a Watch struct.</td>
                </tr>
              </tfoot>
            </table>
<p>Convert existing time stamp as a real to Watch (global-scope)</p>
          </div></section>
          <section class="m-dox-details" id="a928d7dd976738fc1e3de5f4ee6147140"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class ProxyElem, class Proxy&gt;
              </div>
              <span class="m-dox-wrap-bumper">ProxyElem tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a928d7dd976738fc1e3de5f4ee6147140" class="m-dox-self">element</a>(</span><span class="m-dox-wrap">const Proxy&amp; proxy,
              const CkArrayIndex1D&amp; x)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">proxy&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Chare array proxy inside a variant to dereference</td>
                </tr>
                <tr>
                  <td>x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Chare array element index</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Chare array element proxy as a variant, defined by ProxyElem</td>
                </tr>
              </tfoot>
            </table>
<p>Function dereferencing operator[] of chare proxy inside variant 

The returning element proxy is a variant, depending on the input proxy.</p><aside class="m-note m-default"><h4>See also</h4><p><a href="classinciter_1_1_scheme.html" class="m-dox">inciter::<wbr />Scheme</a>, <a href="classinciter_1_1_scheme_base.html" class="m-dox">inciter::<wbr />SchemeBase</a>, or, e.g., DistFCT::apply() for client code.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ab602857e33f89cab4cc3788576ab1519"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;T, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab602857e33f89cab4cc3788576ab1519" class="m-dox-self">cross</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Cross-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the cross-product of two vectors</p>
          </div></section>
          <section class="m-dox-details" id="a77ef9600b5075a8bbee89b6e4991fd69"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;T, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a77ef9600b5075a8bbee89b6e4991fd69" class="m-dox-self">crossdiv</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2,
              T j)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
                <tr>
                  <td>j&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar to divide each component by</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Cross-product divided by scalar</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the cross-product of two vectors divided by a scalar</p>
          </div></section>
          <section class="m-dox-details" id="aeaca2df70ee950c576f6d74e1eb42caa"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">T tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aeaca2df70ee950c576f6d74e1eb42caa" class="m-dox-self">dot</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Dot-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the dot-product of two vectors</p>
          </div></section>
          <section class="m-dox-details" id="ae5b04b00aa51667b944b7188545ec5ae"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">T tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae5b04b00aa51667b944b7188545ec5ae" class="m-dox-self">triple</a>(</span><span class="m-dox-wrap">const std::array&lt;T, 3&gt;&amp; v1,
              const std::array&lt;T, 3&gt;&amp; v2,
              const std::array&lt;T, 3&gt;&amp; v3)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
                <tr>
                  <td>v3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3rd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Triple-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the triple-product of three vectors</p>
          </div></section>
          <section class="m-dox-details" id="ab33ea32478ab229dc49f14585c74fec2"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab33ea32478ab229dc49f14585c74fec2" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; v)</span></span>
            </h3>
            <p>Serialize std::vector to raw memory stream.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized vectors</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="adb0ded68a9723df3debe38af3634e139"><div>
            <h3>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adb0ded68a9723df3debe38af3634e139" class="m-dox-self">mergeVector</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging std::vectors during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized vectors</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated std::vectors built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a485fc849f142f0ee38055fad224206d6"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a8e37e8d13562df3379a730217f735255" class="m-dox">MeshReaderType</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a485fc849f142f0ee38055fad224206d6" class="m-dox-self">detectInput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename)</span></span>
            </h3>
            <p>Detect input mesh file type.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>File to open and detect its type</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>enum specifying the mesh reader type</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6bcaad9b4f5b0aa6e5792f9ccacf8d79"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox">MeshWriterType</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6bcaad9b4f5b0aa6e5792f9ccacf8d79" class="m-dox-self">pickOutput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename)</span></span>
            </h3>
            <p>Determine output mesh file type.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to pick its type based on extension given</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>enum specifying the mesh writer type</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="af947865970b76333655208aea71ceb71"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af947865970b76333655208aea71ceb71" class="m-dox-self">readUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; timestamp)</span></span>
            </h3>
            <p>Read unstructured mesh from file.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to read mesh from</td>
                </tr>
                <tr>
                  <td>timestamp&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>A time stamp consisting of a timer label (a string), and a time state (a <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> in seconds) measuring the mesh read time</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Unstructured mesh object</td>
                </tr>
              </tfoot>
            </table>
<p>Create unstructured mesh to store mesh</p>
          </div></section>
          <section class="m-dox-details" id="a92ff858133bdb654de9b95c279427325"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a92ff858133bdb654de9b95c279427325" class="m-dox-self">writeUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>&amp; mesh,
              bool reorder)</span></span>
            </h3>
            <p>Write unstructured mesh to file.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to write mesh to</td>
                </tr>
                <tr>
                  <td>mesh&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Unstructured mesh object to write from</td>
                </tr>
                <tr>
                  <td>reorder&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether to also reorder mesh nodes</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector of time stamps consisting of a timer label (a string), and a time state (a <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> in seconds) measuring the renumber and the mesh write time</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a20ee8c554da198c14efbb80a0b623a4a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a20ee8c554da198c14efbb80a0b623a4a" class="m-dox-self">SiloError</a>(</span><span class="m-dox-wrap">char* msg)</span></span>
            </h3>
            <p>Silo error handler.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">msg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Error message</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8e567fa9a72a1d5d02cea9eb020b192a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8e567fa9a72a1d5d02cea9eb020b192a" class="m-dox-self">workdir</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Wrapper for POSIX API&#x27;s getcwd() from unistd.h.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>A stirng containing the current working directory</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a69ebefad09fa900014b6271b30e8bd5f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a69ebefad09fa900014b6271b30e8bd5f" class="m-dox-self">curtime</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Wrapper for the standard C library&#x27;s gettimeofday() from.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>A stirng containing the current date and time</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="afbbf10b984ba3f66b55cc8363c6a2341"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#afbbf10b984ba3f66b55cc8363c6a2341" class="m-dox-self">echoHeader</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header)</span></span>
            </h3>
            <p>Echo program header.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>header&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Header type enum indicating which header to print</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab72923dba604ccbf4233af3ccafc70b3"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab72923dba604ccbf4233af3ccafc70b3" class="m-dox-self">echoBuildEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              const std::string&amp; executable)</span></span>
            </h3>
            <p>Echo build environment.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
              </tbody>
            </table>
<p>Echo information read from build_dir/Base/Config.h filled by CMake based on src/Main/Config.h.in.</p>
          </div></section>
          <section class="m-dox-details" id="a575873ee9074d8c75f3e82f2ece02c3b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a575873ee9074d8c75f3e82f2ece02c3b" class="m-dox-self">echoRunEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              int argc,
              char** argv,
              bool verbose,
              bool quiescence)</span></span>
            </h3>
            <p>Echo runtime environment.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>argc&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>argv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>C-style string array to command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>verbose&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True for verbose screen-output</td>
                </tr>
                <tr>
                  <td>quiescence&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if quiescence detection is enabled</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="af9d21933fc9e1a656db37419b2173f5f"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Driver, class Printer, class CmdLine&gt;
              </div>
              <span class="m-dox-wrap-bumper">Driver tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af9d21933fc9e1a656db37419b2173f5f" class="m-dox-self">Main</a>(</span><span class="m-dox-wrap">int argc,
              char* argv[],
              const CmdLine&amp; cmdline,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header,
              const std::string&amp; executable,
              const Printer&amp; print)</span></span>
            </h3>
            <p>Generic <a href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" class="m-dox">Main()</a> used for all executables for code-reuse and a uniform output.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">argc&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>argv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>C-style string array to command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>cmdline&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line object storing data parsed from the command line arguments</td>
                </tr>
                <tr>
                  <td>header&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Header type enum indicating which executable header to print</td>
                </tr>
                <tr>
                  <td>executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
                <tr>
                  <td>print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer to use</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Instantiated driver object which can then be used to <a href="classexecute.html" class="m-dox">execute()</a> whatever it is intended to drive</td>
                </tr>
              </tfoot>
            </table>
<p>The template arguments configure this <a href="class_main.html" class="m-dox">Main</a> class that is practically used instead of the usual <a href="_unit_test_8_c.html#a3c04138a5bfe5d72780bb7e82a18e627" class="m-dox">main()</a>. This allows code-reuse and a unfirom screen-output. The template arguments are:</p><ul><li>Driver, specializaing the driver type to be created, see tk::Driver</li><li>Printer, specializaing the pretty printer type to use, see <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a></li><li>CmdLine, specializing the command line object storing data parsed from the command line</li></ul>
          </div></section>
          <section class="m-dox-details" id="abdd71f3e10edf6e1a8d047478abd488c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#abdd71f3e10edf6e1a8d047478abd488c" class="m-dox-self">npoin</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel)</span></span>
            </h3>
            <p>Compute number of points (nodes) in mesh from connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inteconnectivity of points and elements. These are the</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of mesh points (nodes)</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a66a2889d5d8aeb4a836842c6a1010463"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox-self">genEsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esup1</em> and <em>esup2</em>, where <em>esup2</em> holds the indices at which <em>esup1</em> holds the element ids surrounding points. Looping over all elements surrounding all points can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad2a88a65102c17149b44660db15d445b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad2a88a65102c17149b44660db15d445b" class="m-dox-self">genPsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, points surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing points surrounding points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>psup1</em> and <em>psup2</em>, where <em>psup2</em> holds the indices at which <em>psup1</em> holds the point ids surrounding points. Looping over all points surrounding all points can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">psup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><p>or the length-1 of the generated index list: <code class="m-code"><span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="adb7a88611b67f7c809f2bba5c794df0b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox-self">genEdsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, edges surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing edges (point ids p &lt; q) emanating from points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>edsup1</em> and <em>edsup2</em>, where <em>edsup2</em> holds the indices at which <em>edsup1</em> holds the edge-end point ids emanating from points for all points. The generated data structure, linked lists edsup1 and edsup2, are very similar to psup1 and psup2, generated by <a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" class="m-dox">genPsup()</a>, except here only unique edges are stored, i.e., for edges with point ids p &lt; q, only ids q are stored that are still associated to point p. Looping over all unique edges can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">edsup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">edsup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">use</span> <span class="n">edge</span> <span class="n">with</span> <span class="n">point</span> <span class="n">ids</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">edsup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">tk::<wbr />genInpoed</a> for similar data that sometimes may be more advantageous</p><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a559eb56e40ec844767bd2a55da55bda0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a559eb56e40ec844767bd2a55da55bda0" class="m-dox-self">genInpoed</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, edge connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linear vector storing edge connectivity (point ids p &lt; q)</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linear vector and is very similar to the linked lists, <em>edsup1</em> and _edsup2, generated by <a href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">genEdsup()</a>. The difference is that in the linear vector, inpoed, generated here, both edge point ids are stored as a pair, p &lt; q, as opposed to the linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end point ids (still associated to edge-start point ids when used together with edsup2). The rationale is that while inpoed is larger in memory, it allows direct access to edges (pair of point ids making up an edge), edsup1 and edsup2 are smaller in memory, still allow accessing the same data (edge point id pairs) but only in a linear fashion, not by direct access to particular edges. Accessing all unique edges using the edge connectivity data structure, inpoed, generated here can be accomplished by</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">inpoed</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">p</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">q</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span></pre><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">tk::<wbr />genEdsup</a> for similar data that sometimes may be more advantageous</p><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a9d835a7a93970d17a66356b64f3291af"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9d835a7a93970d17a66356b64f3291af" class="m-dox-self">genEsupel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding points of elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding points of elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esupel1</em> and <em>esupel2</em>, where <em>esupel2</em> holds the indices at which <em>esupel1</em> holds the element ids surrounding points of elements. Looping over all elements surrounding the points of all elements can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esupel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esupel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esupel</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a7b12aff8f884c70e45c6037b4f37e662"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7b12aff8f884c70e45c6037b4f37e662" class="m-dox-self">genEsuel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esuel1</em> and <em>esuel2</em>, where <em>esuel2</em> holds the indices at which <em>esuel1</em> holds the element ids surrounding elements. Looping over elements surrounding elements can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esuel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esuel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esuel</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a7c8a720dd257388a44d5ca7af7aaec8f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7c8a720dd257388a44d5ca7af7aaec8f" class="m-dox-self">genInedel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::vector&lt;std::size_t&gt;&amp; inpoed)</span></span>
            </h3>
            <p>Generate derived data structure, edges of elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>inpoed&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Edge connectivity as linear vector, see <a href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">tk::<wbr />genInpoed</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linear vector storing all edge ids * 2 of all elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or inpoed or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linear vector with all edge ids (as defined by inpoed) of all elements. The edge ids stored in inedel can be directly used to index the vector inpoed. Because the derived data structure generated here, inedel, is intended to be used in conjunction with the linear vector inpoed and not with the linked lists edsup1 and edsup2, this function takes inpoed as an argument. Accessing the edges of element e using the edge of elements data structure, inedel, generated here can be accomplished by</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nepe</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">use</span> <span class="n">edge</span> <span class="n">id</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="n">of</span> <span class="n">element</span> <span class="n">e</span><span class="p">,</span> <span class="n">or</span>
    <span class="n">use</span> <span class="n">point</span> <span class="n">ids</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">id</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="n">of</span> <span class="n">element</span> <span class="n">e</span> <span class="n">as</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="p">]</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>where <em>nepe</em> denotes the number of edges per elements: 3 for triangles, 6 for tetrahedra. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="abff39252e99681eebb5ccf0078b7b924"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#abff39252e99681eebb5ccf0078b7b924" class="m-dox-self">genEsued</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding edges.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding edges</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esued1</em> and <em>esued2</em>, where <em>esued2</em> holds the indices at which <em>esued1</em> holds the element ids surrounding edges. Looping over all elements surrounding edges can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nedge</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esued</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esued</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esued</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of edges, <em>nedge</em>, the edge connectivity, <em>inpoed</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">esup</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsup</span><span class="p">(</span><span class="n">inpoel</span><span class="p">,</span><span class="n">nnpe</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">nedge</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genInpoed</span><span class="p">(</span><span class="n">inpoel</span><span class="p">,</span><span class="n">nnpe</span><span class="p">,</span><span class="n">esup</span><span class="p">).</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span></pre><p>where <em>nnpe</em> is the number of nodes per element (4 for tetrahedra, 3 for triangles).</p><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="ab68c15dd976b0c7420ebee8770fb1f9c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab68c15dd976b0c7420ebee8770fb1f9c" class="m-dox-self">genNbfacTet</a>(</span><span class="m-dox-wrap">std::size_t tnbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel_complete,
              const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface_complete,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; lid,
              std::vector&lt;std::size_t&gt;&amp; triinpoel,
              std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface)</span></span>
            </h3>
            <p>Generate total number of boundary faces in this chunk.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tnbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of boundary faces in the entire mesh.</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh.</td>
                </tr>
                <tr>
                  <td>triinpoel_complete&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interconnectivity of points and boundary-face in the entire mesh.</td>
                </tr>
                <tr>
                  <td>bface_complete&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map of boundary-face lists mapped to corresponding side set ids for the entire mesh.</td>
                </tr>
                <tr>
                  <td>lid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mapping between the node indices used in the smaller inpoel connectivity (a subset of the entire triinpoel_complete connectivity), e.g., after mesh partitioning.</td>
                </tr>
                <tr>
                  <td>triinpoel&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Interconnectivity of points and boundary-face in this mesh-partition.</td>
                </tr>
                <tr>
                  <td>bface&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Map of boundary-face lists mapped to corresponding side set ids for this mesh-partition</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of boundary-faces on this chare/mesh-partition.</td>
                </tr>
              </tfoot>
            </table>
<p>This function takes a mesh by its domain-element (tetrahedron-connectivity) in inpoel and a boundary-face (triangle) connectivity in triinpoel_complete. Based on these two arrays, it searches for those faces of triinpoel_complete that are also in inpoel and as a result it generates (1) the number of boundary faces shared with the mesh in inpoel and (2) the intersection of the triangle element connectivity whose faces are shared with inpoel. An example use case is where triinpoel_complete contains the connectivity for the boundary of the full problem/mesh and inpoel contains the connectivity for only a chunk of an already partitioned mesh. This function then intersects triinpoel_complete with inpoel and returns only those faces that share nodes with inpoel.</p>
          </div></section>
          <section class="m-dox-details" id="a5b61b3cb6492e71ff9853404440fddcc"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;int&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5b61b3cb6492e71ff9853404440fddcc" class="m-dox-self">genEsuelTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector storing elements surrounding elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</p></aside><p>The data generated here is stored in a single vector, with length nfpe * nelem. Note however, that nelem is not explicitly provided, but calculated from inpoel. For boundary elements, at the boundary face, this esuelTet stores value -1 indicating that this is outside the domain. The convention for numbering the local face (triangle) connectivity is very important, e.g., in generating the inpofa array later. This node ordering convention is stored in <a href="namespacetk.html#a30ac7c57927d6134e6563817f5d005a0" class="m-dox">tk::<wbr />lpofa</a>. Thus function is specific to tetrahedra, which is reflected in the fact that nnpe and nfpe are being set here in the function rather than being input arguments. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p>
          </div></section>
          <section class="m-dox-details" id="a94114220a51c1ba65f5f1e8314ffc27e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a94114220a51c1ba65f5f1e8314ffc27e" class="m-dox-self">genNtfac</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nbfac,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate derived data structure, total number of faces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nfpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of faces per element.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Total number of faces in the mesh</td>
                </tr>
              </tfoot>
            </table>
<p>The unsigned integer here gives the total number of faces in</p>
          </div></section>
          <section class="m-dox-details" id="ae2d934afca4d36661acc1b3e6f863f05"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;int&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae2d934afca4d36661acc1b3e6f863f05" class="m-dox-self">genEsuf</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t ntfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; belem,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding faces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nfpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of faces per element.</td>
                </tr>
                <tr>
                  <td>ntfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of faces.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>belem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Boundary element vector.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Elements surrounding faces.</td>
                </tr>
              </tfoot>
            </table>
<p>The unsigned integer vector gives the IDs of the elements to the</p>
          </div></section>
          <section class="m-dox-details" id="ae501950a1a32199708b69a52382f1b1e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae501950a1a32199708b69a52382f1b1e" class="m-dox-self">genInpofaTet</a>(</span><span class="m-dox-wrap">std::size_t ntfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate derived data structure, node-face connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ntfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of faces.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity.</td>
                </tr>
                <tr>
                  <td>triinpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Points surrounding faces. The unsigned integer vector gives the elements to the left and to the right of each face in the mesh.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad69e35d3f9e7f2237c0c5c3b9c5c0888"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888" class="m-dox-self">genBelemTet</a>(</span><span class="m-dox-wrap">std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, host/boundary element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>inpofa&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Host elements or boundary elements. The unsigned integer vector gives the elements to the left of each boundary face in the mesh.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a61a2eebfe3b1f67bafb3131442ffffa1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">tk::Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a61a2eebfe3b1f67bafb3131442ffffa1" class="m-dox-self">genGeoFaceTri</a>(</span><span class="m-dox-wrap">std::size_t ntfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Generate derived data structure, face geometry.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ntfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of faces in the mesh.</td>
                </tr>
                <tr>
                  <td>inpofa&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Co-ordinates of nodes in this mesh-chunk.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates. Use the following examples to access this information for face-f. face area: geoFace(f,0,0), unit-normal x-component: geoFace(f,1,0), y-component: geoFace(f,2,0), z-component: geoFace(f,3,0), centroid x-coordinate: geoFace(f,4,0), y-coordinate: geoFace(f,5,0), z-coordinate: geoFace(f,6,0).</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a33792d596875801d33c16acc28eb497f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a33792d596875801d33c16acc28eb497f" class="m-dox-self">normal</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; z)</span></span>
            </h3>
            <p>Compute the unit normal vector of a triangle.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z-coordinates of the three vertices of the triangle</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Unit normal</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the unit normal vector of a triangle</p>
          </div></section>
          <section class="m-dox-details" id="a51f7ec47d21ee4be4ef5a6e58fdd4776"><div>
            <h3>
              <span class="m-dox-wrap-bumper">tk::Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a51f7ec47d21ee4be4ef5a6e58fdd4776" class="m-dox-self">geoFaceTri</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; z)</span></span>
            </h3>
            <p>Compute geometry of the face given by three vertices.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x-coordinates of the three vertices of the triangular face.</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y-coordinates of the three vertices of the triangular face.</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z-coordinates of the three vertices of the triangular face.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates.</td>
                </tr>
              </tfoot>
            </table>
<p>Compute geometry of the face given by three vertices</p>
          </div></section>
          <section class="m-dox-details" id="af33c6a2dc1649b840ab82bfcd3d1617a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">tk::Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af33c6a2dc1649b840ab82bfcd3d1617a" class="m-dox-self">genGeoElemTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Generate derived data structure, element geometry.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity.</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Co-ordinates of nodes in this mesh-chunk.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Element geometry information. This includes element volume and element centroid coordinates. Use the following examples to access this information for element-e. volume: geoElem(e,0,0), centroid x-coordinate: geoElem(f,1,0), y-coordinate: geoElem(f,2,0), z-coordinate: geoElem(f,3,0).</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8b04469b1f0015a5322697e83617ca6d"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8b04469b1f0015a5322697e83617ca6d" class="m-dox-self">leakyPartition</a>(</span><span class="m-dox-wrap">const std::vector&lt;int&gt;&amp; esueltet,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Perform leak-test on mesh (partition)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">esueltet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements for tetrahedra, see tk::genEsueltet()</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node coordinates</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if partition leaks.</td>
                </tr>
              </tfoot>
            </table>
<p>This function computes a surface integral over the boundary of the incoming mesh (partition). A non-zero vector result indicates a leak, e.g., a hole in the mesh (partition), which indicates an error either in the</p>
          </div></section>
          <section class="m-dox-details" id="aae5766a4d0dae70d561c514f2758072e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aae5766a4d0dae70d561c514f2758072e" class="m-dox-self">nodegrad</a>(</span><span class="m-dox-wrap">std::size_t node,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4" class="m-dox">ncomp_<wbr />t</a> c)</span></span>
            </h3>
            <p>Compute gradient at a mesh node.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">node&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node id at which to compute gradient</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Linked lists storing elements surrounding points, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup()</a></td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Field vector whose component gradient to compute</td>
                </tr>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar component to compute gradient of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Gradient of U(c) at mesh node</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8deceeef86846672dd872bb7e975bb13"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8deceeef86846672dd872bb7e975bb13" class="m-dox-self">edgegrad</a>(</span><span class="m-dox-wrap">std::size_t edge,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esued,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#a9bf453dedb17140704a4e947d172bae4" class="m-dox">ncomp_<wbr />t</a> c)</span></span>
            </h3>
            <p>Compute gradient at a mesh edge.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">edge&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Edge id at which to compute gradient</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>esued&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Linked lists storing elements surrounding edges, see <a href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924" class="m-dox">tk::<wbr />genEsued()</a></td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Field vector whose component gradient to compute</td>
                </tr>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar component to compute gradient of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Gradient of U(c) at mesh edge</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a293dd6fafcc3b8f4b28bef4f3ef050e1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1" class="m-dox-self">shiftToZero</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; inpoel)</span></span>
            </h3>
            <p>Shift node IDs to start with zero in element connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Inteconnectivity of points and elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Amount shifted</td>
                </tr>
              </tfoot>
            </table>
<p>This function implements a simple reordering of the node ids of the element connectivity in inpoel by shifting the node ids so that the smallest is zero.</p><aside class="m-note m-info"><h4>Note</h4><p>It is okay to call this function with an empty container; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a261ac7b3e006f7fa6621ad910b6553cc"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a261ac7b3e006f7fa6621ad910b6553cc" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; id,
              const std::vector&lt;std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Apply new mapping to vector of indices.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">id&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of integer IDs to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of indices creating a new order</td>
                </tr>
              </tbody>
            </table>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed between the array index ands its value. The function overwrites every value, i, of vector id with map[i].</p><aside class="m-note m-info"><h4>Note</h4><p>The sizes of id and map need not equal. Only the maximum index in id must be lower than the size of map.</p><p>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="af808bcf55ee4b5e910f68ecb0fe2f8dd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; r,
              const std::vector&lt;std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Apply new mapping to vector of real numbers.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">r&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of real numbers to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of indices creating a new order</td>
                </tr>
              </tbody>
            </table>
<p>This function applies a mapping (reordering) to the real values passed in using the map passed in. The mapping is expressed between the array index ands its value. The function moves every value r[i] to r[ map[i] ].</p><aside class="m-note m-info"><h4>Note</h4><p>The sizes of r and map must be equal and the maximum index in map must be lower than the size of map.</p><p>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a22a8b455edb4f8453d5a6173319f9c80"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a22a8b455edb4f8453d5a6173319f9c80" class="m-dox-self">renumber</a>(</span><span class="m-dox-wrap">const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; psup)</span></span>
            </h3>
            <p>Reorder mesh points with the advancing front technique.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">psup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Points surrounding points</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Mapping created by renumbering (reordering)</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="acb19d7c5f6c7354614bb457d6b17afde"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::unordered_map&lt;std::size_t, std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acb19d7c5f6c7354614bb457d6b17afde" class="m-dox-self">assignLid</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; gid)</span></span>
            </h3>
            <p>Assign local ids to global ids.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">gid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Global ids</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Map associating global ids to local ids</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a0ee7abd71123782d48e2ec04906fe982"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::tuple&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;, std::unordered_map&lt;std::size_t, std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0ee7abd71123782d48e2ec04906fe982" class="m-dox-self">global2local</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ginpoel)</span></span>
            </h3>
            <p>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ginpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity with global node IDs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Tuple of (1) element connectivity with local node IDs, (2) the vector of unique global node IDs (i.e., the mapping between local to global node IDs), and (3) mapping between global to local node IDs.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6c5589db5d1caeac294a0b1569b65ebd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6c5589db5d1caeac294a0b1569b65ebd" class="m-dox-self">positiveJacobians</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord)</span></span>
            </h3>
            <p>Test positivity of the Jacobian for all cells in a mesh.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity (zero-based, i.e., local if parallel)</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node coordinates</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if Jacobians of all mesh cells are positive</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a1f585439fa7abf61b26704881e98a168"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1f585439fa7abf61b26704881e98a168" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u)</span></span>
            </h3>
            <p>Serialize univariate PDF to raw memory stream.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Univariate PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized PDFs</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a24204b4ddfb41147330f02a8e6e7b760"><div>
            <h3>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a24204b4ddfb41147330f02a8e6e7b760" class="m-dox-self">mergeUniPDFs</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging a univariate PDF during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized PDF</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated PDF built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a95434266ed0be6503251e90e0fe60823"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a95434266ed0be6503251e90e0fe60823" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u,
              const std::vector&lt;<a href="classtk_1_1_bi_p_d_f.html" class="m-dox">tk::<wbr />BiPDF</a>&gt;&amp; b,
              const std::vector&lt;<a href="classtk_1_1_tri_p_d_f.html" class="m-dox">tk::<wbr />TriPDF</a>&gt;&amp; t)</span></span>
            </h3>
            <p>Serialize vectors of PDFs to raw memory stream.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of univariate PDFs</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of bivariate PDFs</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of trivariate PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized PDFs</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab8753a2df233c9b1327d5682940ddcbf"><div>
            <h3>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab8753a2df233c9b1327d5682940ddcbf" class="m-dox-self">mergePDF</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging PDFs during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated PDFs built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ac0a63cccd84b6bd8b998cb4282adac23"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static std::ostream&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac0a63cccd84b6bd8b998cb4282adac23" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&amp; p)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Stream to output to</td>
                </tr>
                <tr>
                  <td>p&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>PDF to output</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated stream</td>
                </tr>
              </tfoot>
            </table>
<p>Output univariate PDF to output stream</p><aside class="m-note m-info"><h4>Note</h4><p>Used for debugging.</p></aside>
          </div></section>
        </section>
        <section>
          <h2>Variable documentation</h2>
          <section class="m-dox-details" id="afc6a4dbf99954fbde58f895283a8de43"><div>
            <h3>
              const std::array&lt;std::size_t, 2&gt; tk::<wbr /><a href="#afc6a4dbf99954fbde58f895283a8de43" class="m-dox-self">ExoNnpe</a>
            </h3>
<p>ExodusII mesh cell number of nodes</p><p>List of number of nodes per element for different element types supported in the order of <a href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox">tk::<wbr />ExoElemType</a></p>
          </div></section>
          <section class="m-dox-details" id="a9445a95368496196e7c7560eccadbb09"><div>
            <h3>
              const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; tk::<wbr /><a href="#a9445a95368496196e7c7560eccadbb09" class="m-dox-self">expofa</a>
            </h3>
<p>ExodusII face-node numbering for tetrahedron side sets</p><aside class="m-note m-default"><h4>See also</h4><p>ExodusII manual figure on &quot;Sideset side Numbering&quot;</p></aside>
          </div></section>
          <section class="m-dox-details" id="a30ac7c57927d6134e6563817f5d005a0"><div>
            <h3>
              const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; tk::<wbr /><a href="#a30ac7c57927d6134e6563817f5d005a0" class="m-dox-self">lpofa</a>
            </h3>
<p>Const array defining the node ordering convention for a tetrahedron cell</p><p>This two-dimensional array stores the naming/ordering convention of the node indices of a tetrahedron (tet) element. The dimensions are 4x3 as a tetrahedron has a total of 4 nodes and each (triangle) face has 3 nodes. Thus the array below associates tet node 0 with nodes {1,2,3}, tet node 1 with {2,0,3}, tet node 2 with {3,0,1}, and tet node 3 with {0,2,1}. Note that not only these mappings are important, but also the order of the nodes within the triplets as this specific order also defines the outwards normal of each face.</p>
          </div></section>
          <section class="m-dox-details" id="a07af9a3d86b90e1861bd16ded6a6ae87"><div>
            <h3>
              static highwayhash::HH_U64 tk::<wbr /><a href="#a07af9a3d86b90e1861bd16ded6a6ae87" class="m-dox-self">hh_key</a> <span class="m-label m-primary">constexpr</span>
            </h3>
<p>Highway hash &quot;secret&quot; key</p><aside class="m-note m-info"><h4>Note</h4><p>No reason for these particular numbers, taken from highwayhash tests.</p></aside>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.org+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.org+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="http://quinoacomputing.org/">Quinoa project</a>. Copyright © J. Bakosi 2012&ndash;2015, <a href="http://www.lansllc.com/">Los Alamos National Security, LLC,</a> 2016&ndash;2018.<br />Generated based on <a href="https://github.com/quinoacomputing/quinoa/commit/a0a78a6">a0a78a6</a> by <a href="http://doxygen.org/">Doxygen</a> 1.8.15 and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/">GitHub</a>, <a href="mailto:quinoa@lanl.gov">Email</a> or <a href="https://gitter.im/quinoacomputing/quinoa">Gitter</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>