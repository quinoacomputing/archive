<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: tk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Toolkit declarations and definitions for general purpose utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetk_1_1ctr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1ctr.html">ctr</a></td></tr>
<tr class="memdesc:namespacetk_1_1ctr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit control, general purpose user input to internal data transfer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1grm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html">grm</a></td></tr>
<tr class="memdesc:namespacetk_1_1grm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit general purpose grammar definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1hypre"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1hypre.html">hypre</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1mkl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1mkl.html">mkl</a></td></tr>
<tr class="memdesc:namespacetk_1_1mkl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for Intel's Math Kernel Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1random123"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1random123.html">random123</a></td></tr>
<tr class="memdesc:namespacetk_1_1random123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for the <a class="el" href="classtk_1_1_random123.html" title="Random123-based random number generator used polymorphically with tk::RNG. ">Random123</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1rngsse"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1rngsse.html">rngsse</a></td></tr>
<tr class="memdesc:namespacetk_1_1rngsse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit, grammar definition for the <a class="el" href="classtk_1_1_r_n_g_s_s_e.html" title="RNGSSE-based random number generator used polymorphically with tk::RNG. ">RNGSSE</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1tuple"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:namespacetk_1_1tuple"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged tuple allowing tag-based access to tuple members. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1zoltan"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html">zoltan</a></td></tr>
<tr class="memdesc:namespacetk_1_1zoltan"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interoperation with the Zoltan library, used for static mesh partitioning. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_bi_p_d_f.html">BiPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint bivariate PDF estimator.  <a href="classtk_1_1_bi_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html">Control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch.  <a href="classtk_1_1_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_diag_writer.html">DiagWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_diag_writer.html" title="DiagWriter : tk::Writer. ">DiagWriter</a> : <a class="el" href="classtk_1_1_writer.html">tk::Writer</a>.  <a href="classtk_1_1_diag_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_driver.html">Driver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic exception class for producing <a href="file:func:line">file:func:line</a> info + call trace.  <a href="classtk_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html">ExodusIIMeshReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_writer.html">ExodusIIMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_file_parser.html">FileParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_file_parser.html" title="FileParser. ">FileParser</a>.  <a href="classtk_1_1_file_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_reader.html">GmshMeshReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_writer.html">GmshMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_h5_part_writer.html">H5PartWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_choices.html">HasFunctionExpectChoices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::choices".  <a href="structtk_1_1_has_function_expect_choices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_description.html">HasFunctionExpectDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::description".  <a href="structtk_1_1_has_function_expect_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_alias.html">HasTypedefAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "alias".  <a href="structtk_1_1_has_typedef_alias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_code.html">HasTypedefCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "code".  <a href="structtk_1_1_has_typedef_code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_expect_type.html">HasTypedefExpectType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "expect::type".  <a href="structtk_1_1_has_typedef_expect_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_proxy.html">HasTypedefProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "Proxy".  <a href="structtk_1_1_has_typedef_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_hyper_mesh_reader.html">HyperMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_hyper_mesh_reader.html" title="HyperMeshReader : tk::Reader. ">HyperMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_hyper_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if__.html">if_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type selection: <a class="el" href="structtk_1_1if__.html#a456b6172591b18a1bd516f30b653444d">if_&lt; Condition, Then, Else &gt;::type</a>.  <a href="structtk_1_1if__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if___3_01false_00_01_then_00_01_else_01_4.html">if_&lt; false, Then, Else &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_linear_map.html">LinearMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_lin_sys_merger.html">LinSysMerger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list.html">make_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_01_4.html">make_list&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_00_01_args_8_8_8_01_4.html">make_list&lt; T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_4.html">make_list&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_m_k_l_r_n_g.html">MKLRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MKL-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_m_k_l_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_msg.html">Msg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_reader.html">NetgenMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_netgen_mesh_reader.html" title="NetgenMeshReader : tk::Reader. ">NetgenMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_netgen_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_writer.html">NetgenMeshWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_particle_writer.html">ParticleWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ group used to output particle data to file in parallel using H5Part and MPI-IO.  <a href="classtk_1_1_particle_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_p_d_f_writer.html">PDFWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_p_d_f_writer.html" title="PDFWriter : Writer. ">PDFWriter</a> : <a class="el" href="classtk_1_1_writer.html">Writer</a>.  <a href="classtk_1_1_p_d_f_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_print.html">Print</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_progress.html">Progress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_random123.html">Random123</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random123-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_random123.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_reader.html">Reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g.html">RNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator.  <a href="classtk_1_1_r_n_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_print.html">RNGPrint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_r_n_g_print.html" title="RNGPrint : Print. ">RNGPrint</a> : <a class="el" href="classtk_1_1_print.html">Print</a>.  <a href="classtk_1_1_r_n_g_print.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_s_s_e.html">RNGSSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RNGSSE-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a>.  <a href="classtk_1_1_r_n_g_s_s_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_stack.html">RNGStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator stack.  <a href="classtk_1_1_r_n_g_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_silo_writer.html">SiloWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_silo_writer.html" title="SiloWriter. ">SiloWriter</a>.  <a href="classtk_1_1_silo_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_statistics.html" title="Statistics estimator. ">Statistics</a> estimator.  <a href="classtk_1_1_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_mesh.html">STLMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_mesh.html" title="STLMesh. ">STLMesh</a>.  <a href="classtk_1_1_s_t_l_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html">STLTxtMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html" title="STLTxtMeshReader : tk::Reader. ">STLTxtMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_s_t_l_txt_mesh_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1str__const.html">str_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr string  <a href="classtk_1_1str__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_string_parser.html">StringParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_string_parser.html" title="StringParser. ">StringParser</a>.  <a href="classtk_1_1_string_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_strings_msg.html">StringsMsg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_toggle.html">Toggle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_toggle.html" title="Toggle is the base for an Option, doing generic searches. ">Toggle</a> is the base for an Option, doing generic searches.  <a href="classtk_1_1_toggle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_tracker.html">Tracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_tracker.html" title="Tracker advances Lagrangian particles in state space. ">Tracker</a> advances Lagrangian particles in state space.  <a href="classtk_1_1_tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_tri_p_d_f.html">TriPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint trivariate PDF estimator.  <a href="classtk_1_1_tri_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_txt_stat_writer.html">TxtStatWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_txt_stat_writer.html" title="TxtStatWriter : tk::Writer. ">TxtStatWriter</a> : <a class="el" href="classtk_1_1_writer.html">tk::Writer</a>.  <a href="classtk_1_1_txt_stat_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uni_p_d_f.html">UniPDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Univariate PDF estimator.  <a href="classtk_1_1_uni_p_d_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D unstructured mesh class  <a href="classtk_1_1_uns_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh_map.html">UnsMeshMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ array map for initial placement of array elements using an unstructured grid.  <a href="classtk_1_1_uns_mesh_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_vec_strs_msg.html">VecStrsMsg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_writer.html">Writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a732b6aaa7f495f4b1f06dd4d1acee269">is_enum_class</a> = typename boost::mpl::bool_&lt; std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_convertible&lt; T, uint8_t &gt;::value &gt;</td></tr>
<tr class="memdesc:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait querying whether T is a strongly typed enum.  <a href="#a732b6aaa7f495f4b1f06dd4d1acee269">More...</a><br /></td></tr>
<tr class="separator:a732b6aaa7f495f4b1f06dd4d1acee269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3683fffc858642385d1292c3817021"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">Table</a> = std::vector&lt; std::pair&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;</td></tr>
<tr class="memdesc:a4a3683fffc858642385d1292c3817021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for declaring, defining, and storing a discrete y = f(x) function.  <a href="#a4a3683fffc858642385d1292c3817021">More...</a><br /></td></tr>
<tr class="separator:a4a3683fffc858642385d1292c3817021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a96ada94b7e2911ecca0a360f305575"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">real</a> = double</td></tr>
<tr class="memdesc:a1a96ada94b7e2911ecca0a360f305575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real number type used throughout the whole code.  <a href="#a1a96ada94b7e2911ecca0a360f305575">More...</a><br /></td></tr>
<tr class="separator:a1a96ada94b7e2911ecca0a360f305575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff0a76887b93164712b9ce9192fdd2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a40ff0a76887b93164712b9ce9192fdd2">SiloErrorHandler</a>) (char *)</td></tr>
<tr class="memdesc:a40ff0a76887b93164712b9ce9192fdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler function type.  <a href="#a40ff0a76887b93164712b9ce9192fdd2">More...</a><br /></td></tr>
<tr class="separator:a40ff0a76887b93164712b9ce9192fdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74de56fa53c55c0a8f35b764729cdf20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20">RNGFactory</a> = std::map&lt; <a class="el" href="namespacetk_1_1ctr.html#aa1b0831f9e998d8133473f63480b3ecb">ctr::RNGType</a>, std::function&lt; <a class="el" href="classtk_1_1_r_n_g.html">RNG</a>() &gt; &gt;</td></tr>
<tr class="separator:a74de56fa53c55c0a8f35b764729cdf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afcc275d91d4368505f221061b9ba822a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">ErrCode</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a> = EXIT_SUCCESS, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a> = EXIT_FAILURE
<br />
 }<tr class="memdesc:afcc275d91d4368505f221061b9ba822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for the OS (or whatever calls us)  <a href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afcc275d91d4368505f221061b9ba822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d172b64b84ff0554f0e87475f4541b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">Style</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a> =1
<br />
 }<tr class="memdesc:a1d172b64b84ff0554f0e87475f4541b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output verbosity. C-style enum as this is used for template argument.  <a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1d172b64b84ff0554f0e87475f4541b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3781b50ef71ead8dd0bd286455c6030c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">ExoElemType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a> = 1
<br />
 }<tr class="memdesc:a3781b50ef71ead8dd0bd286455c6030c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported ExodusII mesh cell types.  <a href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3781b50ef71ead8dd0bd286455c6030c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">ExoWriter</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">ExoWriter::CREATE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">ExoWriter::OPEN</a>
<br />
 }<tr class="memdesc:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExodusII writer constructor modes.  <a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aea4fb4c5b5f9f99675ec2f39d25a3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85016961456a798f65e4e5a451e44242"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">GmshElemType</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> = 15
<br />
 }<tr class="memdesc:a85016961456a798f65e4e5a451e44242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers of supported Gmsh elements.  <a href="namespacetk.html#a85016961456a798f65e4e5a451e44242">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a85016961456a798f65e4e5a451e44242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af910e1a2aff3119022dea29cf3d898c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">GmshFileType</a> { <br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">GmshFileType::UNDEFINED</a> = -1, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">GmshFileType::ASCII</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">GmshFileType::BINARY</a> = 1
<br />
 }<tr class="memdesc:af910e1a2aff3119022dea29cf3d898c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported Gmsh mesh file types.  <a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af910e1a2aff3119022dea29cf3d898c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748833535365d6e320da5fcb7d213c30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">MeshReader::GMSH</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">MeshReader::NETGEN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">MeshReader::EXODUSII</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02">MeshReader::HYPERMESH</a>
<br />
 }<tr class="memdesc:a748833535365d6e320da5fcb7d213c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh readers.  <a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a748833535365d6e320da5fcb7d213c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d2f365ad601e02c8d64479adfd4a7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fad8e85cdb6ef83caac7fa35c22dda2153">MeshWriter::GMSH</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fa8d2dc7a7e41c392a0da416ec0626e676">MeshWriter::NETGEN</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7fa834c8a77b335ad1c7bb2b632b6857339">MeshWriter::EXODUSII</a>
<br />
 }<tr class="memdesc:a43d2f365ad601e02c8d64479adfd4a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh writers.  <a href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a43d2f365ad601e02c8d64479adfd4a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3032aaeb67d38d01181590cd7f0acc7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">HeaderType::INCITER</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">HeaderType::RNGTEST</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">HeaderType::UNITTEST</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">HeaderType::MESHCONV</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">HeaderType::WALKER</a>
<br />
 }<tr class="memdesc:a3032aaeb67d38d01181590cd7f0acc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>.  <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3032aaeb67d38d01181590cd7f0acc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a87af1b002bc711716bd170a714bda211"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a87af1b002bc711716bd170a714bda211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">unique</a> (Container &amp;c)</td></tr>
<tr class="separator:a87af1b002bc711716bd170a714bda211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e002561a68875b091a264eb2a1e5f6c"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2e002561a68875b091a264eb2a1e5f6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">cref_find</a> (const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</td></tr>
<tr class="separator:a2e002561a68875b091a264eb2a1e5f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab2aac5f0fd93d5119cfe50a39f3515c9">ref_find</a> (const Container &amp;map, const typename Container::key_type &amp;key) -&gt; typename Container::mapped_type &amp;</td></tr>
<tr class="separator:ab2aac5f0fd93d5119cfe50a39f3515c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0de4157a7818da7a9deb1476099bd8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0de4157a7818da7a9deb1476099bd8d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#af0de4157a7818da7a9deb1476099bd8d">extents</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:af0de4157a7818da7a9deb1476099bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return minimum and maximum values of a vector.  <a href="#af0de4157a7818da7a9deb1476099bd8d">More...</a><br /></td></tr>
<tr class="separator:af0de4157a7818da7a9deb1476099bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1930c11b6d90076b9d17c9f9c9d49efe">extents</a> (const Container &amp;map) -&gt; std::array&lt; typename Container::mapped_type, 2 &gt;</td></tr>
<tr class="separator:a1930c11b6d90076b9d17c9f9c9d49efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47c993218d9384828fcce2794850ac7"><td class="memTemplParams" colspan="2">template&lt;class T , class Allocator &gt; </td></tr>
<tr class="memitem:ad47c993218d9384828fcce2794850ac7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad47c993218d9384828fcce2794850ac7">operator+=</a> (std::vector&lt; T, Allocator &gt; &amp;dst, const std::vector&lt; T, Allocator &gt; &amp;src)</td></tr>
<tr class="memdesc:ad47c993218d9384828fcce2794850ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all elements of a vector to another one.  <a href="#ad47c993218d9384828fcce2794850ac7">More...</a><br /></td></tr>
<tr class="separator:ad47c993218d9384828fcce2794850ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b203c3a87657090a5c477896ce94bf9"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6b203c3a87657090a5c477896ce94bf9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a6b203c3a87657090a5c477896ce94bf9">keyEqual</a> (const Container &amp;a, const Container &amp;b)</td></tr>
<tr class="separator:a6b203c3a87657090a5c477896ce94bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0f319a47a6a5b983e161aa5f4d8f7b6c">sumsize</a> (const Container &amp;c)</td></tr>
<tr class="separator:a0f319a47a6a5b983e161aa5f4d8f7b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd730d099e698f124362ef8c01483e0f"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:afd730d099e698f124362ef8c01483e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">min</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;a, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;b)</td></tr>
<tr class="separator:afd730d099e698f124362ef8c01483e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a26e30d19b940a12990a866a514cb5"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ac9a26e30d19b940a12990a866a514cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">max</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;a, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;b)</td></tr>
<tr class="separator:ac9a26e30d19b940a12990a866a514cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a21669e4d06c62a58cd0f4bf63868ab7e">operator==</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:a21669e4d06c62a58cd0f4bf63868ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac38f5055c45cd35b8ce00151cea4c1d3">operator!=</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:ac38f5055c45cd35b8ce00151cea4c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memTemplParams" colspan="2">template&lt;uint8_t Layout&gt; </td></tr>
<tr class="memitem:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::size_t, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab7f02155bc2945a0a0c82c1be5cad041">maxdiff</a> (const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;lhs, const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;rhs)</td></tr>
<tr class="separator:ab7f02155bc2945a0a0c82c1be5cad041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad986ef5558d44d5e0c6650c589499980"><td class="memTemplParams" colspan="2">template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </td></tr>
<tr class="memitem:ad986ef5558d44d5e0c6650c589499980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980">record</a> (Factory &amp;f, const Key &amp;key, ConstructorArgs &amp;&amp;... args)</td></tr>
<tr class="separator:ad986ef5558d44d5e0c6650c589499980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9673379e599043b13fff369dce1402"><td class="memTemplParams" colspan="2">template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </td></tr>
<tr class="memitem:aeb9673379e599043b13fff369dce1402"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> (const Factory &amp;f, const Key &amp;key)</td></tr>
<tr class="separator:aeb9673379e599043b13fff369dce1402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr class="memitem:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a24170c3146caaa7b79d78d4aa1d98f66">recordModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a24170c3146caaa7b79d78d4aa1d98f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98b4e55f14339c707622a8da43d8ce9"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </td></tr>
<tr class="memitem:ae98b4e55f14339c707622a8da43d8ce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae98b4e55f14339c707622a8da43d8ce9">recordModelLate</a> (Factory &amp;f, const Key &amp;key, ModelConstrArg)</td></tr>
<tr class="separator:ae98b4e55f14339c707622a8da43d8ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6374b4792dbd3c626dad60bcef168"><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr class="memitem:a4bd6374b4792dbd3c626dad60bcef168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4bd6374b4792dbd3c626dad60bcef168">recordCharmModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;... args)</td></tr>
<tr class="separator:a4bd6374b4792dbd3c626dad60bcef168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac2323b3c43edbcc32d55d91100ffc3a6">flip_pair</a> (const std::pair&lt; A, B &gt; &amp;p)</td></tr>
<tr class="separator:ac2323b3c43edbcc32d55d91100ffc3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memTemplItemLeft" align="right" valign="top">std::multimap&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a42982d289f8edfffa60fa4da8b7b9fdf">flip_map</a> (const std::map&lt; A, B &gt; &amp;src)</td></tr>
<tr class="separator:a42982d289f8edfffa60fa4da8b7b9fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a928cb4648630899f34ee7ad08fd754"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </td></tr>
<tr class="memitem:a8a928cb4648630899f34ee7ad08fd754"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">serialize</a> (const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</td></tr>
<tr class="separator:a8a928cb4648630899f34ee7ad08fd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371117af5d2009dca83a8cb5539a43f"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </td></tr>
<tr class="memitem:ac371117af5d2009dca83a8cb5539a43f"><td class="memTemplItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac371117af5d2009dca83a8cb5539a43f">mergeHashMap</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:ac371117af5d2009dca83a8cb5539a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.  <a href="#ac371117af5d2009dca83a8cb5539a43f">More...</a><br /></td></tr>
<tr class="separator:ac371117af5d2009dca83a8cb5539a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484074849c5c9532282fc9fa4e19467"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae484074849c5c9532282fc9fa4e19467">linearLoadDistributor</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> virtualization, uint64_t load, int npe, uint64_t &amp;chunksize, uint64_t &amp;remainder)</td></tr>
<tr class="memdesc:ae484074849c5c9532282fc9fa4e19467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear load distribution for given total work and virtualization.  <a href="#ae484074849c5c9532282fc9fa4e19467">More...</a><br /></td></tr>
<tr class="separator:ae484074849c5c9532282fc9fa4e19467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1bbb9b08d37f6f5f3bed45effc8fc64e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const std::vector&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a1bbb9b08d37f6f5f3bed45effc8fc64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memTemplParams" colspan="2">template&lt;typename Msg &gt; </td></tr>
<tr class="memitem:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5d61711de49d010da4785f7cb6ad2d9b">waitfor</a> (const CkFuture &amp;f)</td></tr>
<tr class="separator:a5d61711de49d010da4785f7cb6ad2d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4d5bfee8e8bdea2bc60e5d725672af09">rm</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file from file system.  <a href="#a4d5bfee8e8bdea2bc60e5d725672af09">More...</a><br /></td></tr>
<tr class="separator:a4d5bfee8e8bdea2bc60e5d725672af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04df49334286e653e440035c499a8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af04df49334286e653e440035c499a8d1">processExceptionCharm</a> ()</td></tr>
<tr class="memdesc:af04df49334286e653e440035c499a8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the Charm++ runtime system.  <a href="#af04df49334286e653e440035c499a8d1">More...</a><br /></td></tr>
<tr class="separator:af04df49334286e653e440035c499a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a2a62b5b6880fbd0a011cedf8896b19dc">processExceptionMPI</a> ()</td></tr>
<tr class="memdesc:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the MPI runtime system.  <a href="#a2a62b5b6880fbd0a011cedf8896b19dc">More...</a><br /></td></tr>
<tr class="separator:a2a62b5b6880fbd0a011cedf8896b19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd06aee13370660ff0109b8f8b1958e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aabd06aee13370660ff0109b8f8b1958e"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aabd06aee13370660ff0109b8f8b1958e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const T &amp;e)</td></tr>
<tr class="separator:aabd06aee13370660ff0109b8f8b1958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aa160d13ea2e4a3498916472c3b6cdbb0">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;lhs, const T &amp;e)</td></tr>
<tr class="separator:aa160d13ea2e4a3498916472c3b6cdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr class="memitem:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7adfa2dfb8b3a38f60ac0edf5666b6c4">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;&amp;lhs, const T &amp;e)</td></tr>
<tr class="separator:a7adfa2dfb8b3a38f60ac0edf5666b6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a553d30e4fd16f06342dd643d26c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a28a553d30e4fd16f06342dd643d26c25">sample</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> x, const <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> &amp;table)</td></tr>
<tr class="memdesc:a28a553d30e4fd16f06342dd643d26c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a discrete y = f(x) function at x.  <a href="#a28a553d30e4fd16f06342dd643d26c25">More...</a><br /></td></tr>
<tr class="separator:a28a553d30e4fd16f06342dd643d26c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6260a3dcdcb9a995a4886e566b665c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad6260a3dcdcb9a995a4886e566b665c4">hms</a> (<a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> stamp)</td></tr>
<tr class="memdesc:ad6260a3dcdcb9a995a4886e566b665c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert existing time stamp as a real to Watch (global scope)  <a href="#ad6260a3dcdcb9a995a4886e566b665c4">More...</a><br /></td></tr>
<tr class="separator:ad6260a3dcdcb9a995a4886e566b665c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab602857e33f89cab4cc3788576ab1519"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab602857e33f89cab4cc3788576ab1519"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr class="separator:ab602857e33f89cab4cc3788576ab1519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">crossdiv</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)</td></tr>
<tr class="separator:a77ef9600b5075a8bbee89b6e4991fd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr class="separator:aeaca2df70ee950c576f6d74e1eb42caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b04b00aa51667b944b7188545ec5ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5b04b00aa51667b944b7188545ec5ae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">triple</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</td></tr>
<tr class="separator:ae5b04b00aa51667b944b7188545ec5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ea32478ab229dc49f14585c74fec2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab33ea32478ab229dc49f14585c74fec2">serialize</a> (const std::vector&lt; std::size_t &gt; &amp;v)</td></tr>
<tr class="memdesc:ab33ea32478ab229dc49f14585c74fec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize std::vector to raw memory stream.  <a href="#ab33ea32478ab229dc49f14585c74fec2">More...</a><br /></td></tr>
<tr class="separator:ab33ea32478ab229dc49f14585c74fec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ded68a9723df3debe38af3634e139"><td class="memItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#adb0ded68a9723df3debe38af3634e139">mergeVector</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:adb0ded68a9723df3debe38af3634e139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging std::vectors during reduction across PEs.  <a href="#adb0ded68a9723df3debe38af3634e139">More...</a><br /></td></tr>
<tr class="separator:adb0ded68a9723df3debe38af3634e139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e7ddf794b944c7d2095c1222f4244a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">detectInput</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a08e7ddf794b944c7d2095c1222f4244a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect input mesh file type.  <a href="#a08e7ddf794b944c7d2095c1222f4244a">More...</a><br /></td></tr>
<tr class="separator:a08e7ddf794b944c7d2095c1222f4244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b09f52ea3b4314e449e70255837836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">pickOutput</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a64b09f52ea3b4314e449e70255837836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine output mesh file type.  <a href="#a64b09f52ea3b4314e449e70255837836">More...</a><br /></td></tr>
<tr class="separator:a64b09f52ea3b4314e449e70255837836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947865970b76333655208aea71ceb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af947865970b76333655208aea71ceb71">readUnsMesh</a> (const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;print, const std::string &amp;filename, std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;timestamp)</td></tr>
<tr class="memdesc:af947865970b76333655208aea71ceb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unstructured mesh from file.  <a href="#af947865970b76333655208aea71ceb71">More...</a><br /></td></tr>
<tr class="separator:af947865970b76333655208aea71ceb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ff858133bdb654de9b95c279427325"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a92ff858133bdb654de9b95c279427325">writeUnsMesh</a> (const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;print, const std::string &amp;filename, <a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> &amp;mesh, bool reorder)</td></tr>
<tr class="memdesc:a92ff858133bdb654de9b95c279427325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unstructured mesh to file.  <a href="#a92ff858133bdb654de9b95c279427325">More...</a><br /></td></tr>
<tr class="separator:a92ff858133bdb654de9b95c279427325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ee8c554da198c14efbb80a0b623a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a20ee8c554da198c14efbb80a0b623a4a">SiloError</a> (char *msg)</td></tr>
<tr class="memdesc:a20ee8c554da198c14efbb80a0b623a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler.  <a href="#a20ee8c554da198c14efbb80a0b623a4a">More...</a><br /></td></tr>
<tr class="separator:a20ee8c554da198c14efbb80a0b623a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbeb1245c469101fb0f280aa51fe0c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abcbeb1245c469101fb0f280aa51fe0c9">poinCommMaps</a> (std::size_t graphsize, const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, std::size_t nchare, std::string &amp;&amp;toofine)</td></tr>
<tr class="memdesc:abcbeb1245c469101fb0f280aa51fe0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-based communication maps.  <a href="#abcbeb1245c469101fb0f280aa51fe0c9">More...</a><br /></td></tr>
<tr class="separator:abcbeb1245c469101fb0f280aa51fe0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983201a427244339722ca9a4e809f48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5983201a427244339722ca9a4e809f48">elemCommMaps</a> (const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, const std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt; &amp;element, std::size_t nchare)</td></tr>
<tr class="memdesc:a5983201a427244339722ca9a4e809f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute element-based communication maps.  <a href="#a5983201a427244339722ca9a4e809f48">More...</a><br /></td></tr>
<tr class="separator:a5983201a427244339722ca9a4e809f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">workdir</a> ()</td></tr>
<tr class="memdesc:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for POSIX API's getcwd() from unistd.h.  <a href="#a8e567fa9a72a1d5d02cea9eb020b192a">More...</a><br /></td></tr>
<tr class="separator:a8e567fa9a72a1d5d02cea9eb020b192a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ebefad09fa900014b6271b30e8bd5f"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">curtime</a> ()</td></tr>
<tr class="memdesc:a69ebefad09fa900014b6271b30e8bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the standard C library's gettimeofday() from.  <a href="#a69ebefad09fa900014b6271b30e8bd5f">More...</a><br /></td></tr>
<tr class="separator:a69ebefad09fa900014b6271b30e8bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf10b984ba3f66b55cc8363c6a2341"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">echoHeader</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> header)</td></tr>
<tr class="memdesc:afbbf10b984ba3f66b55cc8363c6a2341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo program header.  <a href="#afbbf10b984ba3f66b55cc8363c6a2341">More...</a><br /></td></tr>
<tr class="separator:afbbf10b984ba3f66b55cc8363c6a2341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72923dba604ccbf4233af3ccafc70b3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">echoBuildEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, const std::string &amp;executable)</td></tr>
<tr class="memdesc:ab72923dba604ccbf4233af3ccafc70b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo build environment.  <a href="#ab72923dba604ccbf4233af3ccafc70b3">More...</a><br /></td></tr>
<tr class="separator:ab72923dba604ccbf4233af3ccafc70b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ea7a4015fef3262bdb056f840bf82"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">echoRunEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, int argc, char **argv, bool verbose)</td></tr>
<tr class="memdesc:a991ea7a4015fef3262bdb056f840bf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo runtime environment.  <a href="#a991ea7a4015fef3262bdb056f840bf82">More...</a><br /></td></tr>
<tr class="separator:a991ea7a4015fef3262bdb056f840bf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d21933fc9e1a656db37419b2173f5f"><td class="memTemplParams" colspan="2">template&lt;class Driver , class Printer , class CmdLine &gt; </td></tr>
<tr class="memitem:af9d21933fc9e1a656db37419b2173f5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_driver.html">Driver</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f">Main</a> (int argc, char *argv[], const CmdLine &amp;cmdline, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a> header, const std::string &amp;executable, const Printer &amp;print)</td></tr>
<tr class="memdesc:af9d21933fc9e1a656db37419b2173f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output. ">Main()</a> used for all executables for code-reuse and a uniform output.  <a href="#af9d21933fc9e1a656db37419b2173f5f">More...</a><br /></td></tr>
<tr class="separator:af9d21933fc9e1a656db37419b2173f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a2889d5d8aeb4a836842c6a1010463"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">genEsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</td></tr>
<tr class="memdesc:a66a2889d5d8aeb4a836842c6a1010463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points.  <a href="#a66a2889d5d8aeb4a836842c6a1010463">More...</a><br /></td></tr>
<tr class="separator:a66a2889d5d8aeb4a836842c6a1010463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a88a65102c17149b44660db15d445b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">genPsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:ad2a88a65102c17149b44660db15d445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, points surrounding points.  <a href="#ad2a88a65102c17149b44660db15d445b">More...</a><br /></td></tr>
<tr class="separator:ad2a88a65102c17149b44660db15d445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a88611b67f7c809f2bba5c794df0b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b">genEdsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:adb7a88611b67f7c809f2bba5c794df0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges surrounding points.  <a href="#adb7a88611b67f7c809f2bba5c794df0b">More...</a><br /></td></tr>
<tr class="separator:adb7a88611b67f7c809f2bba5c794df0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559eb56e40ec844767bd2a55da55bda0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">genInpoed</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a559eb56e40ec844767bd2a55da55bda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edge connectivity.  <a href="#a559eb56e40ec844767bd2a55da55bda0">More...</a><br /></td></tr>
<tr class="separator:a559eb56e40ec844767bd2a55da55bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d835a7a93970d17a66356b64f3291af"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9d835a7a93970d17a66356b64f3291af">genEsupel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a9d835a7a93970d17a66356b64f3291af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points of elements.  <a href="#a9d835a7a93970d17a66356b64f3291af">More...</a><br /></td></tr>
<tr class="separator:a9d835a7a93970d17a66356b64f3291af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b12aff8f884c70e45c6037b4f37e662"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7b12aff8f884c70e45c6037b4f37e662">genEsuel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:a7b12aff8f884c70e45c6037b4f37e662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding elements.  <a href="#a7b12aff8f884c70e45c6037b4f37e662">More...</a><br /></td></tr>
<tr class="separator:a7b12aff8f884c70e45c6037b4f37e662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7c8a720dd257388a44d5ca7af7aaec8f">genInedel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::vector&lt; std::size_t &gt; &amp;inpoed)</td></tr>
<tr class="memdesc:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges of elements.  <a href="#a7c8a720dd257388a44d5ca7af7aaec8f">More...</a><br /></td></tr>
<tr class="separator:a7c8a720dd257388a44d5ca7af7aaec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff39252e99681eebb5ccf0078b7b924"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924">genEsued</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr class="memdesc:abff39252e99681eebb5ccf0078b7b924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding edges.  <a href="#abff39252e99681eebb5ccf0078b7b924">More...</a><br /></td></tr>
<tr class="separator:abff39252e99681eebb5ccf0078b7b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a293dd6fafcc3b8f4b28bef4f3ef050e1">shiftToZero</a> (std::vector&lt; std::size_t &gt; &amp;inpoel)</td></tr>
<tr class="memdesc:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift node IDs to start with zero in element connectivity.  <a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1">More...</a><br /></td></tr>
<tr class="separator:a293dd6fafcc3b8f4b28bef4f3ef050e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac2475f6c08b5fcb81392b14aad73a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4">remap</a> (std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;newid)</td></tr>
<tr class="memdesc:a5ac2475f6c08b5fcb81392b14aad73a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder mesh point ids in a vector given a new order, i.e., index map.  <a href="#a5ac2475f6c08b5fcb81392b14aad73a4">More...</a><br /></td></tr>
<tr class="separator:a5ac2475f6c08b5fcb81392b14aad73a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0312d71017d8ffd9f11811a46e5a16"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16">renumber</a> (const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)</td></tr>
<tr class="memdesc:a1d0312d71017d8ffd9f11811a46e5a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder mesh points with the advancing front technique.  <a href="#a1d0312d71017d8ffd9f11811a46e5a16">More...</a><br /></td></tr>
<tr class="separator:a1d0312d71017d8ffd9f11811a46e5a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb19d7c5f6c7354614bb457d6b17afde"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">assignLid</a> (const std::vector&lt; std::size_t &gt; &amp;gid)</td></tr>
<tr class="memdesc:acb19d7c5f6c7354614bb457d6b17afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign local ids to global ids.  <a href="#acb19d7c5f6c7354614bb457d6b17afde">More...</a><br /></td></tr>
<tr class="separator:acb19d7c5f6c7354614bb457d6b17afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7abd71123782d48e2ec04906fe982"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt;, std::unordered_map&lt; std::size_t, std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0ee7abd71123782d48e2ec04906fe982">global2local</a> (const std::vector&lt; std::size_t &gt; &amp;ginpoel)</td></tr>
<tr class="memdesc:a0ee7abd71123782d48e2ec04906fe982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.  <a href="#a0ee7abd71123782d48e2ec04906fe982">More...</a><br /></td></tr>
<tr class="separator:a0ee7abd71123782d48e2ec04906fe982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95434266ed0be6503251e90e0fe60823"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a95434266ed0be6503251e90e0fe60823">serialize</a> (const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;u, const std::vector&lt; <a class="el" href="classtk_1_1_bi_p_d_f.html">tk::BiPDF</a> &gt; &amp;b, const std::vector&lt; <a class="el" href="classtk_1_1_tri_p_d_f.html">tk::TriPDF</a> &gt; &amp;t)</td></tr>
<tr class="memdesc:a95434266ed0be6503251e90e0fe60823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize vectors of PDFs to raw memory stream.  <a href="#a95434266ed0be6503251e90e0fe60823">More...</a><br /></td></tr>
<tr class="separator:a95434266ed0be6503251e90e0fe60823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8753a2df233c9b1327d5682940ddcbf"><td class="memItemLeft" align="right" valign="top">CkReductionMsg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab8753a2df233c9b1327d5682940ddcbf">mergePDF</a> (int nmsg, CkReductionMsg **msgs)</td></tr>
<tr class="memdesc:ab8753a2df233c9b1327d5682940ddcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ custom reducer for merging PDFs during reduction across PEs.  <a href="#ab8753a2df233c9b1327d5682940ddcbf">More...</a><br /></td></tr>
<tr class="separator:ab8753a2df233c9b1327d5682940ddcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a63cccd84b6bd8b998cb4282adac23"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac0a63cccd84b6bd8b998cb4282adac23">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &amp;p)</td></tr>
<tr class="separator:ac0a63cccd84b6bd8b998cb4282adac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a78da814ef7132a0958c47f987e3e711c"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a78da814ef7132a0958c47f987e3e711c">UnkEqComp</a> = 0</td></tr>
<tr class="memdesc:a78da814ef7132a0958c47f987e3e711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for selecting data layout policies.  <a href="#a78da814ef7132a0958c47f987e3e711c">More...</a><br /></td></tr>
<tr class="separator:a78da814ef7132a0958c47f987e3e711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaf71501378c00aad4f847942cdef6d"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9aaf71501378c00aad4f847942cdef6d">EqCompUnk</a> = 1</td></tr>
<tr class="separator:a9aaf71501378c00aad4f847942cdef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca17aedbef10f63fdfdee06f57e29c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9ca17aedbef10f63fdfdee06f57e29c">CSTYLE_STRLEN</a> = 1024</td></tr>
<tr class="separator:af9ca17aedbef10f63fdfdee06f57e29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de4d2862d3290bd756689ad204c028"><td class="memItemLeft" align="right" valign="top">CkReduction::reducerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a84de4d2862d3290bd756689ad204c028">BCVectorMerger</a></td></tr>
<tr class="memdesc:a84de4d2862d3290bd756689ad204c028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ reducers used by <a class="el" href="classtk_1_1_lin_sys_merger.html">LinSysMerger</a>.  <a href="#a84de4d2862d3290bd756689ad204c028">More...</a><br /></td></tr>
<tr class="separator:a84de4d2862d3290bd756689ad204c028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320fa5c795146f9a4ac4fc2eb4e2606"><td class="memItemLeft" align="right" valign="top">CkReduction::reducerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1320fa5c795146f9a4ac4fc2eb4e2606">BCMapMerger</a></td></tr>
<tr class="separator:a1320fa5c795146f9a4ac4fc2eb4e2606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0428a4f13b9aa50299fbb1e07a1c4889"><td class="memItemLeft" align="right" valign="top">CkReduction::reducerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0428a4f13b9aa50299fbb1e07a1c4889">BCValMerger</a></td></tr>
<tr class="separator:a0428a4f13b9aa50299fbb1e07a1c4889"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Toolkit declarations and definitions for general purpose utilities. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a732b6aaa7f495f4b1f06dd4d1acee269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732b6aaa7f495f4b1f06dd4d1acee269">&#9670;&nbsp;</a></span>is_enum_class</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a732b6aaa7f495f4b1f06dd4d1acee269">tk::is_enum_class</a> = typedef typename boost::mpl::bool_&lt; std::is_enum&lt; T &gt;::value &amp;&amp; !std::is_convertible&lt; T, uint8_t &gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait querying whether T is a strongly typed enum. </p>

<p class="definition">Definition at line <a class="el" href="_charm_util_8h_source.html#l00022">22</a> of file <a class="el" href="_charm_util_8h_source.html">CharmUtil.h</a>.</p>

</div>
</div>
<a id="a1a96ada94b7e2911ecca0a360f305575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a96ada94b7e2911ecca0a360f305575">&#9670;&nbsp;</a></span>real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real number type used throughout the whole code. </p>

<p class="definition">Definition at line <a class="el" href="_base_2_types_8h_source.html#l00018">18</a> of file <a class="el" href="_base_2_types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a74de56fa53c55c0a8f35b764729cdf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74de56fa53c55c0a8f35b764729cdf20">&#9670;&nbsp;</a></span>RNGFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20">tk::RNGFactory</a> = typedef std::map&lt; <a class="el" href="namespacetk_1_1ctr.html#aa1b0831f9e998d8133473f63480b3ecb">ctr::RNGType</a>, std::function&lt; <a class="el" href="classtk_1_1_r_n_g.html">RNG</a>() &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Random number generator factory: keys associated to their constructors </p><dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_r_n_g_stack_8h_source.html#l00033">33</a> of file <a class="el" href="_r_n_g_stack_8h_source.html">RNGStack.h</a>.</p>

</div>
</div>
<a id="a40ff0a76887b93164712b9ce9192fdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff0a76887b93164712b9ce9192fdd2">&#9670;&nbsp;</a></span>SiloErrorHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tk::SiloErrorHandler) (char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Silo error handler function type. </p>

<p class="definition">Definition at line <a class="el" href="_silo_writer_8h_source.html#l00023">23</a> of file <a class="el" href="_silo_writer_8h_source.html">SiloWriter.h</a>.</p>

</div>
</div>
<a id="a4a3683fffc858642385d1292c3817021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3683fffc858642385d1292c3817021">&#9670;&nbsp;</a></span>Table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> = typedef std::vector&lt; std::pair&lt; <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for declaring, defining, and storing a discrete y = f(x) function. </p>

<p class="definition">Definition at line <a class="el" href="_table_8h_source.html#l00024">24</a> of file <a class="el" href="_table_8h_source.html">Table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afcc275d91d4368505f221061b9ba822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc275d91d4368505f221061b9ba822a">&#9670;&nbsp;</a></span>ErrCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">tk::ErrCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes for the OS (or whatever calls us) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3"></a>SUCCESS&#160;</td><td class="fielddoc"><p>Everything went fine. </p>
</td></tr>
<tr><td class="fieldname"><a id="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"></a>FAILURE&#160;</td><td class="fielddoc"><p>Exceptions occurred. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exception_8h_source.html#l00063">63</a> of file <a class="el" href="_exception_8h_source.html">Exception.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;             { <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a> = EXIT_SUCCESS, <span class="comment">//!&lt; Everything went fine</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"></span>               <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a> = EXIT_FAILURE  <span class="comment">//!&lt; Exceptions occurred</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"></span>};</div><div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::FAILURE</a></div><div class="ttdoc">Exceptions occurred. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00064">Exception.h:64</a></div></div>
<div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">tk::SUCCESS</a></div><div class="ttdoc">Everything went fine. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00063">Exception.h:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3781b50ef71ead8dd0bd286455c6030c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3781b50ef71ead8dd0bd286455c6030c">&#9670;&nbsp;</a></span>ExoElemType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c">tk::ExoElemType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported ExodusII mesh cell types. </p>
<p>This the order in which <a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html#afa985f1ff7efafc404505766657d3854">ExodusIIMeshReader::m_eid</a> stores the element block IDs. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html#afe8144814a95bbb94d87e04091042918" title="Read element block IDs from file. ">ExodusIIMeshReader::readElemBlockIDs()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exodus_i_i_mesh_reader_8h_source.html#l00034">34</a> of file <a class="el" href="_exodus_i_i_mesh_reader_8h_source.html">ExodusIIMeshReader.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;: <span class="keywordtype">int</span> { <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 0, <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 1 };</div><div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">tk::TET</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00019">GmshMeshIO.h:19</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">tk::TRI</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00018">GmshMeshIO.h:18</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea4fb4c5b5f9f99675ec2f39d25a3482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4fb4c5b5f9f99675ec2f39d25a3482">&#9670;&nbsp;</a></span>ExoWriter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">tk::ExoWriter</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ExodusII writer constructor modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d"></a>CREATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3"></a>OPEN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html#l00025">25</a> of file <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html">ExodusIIMeshWriter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{ <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">CREATE</a>, <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">OPEN</a> };</div><div class="ttc" id="namespacetk_html_aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3"><div class="ttname"><a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3">tk::ExoWriter::OPEN</a></div></div>
<div class="ttc" id="namespacetk_html_aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d"><div class="ttname"><a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">tk::ExoWriter::CREATE</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a85016961456a798f65e4e5a451e44242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85016961456a798f65e4e5a451e44242">&#9670;&nbsp;</a></span>GmshElemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">tk::GmshElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifiers of supported Gmsh elements. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d"></a>LIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433"></a>TRI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170"></a>TET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125"></a>PNT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00017">17</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                  { <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> = 1,</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 2,</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 4,</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> = 15 };</div><div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">tk::TET</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00019">GmshMeshIO.h:19</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">tk::PNT</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00020">GmshMeshIO.h:20</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">tk::LIN</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00017">GmshMeshIO.h:17</a></div></div>
<div class="ttc" id="namespacetk_html_a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"><div class="ttname"><a href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">tk::TRI</a></div><div class="ttdef"><b>Definition:</b> <a href="_gmsh_mesh_i_o_8h_source.html#l00018">GmshMeshIO.h:18</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af910e1a2aff3119022dea29cf3d898c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af910e1a2aff3119022dea29cf3d898c1">&#9670;&nbsp;</a></span>GmshFileType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">tk::GmshFileType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported Gmsh mesh file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3"></a>UNDEFINED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc"></a>ASCII&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452"></a>BINARY&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00023">23</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                        { <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a> = -1,</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">ASCII</a> = 0,</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">BINARY</a> = 1 };</div><div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc">tk::GmshFileType::ASCII</a></div></div>
<div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452">tk::GmshFileType::BINARY</a></div></div>
<div class="ttc" id="namespacetk_html_af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3"><div class="ttname"><a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3">tk::GmshFileType::UNDEFINED</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3032aaeb67d38d01181590cd7f0acc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3032aaeb67d38d01181590cd7f0acc7d">&#9670;&nbsp;</a></span>HeaderType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">tk::HeaderType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd"></a>INCITER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928"></a>RNGTEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247"></a>UNITTEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35"></a>MESHCONV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa"></a>WALKER&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00030">30</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">INCITER</a>=0,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">RNGTEST</a>,</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">UNITTEST</a>,</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">MESHCONV</a>,</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                  <a class="code" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">WALKER</a> };</div><div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">tk::HeaderType::RNGTEST</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">tk::HeaderType::MESHCONV</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">tk::HeaderType::INCITER</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">tk::HeaderType::WALKER</a></div></div>
<div class="ttc" id="namespacetk_html_a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247"><div class="ttname"><a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">tk::HeaderType::UNITTEST</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a748833535365d6e320da5fcb7d213c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748833535365d6e320da5fcb7d213c30">&#9670;&nbsp;</a></span>MeshReader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">tk::MeshReader</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported mesh readers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"></a>GMSH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"></a>NETGEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339"></a>EXODUSII&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02"></a>HYPERMESH&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00024">24</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>=0,</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>,</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                  <a class="code" href="namespacetk_1_1ctr.html#a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>,</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02">HYPERMESH</a> };</div><div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">tk::MeshReader::GMSH</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02">tk::MeshReader::HYPERMESH</a></div></div>
<div class="ttc" id="namespacetk_1_1ctr_html_a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339"><div class="ttname"><a href="namespacetk_1_1ctr.html#a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339">tk::ctr::PDFFileType::EXODUSII</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">tk::MeshReader::NETGEN</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a43d2f365ad601e02c8d64479adfd4a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d2f365ad601e02c8d64479adfd4a7f">&#9670;&nbsp;</a></span>MeshWriter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">tk::MeshWriter</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supported mesh writers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fad8e85cdb6ef83caac7fa35c22dda2153"></a>GMSH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fa8d2dc7a7e41c392a0da416ec0626e676"></a>NETGEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a43d2f365ad601e02c8d64479adfd4a7fa834c8a77b335ad1c7bb2b632b6857339"></a>EXODUSII&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00030">30</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                      : uint8_t { <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>=0,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                  <a class="code" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>,</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                  <a class="code" href="namespacetk_1_1ctr.html#a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a> };</div><div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">tk::MeshReader::GMSH</a></div></div>
<div class="ttc" id="namespacetk_1_1ctr_html_a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339"><div class="ttname"><a href="namespacetk_1_1ctr.html#a39b4992a011792b2f9621efd03c5df7ba834c8a77b335ad1c7bb2b632b6857339">tk::ctr::PDFFileType::EXODUSII</a></div></div>
<div class="ttc" id="namespacetk_html_a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676"><div class="ttname"><a href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">tk::MeshReader::NETGEN</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d172b64b84ff0554f0e87475f4541b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d172b64b84ff0554f0e87475f4541b4">&#9670;&nbsp;</a></span>Style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">tk::Style</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output verbosity. C-style enum as this is used for template argument. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e"></a>QUIET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2"></a>VERBOSE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_print_8h_source.html#l00033">33</a> of file <a class="el" href="_print_8h_source.html">Print.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{ <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a>=0, <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a>=1 };</div><div class="ttc" id="namespacetk_html_a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2"><div class="ttname"><a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">tk::VERBOSE</a></div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00033">Print.h:33</a></div></div>
<div class="ttc" id="namespacetk_html_a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e"><div class="ttname"><a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">tk::QUIET</a></div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00033">Print.h:33</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb19d7c5f6c7354614bb457d6b17afde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb19d7c5f6c7354614bb457d6b17afde">&#9670;&nbsp;</a></span>assignLid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::size_t, std::size_t &gt; tk::assignLid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>gid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign local ids to global ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gid</td><td>Global ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map associating global ids to local ids </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00123">123</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_carrier_8_c_source.html#l00062">inciter::Carrier::Carrier()</a>, and <a class="el" href="_reorder_8_c_source.html#l00140">global2local()</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;{</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  std::unordered_map&lt; std::size_t, std::size_t &gt; lid;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  std::size_t l = 0;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : gid) lid[p] = l++;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  <span class="keywordflow">return</span> lid;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2e002561a68875b091a264eb2a1e5f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e002561a68875b091a264eb2a1e5f6c">&#9670;&nbsp;</a></span>cref_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::cref_find </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Container::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; const typename Container::mapped_type&amp;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00040">40</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_carrier_8_c_source.html#l00600">inciter::Carrier::aec()</a>, <a class="el" href="_carrier_8_c_source.html#l00663">inciter::Carrier::alw()</a>, <a class="el" href="_carrier_8_c_source.html#l01006">inciter::Carrier::apply()</a>, <a class="el" href="_carrier_8_c_source.html#l00235">inciter::Carrier::bc()</a>, <a class="el" href="_test_timer_8h_source.html#l00162">tut::CharmTimer::CharmTimer()</a>, <a class="el" href="_carrier_8_c_source.html#l00630">inciter::Carrier::comaec()</a>, <a class="el" href="_carrier_8_c_source.html#l00695">inciter::Carrier::comalw()</a>, <a class="el" href="_carrier_8_c_source.html#l00768">inciter::Carrier::comlim()</a>, <a class="el" href="_carrier_8_c_source.html#l00190">inciter::Carrier::comvol()</a>, <a class="el" href="_partitioner_8h_source.html#l00806">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::createWorkers()</a>, <a class="el" href="_transporter_8_c_source.html#l00500">inciter::Transporter::evaluateTime()</a>, <a class="el" href="_reorder_8_c_source.html#l00140">global2local()</a>, <a class="el" href="_carrier_8_c_source.html#l00732">inciter::Carrier::lim()</a>, <a class="el" href="_partitioner_8h_source.html#l00690">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::prepare()</a>, <a class="el" href="_partitioner_8h_source.html#l00314">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::query()</a>, <a class="el" href="_carrier_8_c_source.html#l00488">inciter::Carrier::readCoords()</a>, <a class="el" href="_container_util_8h_source.html#l00056">ref_find()</a>, <a class="el" href="_partitioner_8h_source.html#l00711">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::reordered()</a>, <a class="el" href="_carrier_8_c_source.html#l00853">inciter::Carrier::updateLowSol()</a>, <a class="el" href="_carrier_8_c_source.html#l00891">inciter::Carrier::updateSol()</a>, <a class="el" href="_lin_sys_merger_8h_source.html#l01082">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::updateSol()</a>, and <a class="el" href="_carrier_8_c_source.html#l00149">inciter::Carrier::vol()</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;{</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> it = map.find( key );</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="keywordflow">if</span> (it != end(map)) <span class="keywordflow">return</span> it-&gt;second; <span class="keywordflow">else</span> <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Can&#39;t find key&quot;</span> );</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab602857e33f89cab4cc3788576ab1519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab602857e33f89cab4cc3788576ab1519">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; tk::cross </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cross-product of two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross-product </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00020">20</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_base_2_vector_8h_source.html#l00067">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;{</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keywordflow">return</span> {{ v1[1]*v2[2] - v2[1]*v1[2],</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            v1[2]*v2[0] - v2[2]*v1[0],</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            v1[0]*v2[1] - v2[0]*v1[1] }};</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a77ef9600b5075a8bbee89b6e4991fd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef9600b5075a8bbee89b6e4991fd69">&#9670;&nbsp;</a></span>crossdiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; tk::crossdiv </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cross-product of two vectors divided by a scalar </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Scalar to divide each component by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross-product divided by scalar </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00036">36</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_comp_flow_8h_source.html#l00160">inciter::CompFlow&lt; Physics, Problem &gt;::rhs()</a>, and <a class="el" href="_transport_8h_source.html#l00171">inciter::Transport&lt; Physics, Problem &gt;::rhs()</a>.</p>
<div class="fragment"><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;{</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">return</span> {{ (v1[1]*v2[2] - v2[1]*v1[2]) / j,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            (v1[2]*v2[0] - v2[2]*v1[0]) / j,</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            (v1[0]*v2[1] - v2[0]*v1[1]) / j }};</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a69ebefad09fa900014b6271b30e8bd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ebefad09fa900014b6271b30e8bd5f">&#9670;&nbsp;</a></span>curtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tk::curtime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for the standard C library's gettimeofday() from. </p>
<dl class="section return"><dt>Returns</dt><dd>A stirng containing the current date and time </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00052">52</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00134">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;{</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  time_t current_time;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordtype">char</span>* c_time_string;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// Obtain current time as seconds elapsed since the Epoch</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  current_time = time( NULL );</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="keywordflow">if</span> (current_time == static_cast&lt;time_t&gt;(-1))</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Failure to compute the current time&quot;</span> );</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// Convert to local time format</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  c_time_string = ctime(&amp;current_time);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">if</span> (c_time_string == NULL)</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Failure to convert the current time&quot;</span> );</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// Convert to std::string and remove trailing newline</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  std::string str( c_time_string );</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  str.erase( std::remove(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>), str.end() );</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keywordflow">return</span> str;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a08e7ddf794b944c7d2095c1222f4244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e7ddf794b944c7d2095c1222f4244a">&#9670;&nbsp;</a></span>detectInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30">MeshReader</a> tk::detectInput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect input mesh file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File to open and detect its type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum specifying the mesh reader type </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00032">32</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02">HYPERMESH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="namespacetut.html#aa3d137634e947af278a47517d75b6167">tut::Reader()</a>, and <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00093">readUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// Get first three letters from input file</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  std::string s( <a class="code" href="namespacetut.html#aa3d137634e947af278a47517d75b6167">Reader</a>( filename ).firstline().substr(0,4) );</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;$Me&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">return</span> MeshReader::GMSH;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;CDF&quot;</span>) != std::string::npos ||</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;              s.find(<span class="stringliteral">&quot;HDF&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> MeshReader::EXODUSII;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s.find(<span class="stringliteral">&quot;&lt;?x&quot;</span>) != std::string::npos ) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">return</span> MeshReader::HYPERMESH;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">try</span> {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      std::stoi(s);    <span class="comment">// try to convert to an integer</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    } <span class="keywordflow">catch</span> ( std::invalid_argument ) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Input mesh file type could not be determined from header: &quot;</span> +</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;             filename );</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="comment">// could also catch std::out_of_range, the other exception potentially</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// thrown by std::stoi(), but a three-digit integer will always fit into int</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="comment">// if we got here, the above string-to-integer conversion succeeded</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> MeshReader::NETGEN;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
<div class="ttc" id="namespacetut_html_aa3d137634e947af278a47517d75b6167"><div class="ttname"><a href="namespacetut.html#aa3d137634e947af278a47517d75b6167">tut::Reader</a></div><div class="ttdeci">static Reader_group Reader(&quot;Base/Reader&quot;)</div><div class="ttdoc">Define test group. </div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a08e7ddf794b944c7d2095c1222f4244a_cgraph.svg" width="266" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aeaca2df70ee950c576f6d74e1eb42caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaca2df70ee950c576f6d74e1eb42caa">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tk::dot </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the dot-product of two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot-product </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00053">53</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_base_2_vector_8h_source.html#l00067">triple()</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">return</span> v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab72923dba604ccbf4233af3ccafc70b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72923dba604ccbf4233af3ccafc70b3">&#9670;&nbsp;</a></span>echoBuildEnv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoBuildEnv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo build environment. </p>
<p>Echo information read from &lt;build&gt;/Base/Config.h filled by CMake based on src/Main/Config.h.in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00103">103</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_print_8h_source.html#l00194">tk::Print::item()</a>, and <a class="el" href="_print_8h_source.html#l00148">tk::Print::section()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00184">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;{</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  print.section( <span class="stringliteral">&quot;Build environment&quot;</span> );</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  print.item( <span class="stringliteral">&quot;Hostname&quot;</span>, BUILD_HOSTNAME );</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  print.item( <span class="stringliteral">&quot;Executable&quot;</span>, executable );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  print.item( <span class="stringliteral">&quot;Version&quot;</span>, VERSION );</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="keywordflow">if</span> (std::string(GIT_COMMIT).find(<span class="stringliteral">&quot;NOTFOUND&quot;</span>) == std::string::npos)</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    print.item( <span class="stringliteral">&quot;Revision SHA1&quot;</span>, GIT_COMMIT );</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  print.item( <span class="stringliteral">&quot;CMake build type&quot;</span>, BUILD_TYPE );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="preprocessor">#ifdef NDEBUG</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  print.item( <span class="stringliteral">&quot;MPI C++ wrapper&quot;</span>, MPI_COMPILER );</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  print.item( <span class="stringliteral">&quot;Underlying C++ compiler&quot;</span>, COMPILER );</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  print.item( <span class="stringliteral">&quot;Build date&quot;</span>, BUILD_DATE );</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab72923dba604ccbf4233af3ccafc70b3_cgraph.svg" width="310" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afbbf10b984ba3f66b55cc8363c6a2341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf10b984ba3f66b55cc8363c6a2341">&#9670;&nbsp;</a></span>echoHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo program header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which header to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00081">81</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_print_8h_source.html#l00496">tk::Print::headerInciter()</a>, <a class="el" href="_print_8h_source.html#l00592">tk::Print::headerMeshConv()</a>, <a class="el" href="_print_8h_source.html#l00528">tk::Print::headerRNGTest()</a>, <a class="el" href="_print_8h_source.html#l00560">tk::Print::headerUnitTest()</a>, <a class="el" href="_print_8h_source.html#l00624">tk::Print::headerWalker()</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd">INCITER</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35">MESHCONV</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da74844ca6f13566155f9e7e0128faf928">RNGTEST</a>, <a class="el" href="_exception_8h_source.html#l00034">Throw</a>, <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247">UNITTEST</a>, and <a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7da351468df7e784e7c87401bf0f31e1bfa">WALKER</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00184">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="keywordflow">if</span> ( header == HeaderType::INCITER )</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    print.headerInciter();</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::RNGTEST )</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    print.headerRNGTest();</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::UNITTEST )</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    print.headerUnitTest();</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::MESHCONV )</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    print.headerMeshConv();</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == HeaderType::WALKER )</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    print.headerWalker();</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Header not available&quot;</span> );</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_afbbf10b984ba3f66b55cc8363c6a2341_cgraph.svg" width="364" height="234"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a991ea7a4015fef3262bdb056f840bf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991ea7a4015fef3262bdb056f840bf82">&#9670;&nbsp;</a></span>echoRunEnv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tk::echoRunEnv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo runtime environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>True for verbose screen-output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00134">134</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_init_8h_source.html#l00052">curtime()</a>, <a class="el" href="_print_8h_source.html#l00194">tk::Print::item()</a>, <a class="el" href="_print_8h_source.html#l00148">tk::Print::section()</a>, and <a class="el" href="_init_8h_source.html#l00037">workdir()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00184">Main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;{</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  print.section( <span class="stringliteral">&quot;Run-time environment&quot;</span> );</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  print.item( <span class="stringliteral">&quot;Date, time&quot;</span>, <a class="code" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">curtime</a>() );</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  print.item( <span class="stringliteral">&quot;Work directory&quot;</span>, <a class="code" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">workdir</a>() );</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  print.item( <span class="stringliteral">&quot;Executable (rel. to work dir)&quot;</span>, argv[0] );</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  print.item(<span class="stringliteral">&quot;Command line arguments&quot;</span> );</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  print &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="keywordflow">if</span> (argc&gt;1) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=1; i&lt;argc-1; ++i) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;      print &lt;&lt; std::string( argv[i] ) + <span class="charliteral">&#39; &#39;</span>;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    }</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    print &lt;&lt; std::string( argv[argc-1] );</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  print &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  print.item( <span class="stringliteral">&quot;Output&quot;</span>, verbose ? <span class="stringliteral">&quot;verbose (quiet: omit -v)&quot;</span> : <span class="stringliteral">&quot;quiet&quot;</span> );</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8e567fa9a72a1d5d02cea9eb020b192a"><div class="ttname"><a href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">tk::workdir</a></div><div class="ttdeci">static std::string workdir()</div><div class="ttdoc">Wrapper for POSIX API&amp;#39;s getcwd() from unistd.h. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00037">Init.h:37</a></div></div>
<div class="ttc" id="namespacetk_html_a69ebefad09fa900014b6271b30e8bd5f"><div class="ttname"><a href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">tk::curtime</a></div><div class="ttdeci">static std::string curtime()</div><div class="ttdoc">Wrapper for the standard C library&amp;#39;s gettimeofday() from. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00052">Init.h:52</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a991ea7a4015fef3262bdb056f840bf82_cgraph.svg" width="303" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5983201a427244339722ca9a4e809f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5983201a427244339722ca9a4e809f48">&#9670;&nbsp;</a></span>elemCommMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; tk::elemCommMaps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute element-based communication maps. </p>
<p>Compute element-based communication maps </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Global mesh element ids owned by each chare distributed to PEs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-based communication map for all chares</dd></dl>
<p>This is an <em>element-based</em> export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns an element the mesh point is a vertex of. This is for algorithms that work by computing data on the mesh by looping over mesh elements, e.g., element-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p><dl class="section note"><dt>Note</dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_comm_map_8_c_source.html#l00131">131</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;{</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// unique global point ids sent (export map)</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  std::map&lt; std::size_t,</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="comment">// Construct element-based export maps</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pel : element)</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">for</span> (std::size_t c=0; c&lt;pel.size(); ++c)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : pel[c])</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">for</span> (std::size_t n=0; n&lt;4; ++n) {</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;          <span class="keyword">auto</span> p = tetinpoel[e*4+n];</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;          <span class="keywordflow">if</span> (chp[p] != c)      <span class="comment">// if the point-colors differ, store global id</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            comm[ c ][ chp[p] ].insert( p );</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">//   for (const auto&amp; c : comm) {</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">//     std::cout &lt;&lt; c.first &lt;&lt; &quot; -&gt; &quot;;</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">//     for (const auto&amp; t : c.second) {</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">//       std::cout &lt;&lt; t.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">//       for (auto p : t.second)</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">//       std::cout &lt;&lt; &quot;, &quot;;</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">//   std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="comment">// Construct final product: a vector of export maps associating receiver</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    ecomm( nchare );</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        ecomm[ e.first ][ x.first ].push_back( p );</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">//   std::size_t h = 0;</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">//   for (const auto&amp; m : ecomm) {</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; e-&gt; &quot;;</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">//     for (const auto&amp; x : m) {</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">//       for (auto p : x.second)</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="keywordflow">return</span> ecomm;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af0de4157a7818da7a9deb1476099bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0de4157a7818da7a9deb1476099bd8d">&#9670;&nbsp;</a></span>extents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 2 &gt; tk::extents </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return minimum and maximum values of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>Vector whose extents to compute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of two values with the minimum and maximum values  This function should not be called with heavy T types, as the a copy of a std::array&lt; T, 2 &gt; is created and returned. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00072">72</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_partitioner_8h_source.html#l00514">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::computeCentroids()</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;{</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="keyword">auto</span> x = std::minmax_element( begin(vec), end(vec) );</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">return</span> {{ *x.first, *x.second }};</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1930c11b6d90076b9d17c9f9c9d49efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1930c11b6d90076b9d17c9f9c9d49efe">&#9670;&nbsp;</a></span>extents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::extents </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> -&gt; std::array&lt; typename Container::mapped_type, 2 &gt;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00087">87</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;{</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keyword">using</span> pair_type = <span class="keyword">typename</span> Container::value_type;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keyword">auto</span> x = std::minmax_element( begin(map), end(map),</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;             []( <span class="keyword">const</span> pair_type&amp; a, <span class="keyword">const</span> pair_type&amp; b )</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;             { <span class="keywordflow">return</span> a.second &lt; b.second; } );</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keywordflow">return</span> {{ x.first-&gt;second, x.second-&gt;second }};</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a42982d289f8edfffa60fa4da8b7b9fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42982d289f8edfffa60fa4da8b7b9fdf">&#9670;&nbsp;</a></span>flip_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt; B, A &gt; tk::flip_map </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip a std::map of arbitrary types, yielding a std::multimap sorted by std::map::value_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>std::map of arbitrary key and value pairs of types A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::multimap of arbitrary key and value pairs of types B and A </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_flip__map_8h_source.html#l00031">31</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_r_n_g_test_print_8h_source.html#l00212">rngtest::RNGTestPrint::cost()</a>, and <a class="el" href="_r_n_g_test_print_8h_source.html#l00234">rngtest::RNGTestPrint::rank()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                                          {</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  std::multimap&lt; B, A &gt; dst;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  std::transform( src.begin(), src.end(), std::inserter(dst, dst.begin()), </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                  flip_pair&lt; A ,B &gt; );</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">return</span> dst;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac2323b3c43edbcc32d55d91100ffc3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2323b3c43edbcc32d55d91100ffc3a6">&#9670;&nbsp;</a></span>flip_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; B, A &gt; tk::flip_pair </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip a std::pair of arbitrary types </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>std::pair of arbitrary types, A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair of arbitrary types, B and A </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_flip__map_8h_source.html#l00022">22</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{ <span class="keywordflow">return</span> std::pair&lt; B, A &gt;( p.second, p.first ); }</div></div><!-- fragment -->
</div>
</div>
<a id="adb7a88611b67f7c809f2bba5c794df0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a88611b67f7c809f2bba5c794df0b">&#9670;&nbsp;</a></span>genEdsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEdsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edges surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing edges (point ids p &lt; q) emanating from points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>edsup1</em> and <em>edsup2</em>, where <em>edsup2</em> holds the indices at which <em>edsup1</em> holds the edge-end point ids emanating from points for all points. The generated data structure, linked lists edsup1 and edsup2, are very similar to psup1 and psup2, generated by <a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points. ">genPsup()</a>, except here only unique edges are stored, i.e., for edges with point ids p &lt; q, only ids q are stored that are still associated to point p. Looping over all unique edges can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup.second[p]+1; i&lt;=edsup.second[p+1]; ++i)</div><div class="line">    <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> edge with point ids p &lt; edsup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity. ">tk::genInpoed</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00206">206</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;{</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() on empty container&quot;</span> );</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEdsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEdsup() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup1&quot;</span> );</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup2&quot;</span> );</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back(q);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      }</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="comment">// linked lists (vectors) to store edges surrounding points and their indices</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  std::vector&lt; std::size_t &gt; edsup1( 1, 0 ), edsup2( 1, 0 );</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// sort non-center points of each star and store nodes and indices in vectors</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    edsup2.push_back( edsup2.back() + p.second.size() );</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) edsup1.push_back( e );</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="comment">// fill up index array with the last index for points with no new edges</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;npoin-star.size(); ++i)</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    edsup2.push_back( edsup2.back() );</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(edsup1), std::move(edsup2) );</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abff39252e99681eebb5ccf0078b7b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff39252e99681eebb5ccf0078b7b924">&#9670;&nbsp;</a></span>genEsued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsued </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding edges </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esued1</em> and <em>esued2</em>, where <em>esued2</em> holds the indices at which <em>esued1</em> holds the element ids surrounding edges. Looping over all elements surrounding edges can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nedge; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esued.second[e]+1; i&lt;=esued.second[e+1]; ++i)</div><div class="line">    <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> element <span class="keywordtype">id</span> esued.first[i]</div></div><!-- fragment --><p> To find out the number of edges, <em>nedge</em>, the edge connectivity, <em>inpoed</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> esup = <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>(inpoel,nnpe);</div><div class="line"><span class="keyword">auto</span> nedge = <a class="code" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">tk::genInpoed</a>(inpoel,nnpe,esup).size()/2;</div></div><!-- fragment --><p> where <em>nnpe</em> is the number of nodes per element (4 for tetrahedra, 3 for triangles). </p><dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00701">701</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;{</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() on empty container&quot;</span> );</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsued() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsued() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup1&quot;</span> );</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup2&quot;</span> );</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  <span class="comment">// lambda that returns true if element e contains edge (p &lt; q)</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="keyword">auto</span> has = [ &amp;inpoel, nnpe ]( std::size_t e, std::size_t p, std::size_t q )</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  -&gt; <span class="keywordtype">bool</span> {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    std::vector&lt; bool &gt; sp;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n)</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;      <span class="keywordflow">if</span> (inpoel[e*nnpe+n] == p || inpoel[e*nnpe+n] == q)</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        sp.push_back( <span class="keyword">true</span> );</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    <span class="keywordflow">if</span> (sp.size() == 2) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  };</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  <span class="comment">// map to associate edges to unique surrounding element ids</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  std::map&lt; std::size_t,  std::vector&lt; std::size_t &gt; &gt; revolver;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <span class="comment">// generate edges and associated vector of unique surrounding element ids</span></div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;  std::size_t ed = 0;</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) {  <span class="comment">// for edge given point ids p &lt; q</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;            <span class="keywordflow">for</span> (std::size_t j=esup2[p]+1; j&lt;=esup2[p+1]; ++j ) {</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;              <span class="keyword">auto</span> e = esup1[j];</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;              <span class="keywordflow">if</span> (has(e,p,q)) revolver[ed].push_back(e);</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            }</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;            ++ed;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;          }</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        }</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;      }</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;  <span class="comment">// linked lists (vectors) to store elements surrounding edges</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;  std::vector&lt; std::size_t &gt; esued1( 1, 0 ), esued2( 1, 0 );</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  <span class="comment">// sort and store elements surrounding edges and their indices in vectors</span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : revolver) {</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    esued2.push_back( esued2.back() + p.second.size() );</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) esued1.push_back( e );</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  }</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esued1), std::move(esued2) );</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b12aff8f884c70e45c6037b4f37e662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b12aff8f884c70e45c6037b4f37e662">&#9670;&nbsp;</a></span>genEsuel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsuel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esuel1</em> and <em>esuel2</em>, where <em>esuel2</em> holds the indices at which <em>esuel1</em> holds the element ids surrounding elements. Looping over elements surrounding elements can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esuel.second[e]+1; i&lt;=esuel.second[e+1]; ++i)</div><div class="line">     <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> element <span class="keywordtype">id</span> esuel.first[i]</div></div><!-- fragment --><p> To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00490">490</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;{</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() on empty container&quot;</span> );</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsuel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by four&quot;</span> );</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel1&quot;</span> );</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel2&quot;</span> );</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <span class="comment">// lambda that returns true if elements hel and gel share a face</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <span class="keyword">auto</span> adj = [ &amp;inpoel, nnpe ]( std::size_t hel, std::size_t gel ) -&gt; <span class="keywordtype">bool</span> {</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    std::vector&lt; bool &gt; sp;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    <span class="keywordflow">for</span> (std::size_t h=0; h&lt;nnpe; ++h)</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;      <span class="keywordflow">for</span> (std::size_t g=0; g&lt;nnpe; ++g)</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        <span class="keywordflow">if</span> (inpoel[hel*nnpe+h] == inpoel[gel*nnpe+g]) sp.push_back( <span class="keyword">true</span> );</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordflow">if</span> (sp.size() == nnpe-1) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  };</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="comment">// map to associate unique elements and their surrounding elements</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; es;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    std::set&lt; std::size_t &gt; faces; <span class="comment">// will collect elem ids of shared faces</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;      <span class="keyword">auto</span> i = inpoel[ e*nnpe+n ];</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=esup2[i]+1; j&lt;=esup2[i+1]; ++j)</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">if</span> (adj( e, esup1[j] )) faces.insert( esup1[j] );</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="comment">// store element ids of shared faces</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : faces) es[e].push_back(j);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  }</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  <span class="comment">// storing elements surrounding elements</span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  std::vector&lt; std::size_t &gt; esuel1( 1, 0 ), esuel2( 1, 0 );</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="comment">// store elements surrounding elements in linked lists</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : es) {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    esuel2.push_back( esuel2.back() + e.second.size() );</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : e.second) esuel1.push_back( s );</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  }</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esuel1), std::move(esuel2) );</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a66a2889d5d8aeb4a836842c6a1010463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a2889d5d8aeb4a836842c6a1010463">&#9670;&nbsp;</a></span>genEsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esup1</em> and <em>esup2</em>, where <em>esup2</em> holds the indices at which <em>esup1</em> holds the element ids surrounding points. Looping over all elements surrounding all points can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup.second[p]+1; i&lt;=esup.second[p+1]; ++i)</div><div class="line">     <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> element <span class="keywordtype">id</span> esup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00026">26</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00029">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00340">inciter::FluxCorrector::alw()</a>, <a class="el" href="_comm_map_8_c_source.html#l00029">poinCommMaps()</a>, <a class="el" href="_tracker_8h_source.html#l00044">tk::Tracker::Tracker()</a>, and <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsup() on empty container&quot;</span> );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="comment">// allocate one of the linked lists storing elements surrounding points: esup2</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// fill with zeros</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  std::vector&lt; std::size_t &gt; esup2( npoin+1, 0 );</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="comment">// element pass 1: count number of elements connected to each point</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) ++esup2[ n + 1 ];</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="comment">// storage/reshuffling pass 1: update storage counter and store</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// also find out the maximum size of esup1 (mesup)</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="keyword">auto</span> mesup = esup2[0]+1;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=1; i&lt;npoin+1; ++i) {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    esup2[i] += esup2[i-1];</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordflow">if</span> (esup2[i]+1 &gt; mesup) mesup = esup2[i]+1;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="comment">// now we know mesup, so allocate the other one of the linked lists storing</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="comment">// elements surrounding points: esup1</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  std::vector&lt; std::size_t &gt; esup1( mesup );</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// store the elements in esup1</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  std::size_t e = 0;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keyword">auto</span> j = esup2[n]+1;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    esup2[n] = j;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    esup1[j] = e/nnpe;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    ++e;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// storage/reshuffling pass 2</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=npoin; i&gt;0; --i) esup2[i] = esup2[i-1];</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  esup2[0] = 0;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esup1), std::move(esup2) );</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d835a7a93970d17a66356b64f3291af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d835a7a93970d17a66356b64f3291af">&#9670;&nbsp;</a></span>genEsupel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genEsupel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, elements surrounding points of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing elements surrounding points of elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esupel1</em> and <em>esupel2</em>, where <em>esupel2</em> holds the indices at which <em>esupel1</em> holds the element ids surrounding points of elements. Looping over all elements surrounding the points of all elements can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esupel.second[e]+1; i&lt;=esupel.second[e+1]; ++i)</div><div class="line">     <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> element <span class="keywordtype">id</span> esupel.first[i]</div></div><!-- fragment --><p> To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00413">413</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_tracker_8h_source.html#l00044">tk::Tracker::Tracker()</a>.</p>
<div class="fragment"><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;{</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() on empty container&quot;</span> );</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsupel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup1&quot;</span> );</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;          <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup2&quot;</span> );</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <span class="comment">// linked lists storing elements surrounding points of elements, put in a</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  <span class="comment">// single zero in both</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  std::vector&lt; std::size_t &gt; esupel2( 1, 0 ), esupel1( 1, 0 );</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  std::size_t e = 0;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  std::set&lt; std::size_t &gt; esuel;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : inpoel) {       <span class="comment">// loop over all points of all elements</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="comment">// collect unique element ids of elements surrounding points of element</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup2[p]+1; i&lt;=esup2[p+1]; ++i) esuel.insert( esup1[i] );</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">if</span> (++e%nnpe == 0) {        <span class="comment">// when finished checking all nodes of element</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <span class="comment">// erase element whose surrounding elements are considered</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      esuel.erase( e/nnpe-1 );</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      <span class="comment">// store unique element ids in esupel1</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : esuel) esupel1.push_back( i );</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      <span class="comment">// store end-index for element used to address into esupel1</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      esupel2.push_back( esupel2.back() + esuel.size() );</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      esuel.clear();</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    }</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  }</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(esupel1), std::move(esupel2) );</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c8a720dd257388a44d5ca7af7aaec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8a720dd257388a44d5ca7af7aaec8f">&#9670;&nbsp;</a></span>genInedel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genInedel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edges of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoed</td><td>Edge connectivity as linear vector, see <a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity. ">tk::genInpoed</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear vector storing all edge ids * 2 of all elements </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or inpoed or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector with all edge ids (as defined by inpoed) of all elements. The edge ids stored in inedel can be directly used to index the vector inpoed. Because the derived data structure generated here, inedel, is intended to be used in conjunction with the linear vector inpoed and not with the linked lists edsup1 and edsup2, this function takes inpoed as an argument. Accessing the edges of element e using the edge of elements data structure, inedel, generated here can be accomplished by </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;nepe; ++i) {</div><div class="line">    <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> edge <span class="keywordtype">id</span> inedel[e*nepe+i] of element e, or</div><div class="line">    <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> point ids p &lt; q of edge <span class="keywordtype">id</span> inedel[e*nepe+i] of element e as</div><div class="line">      p = inpoed[ inedel[e*nepe+i]*2 ]</div><div class="line">      q = inpoed[ inedel[e*nepe+i]*2+1 ]</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> where <em>nepe</em> denotes the number of edges per elements: 3 for triangles, 6 for tetrahedra. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00580">580</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;{</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() on empty container&quot;</span> );</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInedel() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInedel() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoed.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() with empty inpoed&quot;</span> );</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <span class="comment">// First, generate index of star centers. This is necessary to avoid a</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  <span class="comment">// brute-force search for point ids of edges when searching for element edges.</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  <span class="comment">// Note that this is the same as edsup2, generated by genEdsup(). However,</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="comment">// because the derived data structure generated here, inedel, is intended to</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  <span class="comment">// be used in conjunction with the linear vector inpoed and not with the</span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  <span class="comment">// linked lists edsup1 and edsup2, this function takes inpoed as an argument,</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  <span class="comment">// and so edsup2 is temporarily generated here to avoid a brute-force search.</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;  <span class="comment">// generate stars from inpoed; starting with zero, every even is a star</span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  <span class="comment">// center, every odd is a spike</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;inpoed.size()/2; ++i)</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    star[ inpoed[i*2] ].push_back( inpoed[i*2+1] );</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  <span class="comment">// store index of star centers in vector; assume non-center points of each</span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  <span class="comment">// star have already been sorted</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  std::vector&lt; std::size_t &gt; edsup2( 1, 0 );</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) edsup2.push_back( edsup2.back() + p.second.size() );</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  <span class="comment">// fill up index array with the last index for points with no new edges</span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;npoin-star.size(); ++i)</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    edsup2.push_back( edsup2.back() );</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  star.clear();</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  <span class="comment">// Second, generate edges of elements</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="comment">// map associating elem id with vector of edge ids</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; edges;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  <span class="comment">// generate map of elements associated to edge ids</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;      <span class="keyword">auto</span> p = inpoel[e*nnpe+n];</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup2[p]+1; i&lt;=edsup2[p+1]; ++i)</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;         <span class="keywordflow">for</span> (std::size_t j=0; j&lt;nnpe; ++j)</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            <span class="keywordflow">if</span> (inpoed[(i-1)*2+1] == inpoel[e*nnpe+j])</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;              edges[e].push_back( i-1 );</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    }</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <span class="comment">// linear vector to store the edge ids of all elements</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;  std::vector&lt; std::size_t &gt; inedel;</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  <span class="comment">// store edge ids of elements in linear vector</span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : edges) <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : e.second) inedel.push_back( p );</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  <span class="comment">// Return (move out) vector</span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  <span class="keywordflow">return</span> inedel;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a559eb56e40ec844767bd2a55da55bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559eb56e40ec844767bd2a55da55bda0">&#9670;&nbsp;</a></span>genInpoed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; tk::genInpoed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, edge connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear vector storing edge connectivity (point ids p &lt; q) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector and is very similar to the linked lists, <em>edsup1</em> and _edsup2, generated by <a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points. ">genEdsup()</a>. The difference is that in the linear vector, inpoed, generated here, both edge point ids are stored as a pair, p &lt; q, as opposed to the linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end point ids (still associated to edge-start point ids when used together with edsup2). The rationale is that while inpoed is larger in memory, it allows direct access to edges (pair of point ids making up an edge), edsup1 and edsup2 are smaller in memory, still allow accessing the same data (edge point id pairs) but only in a linear fashion, not by direct access to particular edges. Accessing all unique edges using the edge connectivity data structure, inpoed, generated here can be accomplished by </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t e=0; e&lt;inpoed.size()/2; ++e) {</div><div class="line">  <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> point <span class="keywordtype">id</span> p of edge e = inpoed[e*2];</div><div class="line">  <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> point <span class="keywordtype">id</span> q of edge e = inpoed[e*2+1];</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points. ">tk::genEdsup</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00310">310</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;{</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() on empty container&quot;</span> );</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInpoed() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe == 3 || nnpe == 4,</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInpoed() with nodes per element, nnpe, that is &quot;</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup1&quot;</span> );</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(),</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;          <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup2&quot;</span> );</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="comment">// map to contain stars, a point associated to points connected with edges,</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back( q );</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        }</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      }</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="comment">// linear vector to store edge connectivity and their indices</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  std::vector&lt; std::size_t &gt; inpoed;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="comment">// sort non-center points of each star and store both start and end points of</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  <span class="comment">// each star in linear vector</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    std::sort( begin(p.second), end(p.second) );</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      inpoed.push_back( p.first );</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      inpoed.push_back( e );</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    }</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  }</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  <span class="comment">// Return (move out) linear vector</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  <span class="keywordflow">return</span> inpoed;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2a88a65102c17149b44660db15d445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a88a65102c17149b44660db15d445b">&#9670;&nbsp;</a></span>genPsup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::genPsup </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate derived data structure, points surrounding points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><div class="line">std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,</div><div class="line">                                    10, 14, 13, 12 };</div></div><!-- fragment --> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points. ">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linked lists storing points surrounding points </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>psup1</em> and <em>psup2</em>, where <em>psup2</em> holds the indices at which <em>psup1</em> holds the point ids surrounding points. Looping over all points surrounding all points can then be accomplished by the following loop: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i)</div><div class="line">     <a class="code" href="namespaceinciter_1_1cmd.html#aab3b5e67ca01d6a67e7fdd50b7a9c37c">use</a> point <span class="keywordtype">id</span> psup.first[i]</div></div><!-- fragment --><p> To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><span class="keyword">auto</span> npoin = *minmax.second + 1;</div></div><!-- fragment --><p> or the length-1 of the generated index list: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> npoin = psup.second.size()-1;</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_derived_data_8_c_source.html#l00110">110</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_comm_map_8_c_source.html#l00029">poinCommMaps()</a>, and <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;{</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() on empty container&quot;</span> );</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genPsup() with zero nodes per element&quot;</span> );</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup1&quot;</span> );</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup2&quot;</span> );</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="comment">// find out number of points in mesh connectivity</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="keyword">auto</span> npoin = *minmax.second + 1;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="keyword">auto</span>&amp; esup1 = esup.first;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="keyword">auto</span>&amp; esup2 = esup.second;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="comment">// allocate both of the linked lists storing points surrounding points, we</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="comment">// only know the size of psup2, put in a single zero in psup1</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  std::vector&lt; std::size_t &gt; psup2( npoin+1 ), psup1( 1, 0 );</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="comment">// fill both psup1 and psup2</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  psup2[0] = 0;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  std::size_t j = 0;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p) {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i ) {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;          ++j;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;          psup1.push_back( q );</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;          lpoin[q] = p+1;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    psup2[p+1] = j;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  }</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// sort point ids for each point in psup1</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    std::sort(</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p]+1) ),</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p+1]+1) ) );</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="comment">// Return (move out) linked lists</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="keywordflow">return</span> std::make_pair( std::move(psup1), std::move(psup2) );</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ee7abd71123782d48e2ec04906fe982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee7abd71123782d48e2ec04906fe982">&#9670;&nbsp;</a></span>global2local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt;, std::unordered_map&lt; std::size_t, std::size_t &gt; &gt; tk::global2local </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ginpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ginpoel</td><td>Element connectivity with global node IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) element connectivity with local node IDs, (2) the vector of unique global node IDs (i.e., the mapping between local to global node IDs), and (3) mapping between global to local node IDs. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00140">140</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_reorder_8_c_source.html#l00123">assignLid()</a>, <a class="el" href="_container_util_8h_source.html#l00040">cref_find()</a>, and <a class="el" href="_container_util_8h_source.html#l00025">unique()</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;{</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// Make a copy of the element connectivity with global node ids</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="keyword">auto</span> gid = ginpoel;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="comment">// Generate a vector that holds only the unique global mesh node ids</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( gid );</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="comment">// Assign local node ids to global node ids</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> lid = <a class="code" href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">tk::assignLid</a>( gid );</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="comment">// Generate element connectivity using local node ids</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  std::vector&lt; std::size_t &gt; inpoel;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : ginpoel) inpoel.push_back( <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a>( lid, p ) );</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// Return element connectivty with local node IDs</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="keywordflow">return</span> std::make_tuple( inpoel, gid, lid );</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00025">ContainerUtil.h:25</a></div></div>
<div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00040">ContainerUtil.h:40</a></div></div>
<div class="ttc" id="namespacetk_html_acb19d7c5f6c7354614bb457d6b17afde"><div class="ttname"><a href="namespacetk.html#acb19d7c5f6c7354614bb457d6b17afde">tk::assignLid</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, std::size_t &gt; assignLid(const std::vector&lt; std::size_t &gt; &amp;gid)</div><div class="ttdoc">Assign local ids to global ids. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00123">Reorder.C:123</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a0ee7abd71123782d48e2ec04906fe982_cgraph.svg" width="276" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad6260a3dcdcb9a995a4886e566b665c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6260a3dcdcb9a995a4886e566b665c4">&#9670;&nbsp;</a></span>hms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a> tk::hms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>stamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert existing time stamp as a real to Watch (global scope) </p>
<p>Convert existing time stamp as a real to Watch (global-scope) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stamp</td><td>Time stamp as a real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time as hours, minutes, and seconds, as a Watch struct. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_timer_8_c_source.html#l00094">94</a> of file <a class="el" href="_timer_8_c_source.html">Timer.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inciter_8_c_source.html#l00164">Main::execute()</a>, <a class="el" href="_inciter_8_c_source.html#l00172">Main::finalize()</a>, and <a class="el" href="_mesh_conv_8_c_source.html#l00111">Main::timestamp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;{</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keyword">using</span> std::chrono::duration_cast;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> d = Timer::Dsec( stamp );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">return</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    Timer::Watch( duration_cast&lt; Timer::hours &gt;( d ),</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                  duration_cast&lt; Timer::minutes &gt;( d ) % Timer::hours(1),</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                  duration_cast&lt; Timer::seconds &gt;( d ) % Timer::minutes(1) );</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aeb9673379e599043b13fff369dce1402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9673379e599043b13fff369dce1402">&#9670;&nbsp;</a></span>instantiate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Obj &gt; tk::instantiate </td>
          <td>(</td>
          <td class="paramtype">const Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiate object from factory. Factory must have a mapped_value which must have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This wrapper function can be used to instantiate an derived-class object from a factory, repeatedly filled with wrapper function 'record' above. The factory, as described in the documentation of 'record', stores base class pointers in an associative container, thereby facilitating runtime polymorphism and a simple lookup-and-instantiate-style object creation. The object instantiated is of type Child class. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to instantiate object from (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the object to instantiate from factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr pointing to the object instantiated from factory </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980">record</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00076">76</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, and <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                                                                     {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> it = f.find( key );</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( it != end( f ), <span class="stringliteral">&quot;No such object registered in factory&quot;</span> );</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordflow">return</span> std::unique_ptr&lt; Obj &gt;( it-&gt;second() );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_aeb9673379e599043b13fff369dce1402_cgraph.svg" width="263" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6b203c3a87657090a5c477896ce94bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b203c3a87657090a5c477896ce94bf9">&#9670;&nbsp;</a></span>keyEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::keyEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if all keys of two associative containers are equal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st container to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd container to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the containers have the same size and all keys (and only the keys) of the two containers are equal </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is an error to call this function with unequal-size containers, triggering an exception in DEBUG mode. </dd>
<dd>
Operator != is used to compare the container keys. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00142">142</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_aux_solver_8h_source.html#l00218">inciter::AuxSolverLumpMassDiff::solve()</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                                                        {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.size() == b.size(), <span class="stringliteral">&quot;Size mismatch comparing containers&quot;</span> );</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keyword">auto</span> ia = a.cbegin();</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keyword">auto</span> ib = b.cbegin();</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="keywordflow">while</span> (ia != a.cend()) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">if</span> (ia-&gt;first != ib-&gt;first) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    ++ia;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    ++ib;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae484074849c5c9532282fc9fa4e19467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484074849c5c9532282fc9fa4e19467">&#9670;&nbsp;</a></span>linearLoadDistributor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t tk::linearLoadDistributor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>virtualization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>chunksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute linear load distribution for given total work and virtualization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualization</td><td>Degree of virtualization [0.0...1.0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load</td><td>Total load, e.g., number of particles, number of mesh cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npe</td><td>Number of processing elements to distribute the load to </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chunksize</td><td>Chunk size, see detailed description </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">remainder</td><td>Remainder, see detailed description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of work units</dd></dl>
<p>Compute load distibution (number of chares and chunksize) based on total work (e.g., total number of particles) and virtualization</p>
<p>The virtualization parameter, specified by the user, is a real number between 0.0 and 1.0, inclusive, which controls the degree of virtualization or over-decomposition. Independent of the value of virtualization the work is approximately evenly distributed among the available processing elements, given by npe. For zero virtualization (no over-decomposition), the work is simply decomposed into total_work/numPEs, which yields the smallest number of Charm++ chares and the largest chunks of work units. The other extreme is unity virtualization, which decomposes the total work into the smallest size work units possible, yielding the largest number of Charm++ chares. Obviously, the optimum will be between 0.0 and 1.0, depending on the problem.</p>
<p>The formula implemented uses a linear relationship between the virtualization parameter and the number of work units with the extremes described above. The formula is given by</p>
<p>chunksize = (1 - n) * v + n;</p>
<p>where</p><ul>
<li>v = degree of virtualization</li>
<li>n = load/npes</li>
<li>load = total work, e.g., number of particles, number of mesh cells</li>
<li>npes = number of hardware processing elements <dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="_load_distributor_8_c_source.html#l00022">22</a> of file <a class="el" href="_load_distributor_8_c_source.html">LoadDistributor.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_distributor_8_c_source.html#l00053">walker::Distributor::Distributor()</a>, and <a class="el" href="_transporter_8_c_source.html#l00230">inciter::Transporter::load()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( virtualization &gt; -std::numeric_limits&lt; tk::real &gt;::epsilon() &amp;&amp;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;          virtualization &lt; 1.0+std::numeric_limits&lt; tk::real &gt;::epsilon(),</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;          <span class="stringliteral">&quot;Virtualization parameter must be between [0.0...1.0]&quot;</span> );</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( npe &gt; 0, <span class="stringliteral">&quot;Number of processing elements must be larger than zero&quot;</span> );</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="comment">// Compute minimum number of work units</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span> <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> <span class="keyword">&gt;</span>( load ) / npe;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Compute work unit size based on the linear formula above</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  chunksize = <span class="keyword">static_cast&lt;</span> uint64_t <span class="keyword">&gt;</span>( (1.0 - n) * virtualization + n );</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// Compute number of work units with size computed ignoring remainder</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  uint64_t nchare = load / chunksize;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="comment">// Compute remainder of work if the above number of units were to be created</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  remainder = load - nchare * chunksize;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// Redistribute remainder among the work units for a more equal distribution</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  chunksize += remainder / nchare;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// Compute new remainder (after redistribution of the previous remainder)</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  remainder = load - nchare * chunksize;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="comment">// Return number of work units (number of Charm++ chares)</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">return</span> nchare;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00018">Types.h:18</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af9d21933fc9e1a656db37419b2173f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d21933fc9e1a656db37419b2173f5f">&#9670;&nbsp;</a></span>Main()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class Printer , class CmdLine &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_driver.html">Driver</a> tk::Main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmdLine &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output. ">Main()</a> used for all executables for code-reuse and a uniform output. </p>
<p>The template arguments configure this <a class="el" href="class_main.html" title="Charm++ main chare for the shock hydroddynamics executable, inciter. ">Main</a> class that is practically used instead of the usual <a class="el" href="_unit_test_8_c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="UnitTest main() ">main()</a>. This allows code-reuse and a unfirom screen-output. The template arguments are:</p><ul>
<li><a class="el" href="classtk_1_1_driver.html">Driver</a>, specializaing the driver type to be created, see <a class="el" href="classtk_1_1_driver.html">tk::Driver</a></li>
<li>Printer, specializaing the pretty printer type to use, see <a class="el" href="classtk_1_1_print.html">tk::Print</a></li>
<li>CmdLine, specializing the command line object storing data parsed from the command line <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>Command line object storing data parsed from the command line arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which executable header to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instantiated driver object which can then be used to <a class="el" href="classexecute.html" title="Charm++ chare execute. ">execute()</a> whatever it is intended to drive </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00184">184</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_init_8h_source.html#l00103">echoBuildEnv()</a>, <a class="el" href="_init_8h_source.html#l00081">echoHeader()</a>, and <a class="el" href="_init_8h_source.html#l00134">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;{</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// Echo program header</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <a class="code" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">echoHeader</a>( print, header );</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="comment">// Echo environment</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  print.part( <span class="stringliteral">&quot;Environment&quot;</span> );</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// Build environment</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <a class="code" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">echoBuildEnv</a>( print, executable );</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="comment">// Runtime environment</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <a class="code" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">echoRunEnv</a>( print, argc, argv, cmdline.template get&lt; tag::verbose &gt;() );</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// Create and return driver</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keywordflow">return</span> Driver( print, cmdline );</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;}</div><div class="ttc" id="namespacetk_html_ab72923dba604ccbf4233af3ccafc70b3"><div class="ttname"><a href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">tk::echoBuildEnv</a></div><div class="ttdeci">static void echoBuildEnv(const Print &amp;print, const std::string &amp;executable)</div><div class="ttdoc">Echo build environment. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00103">Init.h:103</a></div></div>
<div class="ttc" id="namespacetk_html_a991ea7a4015fef3262bdb056f840bf82"><div class="ttname"><a href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">tk::echoRunEnv</a></div><div class="ttdeci">static void echoRunEnv(const Print &amp;print, int argc, char **argv, bool verbose)</div><div class="ttdoc">Echo runtime environment. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00134">Init.h:134</a></div></div>
<div class="ttc" id="namespacetk_html_afbbf10b984ba3f66b55cc8363c6a2341"><div class="ttname"><a href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">tk::echoHeader</a></div><div class="ttdeci">static void echoHeader(const Print &amp;print, HeaderType header)</div><div class="ttdoc">Echo program header. </div><div class="ttdef"><b>Definition:</b> <a href="_init_8h_source.html#l00081">Init.h:81</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_af9d21933fc9e1a656db37419b2173f5f_cgraph.svg" width="490" height="431"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac9a26e30d19b940a12990a866a514cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a26e30d19b940a12990a866a514cb5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; tk::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator max between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object containing the maximum of all values for each value in <em>a</em> and <em>b</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties. </dd>
<dd>
As opposed to std::max, this function creates and returns a new object instead of returning a reference to the smaller one of the operands. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00581">581</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_data_8h_source.html#l00279">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00196">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00190">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00029">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00340">inciter::FluxCorrector::alw()</a>, <a class="el" href="_p_d_f_writer_8h_source.html#l00086">tk::PDFWriter::assertSampleSpaceExtents()</a>, <a class="el" href="_transport_physics_8h_source.html#l00056">inciter::TransportPhysicsAdvection::diffusion_dt()</a>, <a class="el" href="_transport_physics_8h_source.html#l00116">inciter::TransportPhysicsAdvDiff::diffusion_dt()</a>, <a class="el" href="_carrier_8_c_source.html#l00379">inciter::Carrier::dt()</a>, <a class="el" href="_transport_8h_source.html#l00251">inciter::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_comp_flow_8h_source.html#l00255">inciter::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_p_d_f_writer_8_c_source.html#l01175">tk::PDFWriter::extents()</a>, <a class="el" href="_comp_flow_physics_8h_source.html#l00193">inciter::CompFlowPhysicsNavierStokes::heat_diffusion_dt()</a>, <a class="el" href="_comp_flow_physics_8h_source.html#l00256">inciter::CompFlowPhysicsEuler::heat_diffusion_dt()</a>, <a class="el" href="_inciter_2_input_deck_2_input_deck_8h_source.html#l00118">inciter::ctr::InputDeck::InputDeck()</a>, <a class="el" href="_walker_2_input_deck_2_input_deck_8h_source.html#l00225">walker::ctr::InputDeck::InputDeck()</a>, <a class="el" href="_random123_8h_source.html#l00047">tk::Random123&lt; CBRNG &gt;::Adaptor::max()</a>, <a class="el" href="_carrier_8_c_source.html#l00445">inciter::Carrier::rhs()</a>, <a class="el" href="_progress_8h_source.html#l00075">tk::Progress&lt; 4 &gt;::start()</a>, <a class="el" href="_comp_flow_physics_8h_source.html#l00132">inciter::CompFlowPhysicsNavierStokes::viscous_dt()</a>, <a class="el" href="_comp_flow_physics_8h_source.html#l00239">inciter::CompFlowPhysicsEuler::viscous_dt()</a>, and <a class="el" href="_p_d_f_writer_8_c_source.html#l00052">tk::PDFWriter::writeTxt()</a>.</p>
<div class="fragment"><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                                                                       {</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nunk() == b.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nprop() == b.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  Data&lt; Layout &gt; r( a.nunk(), a.nprop() );</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  std::transform( a.data().cbegin(), a.data().cend(),</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                  b.data().cbegin(), r.data().begin(),</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                  []( <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> s, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d ){ <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">std::max</a>(s,d); } );</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;}</div><div class="ttc" id="namespacetk_html_ac9a26e30d19b940a12990a866a514cb5"><div class="ttname"><a href="namespacetk.html#ac9a26e30d19b940a12990a866a514cb5">tk::max</a></div><div class="ttdeci">Data&lt; Layout &gt; max(const Data&lt; Layout &gt; &amp;a, const Data&lt; Layout &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_data_8h_source.html#l00581">Data.h:581</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00018">Types.h:18</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac9a26e30d19b940a12990a866a514cb5_cgraph.svg" width="243" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab7f02155bc2945a0a0c82c1be5cad041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f02155bc2945a0a0c82c1be5cad041">&#9670;&nbsp;</a></span>maxdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; tk::maxdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the maximum difference between the elements of two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index, i.e., the raw position, of and the largest absolute value of the difference between all corresponding elements of <em>lhs</em> and <em>rhs</em>.</dd></dl>
<p>The position returned is the position in the underlying raw data structure, independent of components, offsets, etc. If lhs == rhs with precision std::numeric_limits&lt; tk::real &gt;::epsilon(), a pair of (0,0.0) is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>lhs</em> and <em>rhs</em> must have the same number of unknowns and properties. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00632">632</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_data_8h_source.html#l00279">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00196">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00190">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00174">inciter::FluxCorrector::verify()</a>.</p>
<div class="fragment"><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                                                                {</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( lhs.nunk() == rhs.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( lhs.nprop() == rhs.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="keyword">auto</span> l = lhs.data().cbegin();</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <span class="keyword">auto</span> r = rhs.data().cbegin();</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  std::pair&lt; std::size_t, tk::real &gt; m( 0, std::abs(*l - *r) );</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  ++l; ++r;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <span class="keywordflow">while</span> (l != lhs.data().cend()) {</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> d = std::abs(*l - *r);</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keywordflow">if</span> (d &gt; m.second) m = { std::distance(lhs.data().cbegin(),l), d };</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    ++l; ++r;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  }</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  <span class="keywordflow">return</span> m;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab7f02155bc2945a0a0c82c1be5cad041_cgraph.svg" width="263" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac371117af5d2009dca83a8cb5539a43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371117af5d2009dca83a8cb5539a43f">&#9670;&nbsp;</a></span>mergeHashMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg* tk::mergeHashMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized maps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated std::unordered_maps built for further aggregation if needed</dd></dl>
<p>During aggregation the map keys are inserted, i.e., the keys remain unique and the mapped values, assuming containers defining begin() and end() iterators() are concatenated. </p><dl class="section note"><dt>Note</dt><dd>The mapped type must be a container, i.e., must provide iterators begin() and end(). </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_hash_map_reducer_8h_source.html#l00065">65</a> of file <a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00032">serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_lin_sys_merger_8h_source.html#l00332">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::registerBCMerger()</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="comment">// Will store deserialized map</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; p;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Deserialize map from raw stream</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  creator | p;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// Unpack map</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; u;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    curCreator | u;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// Concatenate maps</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : u) {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      <span class="keyword">auto</span>&amp; b = p[ c.first ];</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      b.insert( end(b), begin(c.second), end(c.second) );</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    }</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="comment">// Serialize concatenated maps to raw stream</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( p );</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">// Forward serialized hash map</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00032">HashMapReducer.h:32</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac371117af5d2009dca83a8cb5539a43f_cgraph.svg" width="291" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab8753a2df233c9b1327d5682940ddcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8753a2df233c9b1327d5682940ddcbf">&#9670;&nbsp;</a></span>mergePDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg * tk::mergePDF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging PDFs during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized PDFs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated PDFs built for further aggregation if needed </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00050">50</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00032">serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_collector_8h_source.html#l00089">walker::Collector::registerPDFMerger()</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;{</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// Will store deserialized uni-, bi-, and tri-variate PDFs</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  std::vector&lt; tk::UniPDF &gt; updf;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  std::vector&lt; tk::BiPDF &gt; bpdf;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  std::vector&lt; tk::TriPDF &gt; tpdf;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// Deserialize PDFs from raw stream</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  creator | updf;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  creator | bpdf;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  creator | tpdf;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// Unpack PDFs</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    std::vector&lt; tk::UniPDF &gt; u;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    std::vector&lt; tk::BiPDF &gt; b;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    std::vector&lt; tk::TriPDF &gt; t;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    curCreator | u;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    curCreator | b;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    curCreator | t;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="comment">// Merge PDFs</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    std::size_t i = 0;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : u) updf[i++].addPDF( p );</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    i = 0;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : b) bpdf[i++].addPDF( p );</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    i = 0;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : t) tpdf[i++].addPDF( p );</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">// Serialize vector of merged PDFs to raw stream</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( updf, bpdf, tpdf );</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// Forward serialized PDFs</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;}</div><div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00032">HashMapReducer.h:32</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab8753a2df233c9b1327d5682940ddcbf_cgraph.svg" width="258" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adb0ded68a9723df3debe38af3634e139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0ded68a9723df3debe38af3634e139">&#9670;&nbsp;</a></span>mergeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReductionMsg * tk::mergeVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CkReductionMsg **&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ custom reducer for merging std::vectors during reduction across PEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmsg</td><td>Number of messages in msgs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgs</td><td>Charm++ reduction message containing the serialized vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated std::vectors built for further aggregation if needed </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_vector_reducer_8_c_source.html#l00044">44</a> of file <a class="el" href="_vector_reducer_8_c_source.html">VectorReducer.C</a>.</p>

<p class="reference">References <a class="el" href="_hash_map_reducer_8h_source.html#l00032">serialize()</a>, and <a class="el" href="_container_util_8h_source.html#l00025">unique()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_lin_sys_merger_8h_source.html#l00332">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::registerBCMerger()</a>, and <a class="el" href="_carrier_8h_source.html#l00167">inciter::Carrier::registerReducers()</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="comment">// Will store deserialized vector</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  std::vector&lt; std::size_t &gt; v;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// Create PUP deserializer based on message passed in</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  PUP::fromMem creator( msgs[0]-&gt;getData() );</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// Deserialize vector from raw stream</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  creator | v;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nmsg; ++m) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="comment">// Unpack vector</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::vector&lt; std::size_t &gt; u;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    PUP::fromMem curCreator( msgs[m]-&gt;getData() );</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    curCreator | u;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="comment">// Concatenate vector and make it unique</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    v.insert( end(v), begin(u), end(u) );</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a>( v );</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  }</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Serialize concatenated vectors to raw stream</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keyword">auto</span> stream = <a class="code" href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a>( v );</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// Forward serialized vector</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <span class="keywordflow">return</span> CkReductionMsg::buildNew( stream.first, stream.second.get() );</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00025">ContainerUtil.h:25</a></div></div>
<div class="ttc" id="namespacetk_html_a8a928cb4648630899f34ee7ad08fd754"><div class="ttname"><a href="namespacetk.html#a8a928cb4648630899f34ee7ad08fd754">tk::serialize</a></div><div class="ttdeci">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; serialize(const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="_hash_map_reducer_8h_source.html#l00032">HashMapReducer.h:32</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_adb0ded68a9723df3debe38af3634e139_cgraph.svg" width="274" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afd730d099e698f124362ef8c01483e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd730d099e698f124362ef8c01483e0f">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; tk::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator min between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object containing the minimum of all values for each value in <em>a</em> and <em>b</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties. </dd>
<dd>
As opposed to std::min, this function creates and returns a new object instead of returning a reference to the smaller one of the operands. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00561">561</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_data_8h_source.html#l00279">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00196">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00190">tk::Data&lt; Layout &gt;::nunk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00029">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00340">inciter::FluxCorrector::alw()</a>, <a class="el" href="_p_d_f_writer_8h_source.html#l00086">tk::PDFWriter::assertSampleSpaceExtents()</a>, <a class="el" href="_transport_8h_source.html#l00251">inciter::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_comp_flow_8h_source.html#l00255">inciter::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_timer_8_c_source.html#l00044">tk::Timer::eta()</a>, <a class="el" href="_p_d_f_writer_8_c_source.html#l01175">tk::PDFWriter::extents()</a>, <a class="el" href="_tracker_8_c_source.html#l00024">tk::Tracker::genpar()</a>, <a class="el" href="_diff_eq_2_init_policy_8h_source.html#l00118">walker::InitDelta::init()</a>, <a class="el" href="_diff_eq_2_init_policy_8h_source.html#l00161">walker::InitBeta::init()</a>, <a class="el" href="_transport_problem_8h_source.html#l00168">inciter::TransportProblemSlotCyl::init()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00391">inciter::FluxCorrector::lim()</a>, <a class="el" href="_tracker_8_c_source.html#l00109">tk::Tracker::parinel()</a>, and <a class="el" href="_p_d_f_writer_8_c_source.html#l00052">tk::PDFWriter::writeTxt()</a>.</p>
<div class="fragment"><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                                                                       {</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nunk() == b.nunk(), <span class="stringliteral">&quot;Number of unknowns unequal&quot;</span> );</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( a.nprop() == b.nprop(), <span class="stringliteral">&quot;Number of properties unequal&quot;</span> );</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  Data&lt; Layout &gt; r( a.nunk(), a.nprop() );</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  std::transform( a.data().cbegin(), a.data().cend(),</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                  b.data().cbegin(), r.data().begin(),</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                  []( <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> s, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d ){ <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">std::min</a>(s,d); } );</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;}</div><div class="ttc" id="namespacetk_html_afd730d099e698f124362ef8c01483e0f"><div class="ttname"><a href="namespacetk.html#afd730d099e698f124362ef8c01483e0f">tk::min</a></div><div class="ttdeci">Data&lt; Layout &gt; min(const Data&lt; Layout &gt; &amp;a, const Data&lt; Layout &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_data_8h_source.html#l00561">Data.h:561</a></div></div>
<div class="ttc" id="namespacetk_html_a1a96ada94b7e2911ecca0a360f305575"><div class="ttname"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a></div><div class="ttdeci">double real</div><div class="ttdoc">Real number type used throughout the whole code. </div><div class="ttdef"><b>Definition:</b> <a href="_base_2_types_8h_source.html#l00018">Types.h:18</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_afd730d099e698f124362ef8c01483e0f_cgraph.svg" width="240" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac38f5055c45cd35b8ce00151cea4c1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38f5055c45cd35b8ce00151cea4c1d3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator != between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries are unequal up to epsilon </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00616">616</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;{ <span class="keywordflow">return</span> !(lhs == rhs); }</div></div><!-- fragment -->
</div>
</div>
<a id="ad47c993218d9384828fcce2794850ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47c993218d9384828fcce2794850ac7">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T, Allocator &gt;&amp; tk::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all elements of a vector to another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>Destination vector, i.e., left-hand side of v1 += v2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source vector, i.e., righ-hand side of v1 += v2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destination containing v1[0] += v2[0], v1[1] += v2[1], ...</dd></dl>
<p>If src.size() &gt; dst.size() will grow dst to that of src.size() padding with zeros. </p><dl class="section note"><dt>Note</dt><dd>Will throw exception in DEBUG if src is empty (to warn on no-op), and if src.size() &lt; dst.size() (to warn on loosing data). </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00107">107</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;{</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( !src.empty(), <span class="stringliteral">&quot;src empty in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> );</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( src.size() &gt;= dst.size(), <span class="stringliteral">&quot;src.size() &lt; dst.size() would loose data &quot;</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          <span class="stringliteral">&quot;in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  dst.resize( src.size() );</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  std::transform( src.begin(), src.end(), dst.begin(), dst.begin(),</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                  []( <span class="keyword">const</span> T&amp; s, T&amp; d ){ <span class="keywordflow">return</span> d += s; } );</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="keywordflow">return</span> dst;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bbb9b08d37f6f5f3bed45effc8fc64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbb9b08d37f6f5f3bed45effc8fc64e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt;&amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for writing std::vector&lt; T &gt; to output streams; for debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>std::vector of arbitrary type T to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00039">39</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                                                       {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : t) os &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;&#39; s:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aabd06aee13370660ff0109b8f8b1958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd06aee13370660ff0109b8f8b1958e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt; &amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for writing enum class value to output streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of enum class to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream for chain-use of the operator </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi</dd></dl>
<p>Delegate operator &lt;&lt; to default for writing non-enums to output streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which t is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Value of arbitrary non-enum-class type to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated output stream for chain-use of the operator </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00026">26</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                                          {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  os &lt;&lt; static_cast&lt; unsigned int &gt;( e );</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa160d13ea2e4a3498916472c3b6cdbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160d13ea2e4a3498916472c3b6cdbb0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for lvalues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated string </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00051">51</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                                          {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  std::stringstream ss;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  ss &lt;&lt; lhs &lt;&lt; e;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  lhs = ss.str();</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="keywordflow">return</span> lhs;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7adfa2dfb8b3a38f60ac0edf5666b6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for rvalues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated string </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00065">65</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                           {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="keywordflow">return</span> lhs &lt;&lt; e;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac0a63cccd84b6bd8b998cb4282adac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a63cccd84b6bd8b998cb4282adac23">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::ostream&amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output univariate PDF to output stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>Stream to output to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>PDF to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated stream </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used for debugging. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_uni_p_d_f_8h_source.html#l00124">124</a> of file <a class="el" href="_uni_p_d_f_8h_source.html">UniPDF.h</a>.</p>

<p class="reference">References <a class="el" href="_uni_p_d_f_8h_source.html#l00085">tk::UniPDF::binsize()</a>, <a class="el" href="_uni_p_d_f_8h_source.html#l00081">tk::UniPDF::map()</a>, and <a class="el" href="_uni_p_d_f_8h_source.html#l00058">tk::UniPDF::nsample()</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                             {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  os &lt;&lt; p.<a class="code" href="classtk_1_1_uni_p_d_f.html#a83519a7b7b48c14694c5d683218d3419">binsize</a>() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; p.<a class="code" href="classtk_1_1_uni_p_d_f.html#af0075606b7c787a66c9fade95f22ecb6">nsample</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  std::map&lt; typename tk::UniPDF::key_type, tk::real &gt;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    sorted( p.<a class="code" href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">map</a>().begin(), p.<a class="code" href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">map</a>().end() );</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : sorted) os &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; b.first &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; b.second &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div><div class="ttc" id="classtk_1_1_uni_p_d_f_html_a83519a7b7b48c14694c5d683218d3419"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#a83519a7b7b48c14694c5d683218d3419">tk::UniPDF::binsize</a></div><div class="ttdeci">tk::real binsize() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00085">UniPDF.h:85</a></div></div>
<div class="ttc" id="classtk_1_1_uni_p_d_f_html_af0075606b7c787a66c9fade95f22ecb6"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#af0075606b7c787a66c9fade95f22ecb6">tk::UniPDF::nsample</a></div><div class="ttdeci">std::size_t nsample() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00058">UniPDF.h:58</a></div></div>
<div class="ttc" id="classtk_1_1_uni_p_d_f_html_ae3cc1ee45721ada30dcc808c227e179a"><div class="ttname"><a href="classtk_1_1_uni_p_d_f.html#ae3cc1ee45721ada30dcc808c227e179a">tk::UniPDF::map</a></div><div class="ttdeci">const map_type &amp; map() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="_uni_p_d_f_8h_source.html#l00081">UniPDF.h:81</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ac0a63cccd84b6bd8b998cb4282adac23_cgraph.svg" width="323" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a21669e4d06c62a58cd0f4bf63868ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21669e4d06c62a58cd0f4bf63868ab7e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t Layout&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tk::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_data.html">Data</a>&lt; Layout &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator == between two <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td><a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">Data</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries are equal up to epsilon </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00597">597</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_data_8h_source.html#l00279">tk::Data&lt; Layout &gt;::data()</a>, <a class="el" href="_data_8h_source.html#l00196">tk::Data&lt; Layout &gt;::nprop()</a>, and <a class="el" href="_data_8h_source.html#l00190">tk::Data&lt; Layout &gt;::nunk()</a>.</p>
<div class="fragment"><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                                                                         {</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( rhs.nunk() == lhs.nunk(), <span class="stringliteral">&quot;Incorrect number of unknowns&quot;</span> );</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( rhs.nprop() == lhs.nprop(), <span class="stringliteral">&quot;Incorrect number of properties&quot;</span> );</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;  <span class="keyword">auto</span> l = lhs.data().cbegin();</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;  <span class="keyword">auto</span> r = rhs.data().cbegin();</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  <span class="keywordflow">while</span> (l != lhs.data().cend()) {</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    <span class="keywordflow">if</span> (std::abs(*l - *r) &gt; std::numeric_limits&lt; tk::real &gt;::epsilon())</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;     <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    ++l; ++r;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  }</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a21669e4d06c62a58cd0f4bf63868ab7e_cgraph.svg" width="294" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a64b09f52ea3b4314e449e70255837836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b09f52ea3b4314e449e70255837836">&#9670;&nbsp;</a></span>pickOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a43d2f365ad601e02c8d64479adfd4a7f">MeshWriter</a> tk::pickOutput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine output mesh file type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to pick its type based on extension given </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum specifying the mesh writer type </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00066">66</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, and <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// Get extension of input file name</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  std::string fn = filename;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  std::string ext( fn.substr(fn.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1) );</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;msh&quot;</span> ) {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> MeshWriter::GMSH;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;exo&quot;</span> || ext == <span class="stringliteral">&quot;h5&quot;</span> ) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">return</span> MeshWriter::EXODUSII;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;mesh&quot;</span> ) {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">return</span> MeshWriter::NETGEN;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Output mesh file type could not be determined from extension of &quot;</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;           <span class="stringliteral">&quot;filename &#39;&quot;</span> + filename + <span class="stringliteral">&quot;&#39;; valid extensions are: &quot;</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;           <span class="stringliteral">&quot;&#39;msh&#39; for Gmsh, &#39;exo&#39; or &#39;h5&#39; for ExodusII, &#39;mesh&#39; for Netgen&#39;s &quot;</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;           <span class="stringliteral">&quot;neutral&quot;</span> );</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  }</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abcbeb1245c469101fb0f280aa51fe0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbeb1245c469101fb0f280aa51fe0c9">&#9670;&nbsp;</a></span>poinCommMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; tk::poinCommMaps </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>graphsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>toofine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute point-based communication maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graphsize</td><td>Size of unstructured mesh graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toofine</td><td>Error message to print triggered for too large overdecomposition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point-based communication map for all chares</dd></dl>
<p>This is a <em>point-based</em> export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns a mesh point. This is for algorithms that work by computing data on the mesh by looping over mesh points and their surrounding points, e.g., edge-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p><dl class="section note"><dt>Note</dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_comm_map_8_c_source.html#l00029">29</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_exception_8h_source.html#l00059">ErrChk</a>, <a class="el" href="_derived_data_8_c_source.html#l00026">genEsup()</a>, and <a class="el" href="_derived_data_8_c_source.html#l00110">genPsup()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// unique global point ids sent (export map)</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  std::map&lt; std::size_t,</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="comment">// Generate points surrounding points</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a>( tetinpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>(tetinpoel,4) );</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// Construct point-based export maps</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;graphsize; ++p)  <span class="comment">// for all mesh points</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i) {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      <span class="keyword">auto</span> q = psup.first[i];</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="keywordflow">if</span> (chp[p] != chp[q])   <span class="comment">// if the point-colors differ, store global id</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        comm[ chp[p] ][ chp[q] ].insert( p );</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">// This check should always be done, as it can result from incorrect user</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="comment">// input compared to the mesh size and not due to programmer error.</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <a class="code" href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f">ErrChk</a>( comm.size() == nchare, std::move(toofine) );</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="preprocessor">  #ifndef NDEBUG</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  std::size_t c = 0;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( e.first == c++,</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="stringliteral">&quot;Export/import maps should not be missing for chare id &quot;</span> +</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            std::to_string(c-1) );</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="comment">// Construct final product: a vector of export maps associating receiver</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    pcomm( nchare );</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        pcomm[ e.first ][ x.first ].push_back( p );</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( pcomm.size() == nchare,</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          <span class="stringliteral">&quot;Number of export/import maps must equal the number of chares&quot;</span> );</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">//   std::size_t h = 0;</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">//   for (const auto&amp; m : pcomm) {</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; p-&gt; &quot;;</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">//     for (const auto&amp; x : m) {</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">//       for (auto p : x.second)</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">//     }</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="keywordflow">return</span> pcomm;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div><div class="ttc" id="namespacetk_html_ad2a88a65102c17149b44660db15d445b"><div class="ttname"><a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genPsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</div><div class="ttdoc">Generate derived data structure, points surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00110">DerivedData.C:110</a></div></div>
<div class="ttc" id="_exception_8h_html_ac75cd6578896829d2bfbccf5de71de4f"><div class="ttname"><a href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f">ErrChk</a></div><div class="ttdeci">#define ErrChk(expr,...)</div><div class="ttdoc">ErrChk macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00059">Exception.h:59</a></div></div>
<div class="ttc" id="namespacetk_html_a66a2889d5d8aeb4a836842c6a1010463"><div class="ttname"><a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genEsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</div><div class="ttdoc">Generate derived data structure, elements surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00026">DerivedData.C:26</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_abcbeb1245c469101fb0f280aa51fe0c9_cgraph.svg" width="296" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af04df49334286e653e440035c499a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04df49334286e653e440035c499a8d1">&#9670;&nbsp;</a></span>processExceptionCharm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::processExceptionCharm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an exception from the Charm++ runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p><dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00031">31</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8_c_source.html#l00178">tk::Exception::handleException()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_inciter_8_c_source.html#l00164">Main::execute()</a>, <a class="el" href="_inciter_8_c_source.html#l00172">Main::finalize()</a>, <a class="el" href="_inciter_8_c_source.html#l00134">Main::Main()</a>, and <a class="el" href="_mesh_conv_8_c_source.html#l00111">Main::timestamp()</a>.</p>
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;{</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="keywordflow">try</span> {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  }</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="comment">// Catch tk::Exception</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html">tk::Exception</a>&amp; qe ) {</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  }</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="comment">// file:line:func information</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( se.what() );</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">// Catch uncaught exception</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="comment">// Tell the runtime system to exit with a message</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  CkAbort( <span class="stringliteral">&quot;Exception caught&quot;</span> );</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;}</div><div class="ttc" id="classtk_1_1_exception_html"><div class="ttname"><a href="classtk_1_1_exception.html">tk::Exception</a></div><div class="ttdoc">Basic exception class for producing file:func:line info + call trace. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00073">Exception.h:73</a></div></div>
<div class="ttc" id="classtk_1_1_exception_html_aef3989f5d076c0282329daa2a646b1c6"><div class="ttname"><a href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">tk::Exception::handleException</a></div><div class="ttdeci">virtual ErrCode handleException() noexcept</div><div class="ttdoc">Handle Exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8_c_source.html#l00178">Exception.C:178</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_af04df49334286e653e440035c499a8d1_cgraph.svg" width="100%" height="364"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a2a62b5b6880fbd0a011cedf8896b19dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a62b5b6880fbd0a011cedf8896b19dc">&#9670;&nbsp;</a></span>processExceptionMPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::processExceptionMPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an exception from the MPI runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p><dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_process_exception_8_c_source.html#l00063">63</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00064">FAILURE</a>, and <a class="el" href="_exception_8_c_source.html#l00178">tk::Exception::handleException()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_unit_test_8_c_source.html#l00283">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;{</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordtype">int</span> peid;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic push</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  MPI_Comm_rank( MPI_COMM_WORLD, &amp;peid );  </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic pop</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="keywordflow">try</span> {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  }</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="comment">// Catch tk::Exception</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html">tk::Exception</a>&amp; qe ) {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">// file:line:func information</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( se.what() );</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  }</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// Catch uncaught exception</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="keywordflow">catch</span> (...) {</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <a class="code" href="classtk_1_1_exception.html">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">handleException</a>();</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic push</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="comment">// Tell the runtime system to exit with error code</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  MPI_Abort( MPI_COMM_WORLD, <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::ErrCode::FAILURE</a> );</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor">  #if defined(__clang__)</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="preprocessor">    #pragma GCC diagnostic pop</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div><div class="ttc" id="classtk_1_1_exception_html"><div class="ttname"><a href="classtk_1_1_exception.html">tk::Exception</a></div><div class="ttdoc">Basic exception class for producing file:func:line info + call trace. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00073">Exception.h:73</a></div></div>
<div class="ttc" id="classtk_1_1_exception_html_aef3989f5d076c0282329daa2a646b1c6"><div class="ttname"><a href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6">tk::Exception::handleException</a></div><div class="ttdeci">virtual ErrCode handleException() noexcept</div><div class="ttdoc">Handle Exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8_c_source.html#l00178">Exception.C:178</a></div></div>
<div class="ttc" id="namespacetk_html_afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"><div class="ttname"><a href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">tk::FAILURE</a></div><div class="ttdoc">Exceptions occurred. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00064">Exception.h:64</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a2a62b5b6880fbd0a011cedf8896b19dc_cgraph.svg" width="100%" height="364"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="af947865970b76333655208aea71ceb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af947865970b76333655208aea71ceb71">&#9670;&nbsp;</a></span>readUnsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> tk::readUnsMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unstructured mesh from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to read mesh from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>A time stamp consisting of a timer label (a string), and a time state (a <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" title="Real number type used throughout the whole code. ">tk::real</a> in seconds) measuring the mesh read time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unstructured mesh object </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>
<p>Create unstructured mesh to store mesh </p>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00093">93</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="_mesh_factory_8_c_source.html#l00032">detectInput()</a>, <a class="el" href="_print_8h_source.html#l00315">tk::Print::diagend()</a>, <a class="el" href="_print_8h_source.html#l00308">tk::Print::diagstart()</a>, <a class="el" href="_timer_8h_source.html#l00065">tk::Timer::dsec()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">tut::ExodusIIMeshReader()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30af6a18d9bcecb96fcd432686203acbb02">HYPERMESH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00027">tk::NetgenMeshReader::readMesh()</a>, <a class="el" href="_hyper_mesh_reader_8_c_source.html#l00026">tk::HyperMeshReader::readMesh()</a>, and <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00030">tk::GmshMeshReader::readMesh()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00046">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;{</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Reading mesh from file ...&quot;</span> );</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="comment">// Read in mesh</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160; <span class="comment"></span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">  //! Create unstructured mesh to store mesh</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"></span>  UnsMesh mesh;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">detectInput</a>( filename );</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">if</span> (meshtype == MeshReader::GMSH)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    GmshMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::NETGEN)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    NetgenMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::EXODUSII)</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <a class="code" href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">ExodusIIMeshReader</a>( filename ).readMesh( mesh );</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshReader::HYPERMESH)</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    HyperMeshReader( filename ).readMesh( mesh );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  timestamp = std::make_pair( <span class="stringliteral">&quot;Read mesh from file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="comment">// Return (move out) mesh object</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="keywordflow">return</span> mesh;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div><div class="ttc" id="classtk_1_1_timer_html"><div class="ttname"><a href="classtk_1_1_timer.html">tk::Timer</a></div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00030">Timer.h:30</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a569d68d17038fa38b83d5bb229500c40"><div class="ttname"><a href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">tk::Timer::dsec</a></div><div class="ttdeci">real dsec() const</div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00065">Timer.h:65</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_a9a3bb2dc7c5ea1d979dcec5528c37a66"><div class="ttname"><a href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">tk::Print::diagend</a></div><div class="ttdeci">void diagend(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00315">Print.h:315</a></div></div>
<div class="ttc" id="namespacetut_html_a88f40e8bb56ea7c640a69bb6a75fa769"><div class="ttname"><a href="namespacetut.html#a88f40e8bb56ea7c640a69bb6a75fa769">tut::ExodusIIMeshReader</a></div><div class="ttdeci">static ExodusIIMeshReader_group ExodusIIMeshReader(&quot;IO/ExodusIIMeshReader&quot;)</div><div class="ttdoc">Define test group. </div></div>
<div class="ttc" id="classtk_1_1_print_html_ae1f93831127fb7d45c33ad3cdf3604fd"><div class="ttname"><a href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">tk::Print::diagstart</a></div><div class="ttdeci">void diagstart(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00308">Print.h:308</a></div></div>
<div class="ttc" id="namespacetk_html_a08e7ddf794b944c7d2095c1222f4244a"><div class="ttname"><a href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">tk::detectInput</a></div><div class="ttdeci">MeshReader detectInput(const std::string &amp;filename)</div><div class="ttdoc">Detect input mesh file type. </div><div class="ttdef"><b>Definition:</b> <a href="_mesh_factory_8_c_source.html#l00032">MeshFactory.C:32</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_af947865970b76333655208aea71ceb71_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ad986ef5558d44d5e0c6650c589499980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad986ef5558d44d5e0c6650c589499980">&#9670;&nbsp;</a></span>record()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::record </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstructorArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register class into factory with given key. This is used to register a derived-class object's constructor (deriving from some base class) to a factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;, i.e., an associative container, associating some key to a std::function object holding a pointer of Child's base class constructor. The constructor and its bound arguments are stored via boost::factory, which, in this use-case, yields the correct function object of type Base constructor pointer and thus facilitates runtime polymorphism. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using reference semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by function instantiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00050">50</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                                                                     {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  f.emplace( key,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;             std::bind( boost::factory&lt; C* &gt;(),</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                        std::forward&lt; ConstructorArgs &gt;( args )... ) );</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ad986ef5558d44d5e0c6650c589499980_cgraph.svg" width="235" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4bd6374b4792dbd3c626dad60bcef168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6374b4792dbd3c626dad60bcef168">&#9670;&nbsp;</a></span>recordCharmModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordCharmModel </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register Charm++ model class of host into factory with given key. We bind a host constructor to its arguments of which the first one is a std::function holding a model constructor type (modeling, i.e., used polymorhically with host), followed by an optional number of others (possibly zero) with arbitrary types. Note that the model constructor is a nullptr (default- constructed) and only used to forward its type to the call site inside std::function. The host constructor function is then placed into the factory. This is because Charm++ chares do not explicitly invoke constructors, only call ckNew() on their proxy, which requires all constructor arguments to be present and forwarded to the actual constructor that is only called at a later point in time. This can then be used by those constructors of hosts that invoke the model constructors' proxies' ckNew() and ignore the std::function. See, e.g., <a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery()</a> and the associated unit tests in UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00184">184</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                                                               {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(),</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                             std::function&lt; ModelConstructor() &gt;(), <span class="comment">// nullptr</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                             std::forward&lt; ModelConstrArgs &gt;( args )...) );</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a24170c3146caaa7b79d78d4aa1d98f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24170c3146caaa7b79d78d4aa1d98f66">&#9670;&nbsp;</a></span>recordModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordModel </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register "model" class of "host" into factory with given key. This wrapper can be used to in a similar manner to 'record', but uses boost::value_factory to bind the model object constructor to its arguments and place it in the associative container storing host class objects. The container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e., associating a key to a function holding a constructor (and not its pointer). Runtime polymorphism here is realized entirely within the "base" class. See <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation. ">walker::DiffEq</a> in <a class="el" href="_diff_eq_2_diff_eq_8h.html" title="Differential equation. ">DiffEq/DiffEq.h</a> for an example and more information on runtime polymorphism without client-side inheritance. As a result, this wrapper works with factories that use value semantics, as opposed to 'record' and instantiate which work with reference semantics factories. In order to differentiate between runtime polymorphic classes using reference semantics, consistent with classes realizing runtime polymorphism without client-side inheritance, we call Host as the "Base" class and Model as the "derived" (or child) class. This wrapper function works in conjunction with boost::value_factory, i.e., uses value semantics (works with storing objects instead of object pointers). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using value semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by simply calling the function call operator () on the mapped value. For an example, <a class="el" href="classtk_1_1_r_n_g_stack.html#ab1c30742819f7c22826dcce8c620539f" title="Instantiate selected RNGs. ">RNGStack::selected()</a> in <a class="el" href="_r_n_g_stack_8_c.html" title="Stack of random number generators. ">RNG/RNGStack.C</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00113">113</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_r_n_g_stack_8_c_source.html#l00084">tk::RNGStack::selected()</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                                                                          {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="comment">// Bind model constructor to its arguments</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  std::function&lt; ModelConstructor() &gt; c =</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    std::bind( boost::value_factory&lt; ModelConstructor &gt;(),</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;               std::forward&lt; ModelConstrArgs &gt;( args )... );</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// Bind host to std::function of model constructor and place in factory</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(), std::move(c) ) );</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a24170c3146caaa7b79d78d4aa1d98f66_cgraph.svg" width="272" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae98b4e55f14339c707622a8da43d8ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98b4e55f14339c707622a8da43d8ce9">&#9670;&nbsp;</a></span>recordModelLate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::recordModelLate </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArg&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register model class of host into factory with given key using late binding. This variant of 'record' is very similar to 'recordModel', but registers a model class constructor to a factory with late binding of the constructor argument. Late binding allows specifying the constructor argument at the time when the object is instantiated instead of at the time when it is registered. This has all the benefits of using a factory and allows passing information into the model object only when it is available. The late bind is facilitated via boost::bind instead of std::bind using a placeholder, _1, which stands for the first argument (bound later, i.e., not here). The value of the model constructor argument is then not used here, only its type, used to perform the late binding. The binding happens to both the model constructor via std::function (passed to the host constructor) as well as explicitly to the host constructor. Prescribing late binding to the model constructor ensures that the compiler requires the argument to the model constructor, i.e., ensures that the host constructor is required to pass the argument to the model constructor. Prescribing late binding to the host constructor puts in the actual request that an argument (with the correct type) must be passed to the host constructor at instantiate time, which then will forward it to the model constructor. See also, for example, <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation. ">walker::DiffEq</a>'s corresponding constructor. An example of client-side code is in <a class="el" href="structwalker_1_1_diff_eq_stack_1_1register_diff_eq.html" title="Function object for registering a differential equation into the differential equation factory...">walker::DiffEqStack::registerDiffEq</a> for registration into factory, and DiffEqStack::createDiffEq for instantiation late-passing the argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only works with a single constructor argument </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_factory_8h_source.html#l00151">151</a> of file <a class="el" href="_base_2_factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">References <a class="el" href="namespacetut.html#aee6d9f355bfc979bac6fea8bf2649ee8">tut::Factory()</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                                                   {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="comment">// Prescribe late binding the model constructor to its single argument</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  std::function&lt; ModelConstructor(const ModelConstrArg&amp;) &gt; c =</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    boost::bind( boost::value_factory&lt; ModelConstructor &gt;(), boost::arg&lt;1&gt;() );</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="comment">// Bind host to std::function of model constructor and place in factory and</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="comment">// also explicitly bind single model constructor argument to host constructor</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  f.emplace( key,</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    boost::bind( boost::value_factory&lt; Host &gt;(), std::move(c), boost::arg&lt;1&gt;() )</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  );</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ae98b4e55f14339c707622a8da43d8ce9_cgraph.svg" width="299" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab2aac5f0fd93d5119cfe50a39f3515c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aac5f0fd93d5119cfe50a39f3515c9">&#9670;&nbsp;</a></span>ref_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tk::ref_find </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Container::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename Container::mapped_type&amp;



</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00056">56</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_container_util_8h_source.html#l00040">cref_find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_lin_sys_merger_8h_source.html#l01125">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::auxsolve()</a>, <a class="el" href="_test_timer_8h_source.html#l00162">tut::CharmTimer::CharmTimer()</a>, <a class="el" href="_lin_sys_merger_8h_source.html#l00953">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::lhsbc()</a>, <a class="el" href="_partitioner_8h_source.html#l00339">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::mask()</a>, and <a class="el" href="_lin_sys_merger_8h_source.html#l00977">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::rhsbc()</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;{</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> typename Container::mapped_type&amp; <span class="keyword">&gt;</span>( <a class="code" href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">cref_find</a>(map,key) );</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div><div class="ttc" id="namespacetk_html_a2e002561a68875b091a264eb2a1e5f6c"><div class="ttname"><a href="namespacetk.html#a2e002561a68875b091a264eb2a1e5f6c">tk::cref_find</a></div><div class="ttdeci">auto cref_find(const Container &amp;map, const typename Container::key_type &amp;key) -&gt; const typename Container::mapped_type &amp;</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00040">ContainerUtil.h:40</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab2aac5f0fd93d5119cfe50a39f3515c9_cgraph.svg" width="242" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5ac2475f6c08b5fcb81392b14aad73a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac2475f6c08b5fcb81392b14aad73a4">&#9670;&nbsp;</a></span>remap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::remap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder mesh point ids in a vector given a new order, i.e., index map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">id</td><td>Vector of point ids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newid</td><td>Array of indices creating a new order</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements a simple reordering (or remapping) of the node ids of the vector passed in using the vector newid. Thus the vector in newid is thought of as a mapping between the array index to its value. The function overwrites every value, n, of vector id with newid[n]. </p><dl class="section note"><dt>Note</dt><dd>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00050">50</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.empty() || newid.empty()) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( *max_element( begin(<span class="keywordtype">id</span>), end(<span class="keywordtype">id</span>) ) &lt; newid.size(),</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;          <span class="stringliteral">&quot;attempt to index out of node id bounds using newid&quot;</span> );</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="comment">// remap node ids in vector id</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; n : <span class="keywordtype">id</span>) n = newid[n];</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d0312d71017d8ffd9f11811a46e5a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0312d71017d8ffd9f11811a46e5a16">&#9670;&nbsp;</a></span>renumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; tk::renumber </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder mesh points with the advancing front technique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psup</td><td>Points surrounding points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of maps between old-&gt;new and new-&gt;old order </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00074">74</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00134">writeUnsMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// Find out number of nodes in graph</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="keyword">auto</span> npoin = psup.second.size()-1;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="comment">// Construct mapping using advancing front</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  std::vector&lt; int &gt; hpoin( npoin, -1 ), lpoin( npoin, 0 );</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  std::vector&lt; std::size_t &gt; mapvec( npoin, 0 );</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  hpoin[0] = 0;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  lpoin[0] = 1;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  std::size_t num = 1;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="keywordflow">while</span> (num &lt; npoin) {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    std::size_t cnt = 0;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    std::size_t i = 0;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    std::vector&lt; int &gt; kpoin( npoin, -1 );</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordtype">int</span> p;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">while</span> ((p = hpoin[i]) != -1) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      ++i;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      <span class="keyword">auto</span> P = <span class="keyword">static_cast&lt;</span> std::size_t <span class="keyword">&gt;</span>( p );</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=psup.second[P]+1; j&lt;=psup.second[P+1]; ++j) {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keyword">auto</span> q = psup.first[j];</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">if</span> (lpoin[q] != 1) {    <span class="comment">// consider points not yet counted</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;          mapvec[q] = num++;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;          kpoin[cnt] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>( q ); <span class="comment">// register point as counted</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;          lpoin[q] = 1;                         <span class="comment">// register the point as counted</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;          ++cnt;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    hpoin = kpoin;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Construct new-&gt;old id map</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  std::size_t i = 0;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  std::vector&lt; std::size_t &gt; oldmap( npoin );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : mapvec) oldmap[n] = i++;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// Return old-&gt;new and new-&gt;old maps</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="keywordflow">return</span> { mapvec, oldmap };</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4d5bfee8e8bdea2bc60e5d725672af09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5bfee8e8bdea2bc60e5d725672af09">&#9670;&nbsp;</a></span>rm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::rm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove file from file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name to delete (shell wildcards NOT expanded)</td></tr>
  </table>
  </dd>
</dl>
<p>Since we use pstream's basic_ipstream constructor with signature ( const std::string &amp; file, const argv_type &amp; argv, pmode mode = pstdout ) and the file argument doesn't contain a slash, the actions of the shell are duplicated in searching for an executable in PATH. The shell will not interpret the other arguments, so wildcard expansion will not take place. </p><dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_process_control_8_c_source.html#l00034">34</a> of file <a class="el" href="_process_control_8_c_source.html">ProcessControl.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_test_mesh_8h_source.html#l00036">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                 {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  std::vector&lt; std::string &gt; argv;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  argv.push_back( <span class="stringliteral">&quot;rm&quot;</span> );</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  argv.push_back( file );</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  redi::ipstream in( <span class="stringliteral">&quot;rm&quot;</span>, argv, redi::pstreambuf::pstderr );</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  std::string e;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  std::string error;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keywordflow">while</span> ( std::getline( in, e ) ) error += e + <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="keywordflow">if</span> (!error.empty()) <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( std::move(error) );</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28a553d30e4fd16f06342dd643d26c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a553d30e4fd16f06342dd643d26c25">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> tk::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021">tk::Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample a discrete y = f(x) function at x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Value of abscissa at which to sample y = f(x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td><a class="el" href="namespacetk.html#a4a3683fffc858642385d1292c3817021" title="Type alias for declaring, defining, and storing a discrete y = f(x) function. ">tk::Table</a> to sample</td></tr>
  </table>
  </dd>
</dl>
<p>If x is lower than the first x value in the function table, the first function value is returned. If x is larger than the last x value in the function table, the last function value is returned. In other words, no extrapolation is performed. If x falls between the first/lowest and the last/largest value in the table, linear interpolation is used to compute a sample between the two closest x values of the table around the abscissa given. </p><dl class="section return"><dt>Returns</dt><dd>Sampled value from discrete table </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The x column in the table is assumed to be in increasing order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewalker.html#ac381e784e9a620a33f67921a2068146e" title="Inverse equilibrium hydrodynamics time scale from DNS of homogeneous Rayleigh-Taylor instability...">walker::invhts_eq_A005H</a>, <a class="el" href="namespacewalker.html#ae994182cfb7ee4ba2c578217620016ed" title="Hydrodynamics (turbulent kinetic energy) production divided by the dissipatation rate evolution from ...">walker::prod_A005H</a> for example tables </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_table_8_c_source.html#l00020">20</a> of file <a class="el" href="_table_8_c_source.html">Table.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00619">walker::MixMassFracBetaCoeffHydroTimeScaleHomDecay::hydroproduction()</a>, <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00612">walker::MixMassFracBetaCoeffHydroTimeScaleHomDecay::hydrotimescale()</a>, and <a class="el" href="_distributor_8_c_source.html#l00324">walker::Distributor::outStat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">if</span> (x &lt; table.front().first) <span class="keywordflow">return</span> table.front().second;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;table.size()-1; ++i) {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">if</span> (table[i].first &lt; x &amp;&amp; x &lt; table[i+1].first) {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      <span class="keyword">auto</span> t1 = table[i].first;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="keyword">auto</span> y1 = table[i].second;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      <span class="keyword">auto</span> t2 = table[i+1].first;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      <span class="keyword">auto</span> y2 = table[i+1].second;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;      <span class="keywordflow">return</span> y1 + (y2-y1)/(t2-t1)*(x-t1);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    }</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="keywordflow">return</span> table.back().second;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a95434266ed0be6503251e90e0fe60823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95434266ed0be6503251e90e0fe60823">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_uni_p_d_f.html">tk::UniPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_bi_p_d_f.html">tk::BiPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtk_1_1_tri_p_d_f.html">tk::TriPDF</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize vectors of PDFs to raw memory stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Vector of univariate PDFs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Vector of bivariate PDFs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Vector of trivariate PDFs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized PDFs </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_p_d_f_reducer_8_c_source.html#l00018">18</a> of file <a class="el" href="_p_d_f_reducer_8_c_source.html">PDFReducer.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;{</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <span class="comment">// Prepare for serializing PDFs to a raw binary stream, compute size</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::BiPDF &gt;&amp; <span class="keyword">&gt;</span>( b );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::TriPDF &gt;&amp; <span class="keyword">&gt;</span>( t );</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// Create raw character stream to store the serialized PDFs</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// Serialize PDFs, each message will contain a vector of PDFs</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::UniPDF &gt;&amp; <span class="keyword">&gt;</span>( u );</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::BiPDF &gt;&amp; <span class="keyword">&gt;</span>( b );</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; tk::TriPDF &gt;&amp; <span class="keyword">&gt;</span>( t );</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab33ea32478ab229dc49f14585c74fec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33ea32478ab229dc49f14585c74fec2">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt; char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize std::vector to raw memory stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized vectors </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_vector_reducer_8_c_source.html#l00019">19</a> of file <a class="el" href="_vector_reducer_8_c_source.html">VectorReducer.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="comment">// Prepare for serializing vectors to a raw binary stream, compute size</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::vector&lt; std::size_t &gt;&amp; <span class="keyword">&gt;</span>( v );</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="comment">// Create raw character stream to store the serialized vectors</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="comment">// Serialize vector, each message will contain a vector</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::vector&lt; std::size_t &gt;&amp; <span class="keyword">&gt;</span>( v );</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8a928cb4648630899f34ee7ad08fd754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a928cb4648630899f34ee7ad08fd754">&#9670;&nbsp;</a></span>serialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt; Key &gt;, class KeyEqual  = std::equal_to&lt; Key &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::unique_ptr&lt;char[]&gt; &gt; tk::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; Key, T, Hash, KeyEqual &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize std::unordered_map to raw memory stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Hash map to serialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the length and the raw stream containing the serialized map </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_hash_map_reducer_8h_source.html#l00032">32</a> of file <a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_lin_sys_merger_8h_source.html#l00679">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::charebc()</a>, <a class="el" href="_collector_8_c_source.html#l00143">walker::Collector::chareCenPDF()</a>, <a class="el" href="_collector_8_c_source.html#l00094">walker::Collector::chareOrdPDF()</a>, <a class="el" href="_hash_map_reducer_8h_source.html#l00065">mergeHashMap()</a>, <a class="el" href="_p_d_f_reducer_8_c_source.html#l00050">mergePDF()</a>, and <a class="el" href="_vector_reducer_8_c_source.html#l00044">mergeVector()</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                                                 {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   <span class="comment">// Prepare for serializing map to a raw binary stream, compute size</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  PUP::sizer sizer;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  sizer | <span class="keyword">const_cast&lt;</span> std::unordered_map&lt; Key, T, Hash, KeyEqual &gt;&amp; <span class="keyword">&gt;</span>( m );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="comment">// Create raw character stream to store the serialized map</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  std::unique_ptr&lt;char[]&gt; flatData = tk::make_unique&lt;char[]&gt;( sizer.size() );</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// Serialize map, each message will contain a map</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  PUP::toMem packer( flatData.get() );</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  packer | <span class="keyword">const_cast&lt;</span> std::unordered_map&lt; Key, T, Hash, KeyEqual &gt;&amp; <span class="keyword">&gt;</span>( m );</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="comment">// Return size of and raw stream</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="keywordflow">return</span> { sizer.size(), std::move(flatData) };</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a293dd6fafcc3b8f4b28bef4f3ef050e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1">&#9670;&nbsp;</a></span>shiftToZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::shiftToZero </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift node IDs to start with zero in element connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount shifted</dd></dl>
<p>This function implements a simple reordering of the node ids of the element connectivity in inpoel by shifting the node ids so that the smallest is zero. </p><dl class="section note"><dt>Note</dt><dd>It is okay to call this function with an empty container; it will simply return without throwing an exception. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_reorder_8_c_source.html#l00025">25</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00228">tk::ExodusIIMeshReader::readAllElements()</a>, <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00067">tk::NetgenMeshReader::readElements()</a>, <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00148">tk::GmshMeshReader::readElements()</a>, and <a class="el" href="_test_mesh_8h_source.html#l00036">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">if</span> (inpoel.empty()) <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// find smallest node id</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keyword">auto</span> minId = *std::min_element( begin(inpoel), end(inpoel) );</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="comment">// shift node ids to start from zero</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; n : inpoel) n -= minId;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">return</span> minId;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a20ee8c554da198c14efbb80a0b623a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ee8c554da198c14efbb80a0b623a4a">&#9670;&nbsp;</a></span>SiloError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tk::SiloError </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Silo error handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Error message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_silo_writer_8_c_source.html#l00024">24</a> of file <a class="el" href="_silo_writer_8_c_source.html">SiloWriter.C</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_silo_writer_8_c_source.html#l00043">tk::SiloWriter::SiloWriter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;{</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <span class="comment">// Take out newlines from error message coming from library</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  std::string str(msg);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  std::replace(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39; &#39;</span>);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="comment">// Echo and throw</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  std::stringstream ss;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  ss &lt;&lt; <span class="stringliteral">&quot;Silo library writer error: &quot;</span> &lt;&lt; str;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( ss.str() );</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f319a47a6a5b983e161aa5f4d8f7b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c">&#9670;&nbsp;</a></span>sumsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tk::sumsize </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the sizes of a container of containers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Container of containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the sizes of the containers of the container </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00161">161</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00279">tk::ExodusIIMeshReader::readElements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                        {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  std::size_t sum = 0;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : c) sum += s.size();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="keywordflow">return</span> sum;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae5b04b00aa51667b944b7188545ec5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b04b00aa51667b944b7188545ec5ae">&#9670;&nbsp;</a></span>triple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tk::triple </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the triple-product of three vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v3</td><td>3rd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Triple-product </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_base_2_vector_8h_source.html#l00067">67</a> of file <a class="el" href="_base_2_vector_8h_source.html">Vector.h</a>.</p>

<p class="reference">References <a class="el" href="_base_2_vector_8h_source.html#l00020">cross()</a>, and <a class="el" href="_base_2_vector_8h_source.html#l00053">dot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_flux_corrector_8_c_source.html#l00029">inciter::FluxCorrector::aec()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00282">inciter::FluxCorrector::diff()</a>, <a class="el" href="_transport_8h_source.html#l00251">inciter::Transport&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_comp_flow_8h_source.html#l00255">inciter::CompFlow&lt; Physics, Problem &gt;::dt()</a>, <a class="el" href="_comp_flow_8h_source.html#l00080">inciter::CompFlow&lt; Physics, Problem &gt;::lhs()</a>, <a class="el" href="_transport_8h_source.html#l00091">inciter::Transport&lt; Physics, Problem &gt;::lhs()</a>, <a class="el" href="_flux_corrector_8_c_source.html#l00239">inciter::FluxCorrector::lump()</a>, <a class="el" href="_comp_flow_8h_source.html#l00160">inciter::CompFlow&lt; Physics, Problem &gt;::rhs()</a>, <a class="el" href="_transport_8h_source.html#l00171">inciter::Transport&lt; Physics, Problem &gt;::rhs()</a>, and <a class="el" href="_carrier_8_c_source.html#l00149">inciter::Carrier::vol()</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a>( v1, <a class="code" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a>(v2,v3) );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div><div class="ttc" id="namespacetk_html_ab602857e33f89cab4cc3788576ab1519"><div class="ttname"><a href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">tk::cross</a></div><div class="ttdeci">std::array&lt; T, 3 &gt; cross(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00020">Vector.h:20</a></div></div>
<div class="ttc" id="namespacetk_html_aeaca2df70ee950c576f6d74e1eb42caa"><div class="ttname"><a href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">tk::dot</a></div><div class="ttdeci">T dot(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</div><div class="ttdef"><b>Definition:</b> <a href="_base_2_vector_8h_source.html#l00053">Vector.h:53</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ae5b04b00aa51667b944b7188545ec5ae_cgraph.svg" width="210" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a87af1b002bc711716bd170a714bda211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87af1b002bc711716bd170a714bda211">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tk::unique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make elements of container unique </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_container_util_8h_source.html#l00025">25</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_carrier_8_c_source.html#l00062">inciter::Carrier::Carrier()</a>, <a class="el" href="_partitioner_8h_source.html#l00514">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::computeCentroids()</a>, <a class="el" href="_partitioner_8h_source.html#l00256">inciter::Partitioner&lt; HostProxy, WorkerProxy, LinSysMergerProxy, ParticleWriterProxy &gt;::flatten()</a>, <a class="el" href="_reorder_8_c_source.html#l00140">global2local()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00196">tk::UnsMesh::graphsize()</a>, <a class="el" href="_walker_2_input_deck_2_parser_8_c_source.html#l00036">walker::InputDeckParser::InputDeckParser()</a>, <a class="el" href="_vector_reducer_8_c_source.html#l00044">mergeVector()</a>, <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00392">tk::ExodusIIMeshReader::readSidesets()</a>, <a class="el" href="_print_8h_source.html#l00705">tk::Print::splitLines()</a>, <a class="el" href="_inciter_print_8h_source.html#l00080">inciter::InciterPrint::Policies::unique()</a>, and <a class="el" href="_walker_print_8h_source.html#l00126">walker::WalkerPrint::Policies::unique()</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  std::sort( begin(c), end(c) );</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="keyword">auto</span> it = <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">std::unique</a>( begin(c), end(c) );</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="keyword">auto</span> d = std::distance( begin(c), it );</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a>( d &gt;= 0, <span class="stringliteral">&quot;Distance must be non-negative in tk::unique()&quot;</span> );</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  c.resize( static_cast&lt; std::size_t &gt;( d ) );</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div><div class="ttc" id="namespacetk_html_a87af1b002bc711716bd170a714bda211"><div class="ttname"><a href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a></div><div class="ttdeci">void unique(Container &amp;c)</div><div class="ttdef"><b>Definition:</b> <a href="_container_util_8h_source.html#l00025">ContainerUtil.h:25</a></div></div>
<div class="ttc" id="_exception_8h_html_a6e509ba096551a0924ec024afadba810"><div class="ttname"><a href="_exception_8h.html#a6e509ba096551a0924ec024afadba810">Assert</a></div><div class="ttdeci">#define Assert(expr,...)</div><div class="ttdoc">Assert macro that only throws an exception if expr fails. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00049">Exception.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d61711de49d010da4785f7cb6ad2d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d61711de49d010da4785f7cb6ad2d9b">&#9670;&nbsp;</a></span>waitfor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Msg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a> tk::waitfor </td>
          <td>(</td>
          <td class="paramtype">const CkFuture &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for and return future. Concept: <a class="el" href="structtk_1_1_msg.html">Msg</a> must have public function get() returning <a class="el" href="structtk_1_1_msg.html#a40b53ee92944eb25a8236db8b07a2c41">Msg::value_type</a>. </p><dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00114">114</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p class="reference">References <a class="el" href="_msg_8h_source.html#l00052">tk::Msg&lt; T &gt;::get()</a>, and <a class="el" href="_msg_8h_source.html#l00054">tk::Msg&lt; T &gt;::value</a>.</p>
<div class="fragment"><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                                                    {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  Msg* m = <span class="keyword">static_cast&lt;</span> Msg* <span class="keyword">&gt;</span>( CkWaitFuture( f ) );</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keyword">typename</span> Msg::value_type value( m-&gt;get() );</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="keyword">delete</span> m;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keywordflow">return</span> value;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5d61711de49d010da4785f7cb6ad2d9b_cgraph.svg" width="239" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8e567fa9a72a1d5d02cea9eb020b192a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e567fa9a72a1d5d02cea9eb020b192a">&#9670;&nbsp;</a></span>workdir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tk::workdir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for POSIX API's getcwd() from unistd.h. </p>
<dl class="section return"><dt>Returns</dt><dd>A stirng containing the current working directory </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_init_8h_source.html#l00037">37</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p class="reference">References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p class="reference">Referenced by <a class="el" href="_init_8h_source.html#l00134">echoRunEnv()</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="keywordtype">char</span> cwd[1024];</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordflow">if</span> ( getcwd(cwd, <span class="keyword">sizeof</span>(cwd)) != NULL )</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> std::string( cwd );</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a>( <span class="stringliteral">&quot;Error from POSIX API&#39;s getcwd()&quot;</span> );</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;}</div><div class="ttc" id="_exception_8h_html_a0412f798470c18f503a2c2f63c970ba8"><div class="ttname"><a href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8">Throw</a></div><div class="ttdeci">#define Throw(...)</div><div class="ttdoc">Throw macro that always throws an exception. </div><div class="ttdef"><b>Definition:</b> <a href="_exception_8h_source.html#l00034">Exception.h:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a92ff858133bdb654de9b95c279427325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ff858133bdb654de9b95c279427325">&#9670;&nbsp;</a></span>writeUnsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> &gt; &gt; tk::writeUnsMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unstructured mesh to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to write mesh to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Unstructured mesh object to write from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reorder</td><td>Whether to also reorder mesh nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of time stamps consisting of a timer label (a string), and a time state (a <a class="el" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" title="Real number type used throughout the whole code. ">tk::real</a> in seconds) measuring the renumber and the mesh write time </dd></dl>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00134">134</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p class="reference">References <a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d">CREATE</a>, <a class="el" href="_print_8h_source.html#l00315">tk::Print::diagend()</a>, <a class="el" href="_print_8h_source.html#l00308">tk::Print::diagstart()</a>, <a class="el" href="_timer_8h_source.html#l00065">tk::Timer::dsec()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a834c8a77b335ad1c7bb2b632b6857339">EXODUSII</a>, <a class="el" href="_derived_data_8_c_source.html#l00026">genEsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00110">genPsup()</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30ad8e85cdb6ef83caac7fa35c22dda2153">GMSH</a>, <a class="el" href="namespacetk.html#a748833535365d6e320da5fcb7d213c30a8d2dc7a7e41c392a0da416ec0626e676">NETGEN</a>, <a class="el" href="_mesh_factory_8_c_source.html#l00066">pickOutput()</a>, <a class="el" href="_reorder_8_c_source.html#l00050">remap()</a>, <a class="el" href="_reorder_8_c_source.html#l00074">renumber()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00168">tk::UnsMesh::tetinpoel()</a>, <a class="el" href="_netgen_mesh_writer_8_c_source.html#l00029">tk::NetgenMeshWriter::writeMesh()</a>, <a class="el" href="_gmsh_mesh_writer_8_c_source.html#l00064">tk::GmshMeshWriter::writeMesh()</a>, <a class="el" href="_exodus_i_i_mesh_writer_8_c_source.html#l00082">tk::ExodusIIMeshWriter::writeMesh()</a>, and <a class="el" href="_timer_8h_source.html#l00061">tk::Timer::zero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00046">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;{</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  std::vector&lt; std::pair&lt; std::string, tk::real &gt; &gt; times;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="keywordflow">if</span> (reorder) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Reordering mesh nodes ...&quot;</span> );</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keyword">auto</span>&amp; inpoel = mesh.tetinpoel();</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a>( inpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a>( inpoel, 4 ) );</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    std::vector&lt; std::size_t &gt; map, invmap;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    std::tie( map, invmap ) = <a class="code" href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16">tk::renumber</a>( psup );</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <a class="code" href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4">tk::remap</a>( inpoel, map );</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    times.emplace_back( <span class="stringliteral">&quot;Renumber mesh&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    t.<a class="code" href="classtk_1_1_timer.html#a35be14a9a4bdbbaa93565c4abe9b25d0">zero</a>();</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">diagstart</a>( <span class="stringliteral">&quot;Writing mesh to file ...&quot;</span> );</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">pickOutput</a>( filename );</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordflow">if</span> (meshtype == MeshWriter::GMSH)</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    GmshMeshWriter( filename ).writeMesh( mesh );</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == MeshWriter::NETGEN)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    NetgenMeshWriter( filename ).writeMesh( mesh );</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype== MeshWriter::EXODUSII)</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    ExodusIIMeshWriter( filename, ExoWriter::CREATE ).writeMesh( mesh );</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  print.<a class="code" href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">diagend</a>( <span class="stringliteral">&quot;done&quot;</span> );</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  times.emplace_back( <span class="stringliteral">&quot;Write mesh to file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">dsec</a>() );</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keywordflow">return</span> times;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div><div class="ttc" id="classtk_1_1_timer_html"><div class="ttname"><a href="classtk_1_1_timer.html">tk::Timer</a></div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00030">Timer.h:30</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a35be14a9a4bdbbaa93565c4abe9b25d0"><div class="ttname"><a href="classtk_1_1_timer.html#a35be14a9a4bdbbaa93565c4abe9b25d0">tk::Timer::zero</a></div><div class="ttdeci">void zero()</div><div class="ttdoc">Zero timer. </div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00061">Timer.h:61</a></div></div>
<div class="ttc" id="namespacetk_html_ad2a88a65102c17149b44660db15d445b"><div class="ttname"><a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genPsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</div><div class="ttdoc">Generate derived data structure, points surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00110">DerivedData.C:110</a></div></div>
<div class="ttc" id="namespacetk_html_a1d0312d71017d8ffd9f11811a46e5a16"><div class="ttname"><a href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16">tk::renumber</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; renumber(const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)</div><div class="ttdoc">Reorder mesh points with the advancing front technique. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00074">Reorder.C:74</a></div></div>
<div class="ttc" id="classtk_1_1_timer_html_a569d68d17038fa38b83d5bb229500c40"><div class="ttname"><a href="classtk_1_1_timer.html#a569d68d17038fa38b83d5bb229500c40">tk::Timer::dsec</a></div><div class="ttdeci">real dsec() const</div><div class="ttdef"><b>Definition:</b> <a href="_timer_8h_source.html#l00065">Timer.h:65</a></div></div>
<div class="ttc" id="namespacetk_html_a64b09f52ea3b4314e449e70255837836"><div class="ttname"><a href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">tk::pickOutput</a></div><div class="ttdeci">MeshWriter pickOutput(const std::string &amp;filename)</div><div class="ttdoc">Determine output mesh file type. </div><div class="ttdef"><b>Definition:</b> <a href="_mesh_factory_8_c_source.html#l00066">MeshFactory.C:66</a></div></div>
<div class="ttc" id="namespacetk_html_a5ac2475f6c08b5fcb81392b14aad73a4"><div class="ttname"><a href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4">tk::remap</a></div><div class="ttdeci">void remap(std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;newid)</div><div class="ttdoc">Reorder mesh point ids in a vector given a new order, i.e., index map. </div><div class="ttdef"><b>Definition:</b> <a href="_reorder_8_c_source.html#l00050">Reorder.C:50</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_a9a3bb2dc7c5ea1d979dcec5528c37a66"><div class="ttname"><a href="classtk_1_1_print.html#a9a3bb2dc7c5ea1d979dcec5528c37a66">tk::Print::diagend</a></div><div class="ttdeci">void diagend(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00315">Print.h:315</a></div></div>
<div class="ttc" id="namespacetk_html_a66a2889d5d8aeb4a836842c6a1010463"><div class="ttname"><a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; genEsup(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</div><div class="ttdoc">Generate derived data structure, elements surrounding points. </div><div class="ttdef"><b>Definition:</b> <a href="_derived_data_8_c_source.html#l00026">DerivedData.C:26</a></div></div>
<div class="ttc" id="classtk_1_1_print_html_ae1f93831127fb7d45c33ad3cdf3604fd"><div class="ttname"><a href="classtk_1_1_print.html#ae1f93831127fb7d45c33ad3cdf3604fd">tk::Print::diagstart</a></div><div class="ttdeci">void diagstart(const std::string &amp;msg) const</div><div class="ttdef"><b>Definition:</b> <a href="_print_8h_source.html#l00308">Print.h:308</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a92ff858133bdb654de9b95c279427325_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1320fa5c795146f9a4ac4fc2eb4e2606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1320fa5c795146f9a4ac4fc2eb4e2606">&#9670;&nbsp;</a></span>BCMapMerger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReduction::reducerType tk::BCMapMerger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_lin_sys_merger_8_c_source.html#l00033">33</a> of file <a class="el" href="_lin_sys_merger_8_c_source.html">LinSysMerger.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="_lin_sys_merger_8h_source.html#l00679">tk::LinSysMerger&lt; HostProxy, WorkerProxy, AuxSolver &gt;::charebc()</a>.</p>

</div>
</div>
<a id="a0428a4f13b9aa50299fbb1e07a1c4889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0428a4f13b9aa50299fbb1e07a1c4889">&#9670;&nbsp;</a></span>BCValMerger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReduction::reducerType tk::BCValMerger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_lin_sys_merger_8_c_source.html#l00034">34</a> of file <a class="el" href="_lin_sys_merger_8_c_source.html">LinSysMerger.C</a>.</p>

</div>
</div>
<a id="a84de4d2862d3290bd756689ad204c028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84de4d2862d3290bd756689ad204c028">&#9670;&nbsp;</a></span>BCVectorMerger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CkReduction::reducerType tk::BCVectorMerger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charm++ reducers used by <a class="el" href="classtk_1_1_lin_sys_merger.html">LinSysMerger</a>. </p>
<p>These variables are defined here in the .C file and declared as extern in <a class="el" href="_lin_sys_merger_8h.html" title="Charm++ chare linear system merger group to solve a linear system. ">LinSysMerger.h</a>. If instead one defines them in the header (as static), a new version of any of these variables is created any time the header file is included, yielding no compilation nor linking errors. However, that leads to runtime errors, since <a class="el" href="classtk_1_1_lin_sys_merger.html#aa178f6e5b3cc7f2c2c29d698480c4fca" title="Configure Charm++ reduction types for concatenating BC nodelists. ">LinSysMerger::registerBCMerger()</a>, a Charm++ "initnode" entry method, <em>may</em> fill one while contribute() may use the other (unregistered) one. Result: undefined behavior, segfault, and formatting the internet ... </p>

<p class="definition">Definition at line <a class="el" href="_lin_sys_merger_8_c_source.html#l00032">32</a> of file <a class="el" href="_lin_sys_merger_8_c_source.html">LinSysMerger.C</a>.</p>

</div>
</div>
<a id="af9ca17aedbef10f63fdfdee06f57e29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ca17aedbef10f63fdfdee06f57e29c">&#9670;&nbsp;</a></span>CSTYLE_STRLEN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int tk::CSTYLE_STRLEN = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_msg_8h_source.html#l00030">30</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_msg_8h_source.html#l00062">tk::StringsMsg::StringsMsg()</a>, and <a class="el" href="_msg_8h_source.html#l00089">tk::VecStrsMsg&lt; Size &gt;::VecStrsMsg()</a>.</p>

</div>
</div>
<a id="a9aaf71501378c00aad4f847942cdef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaf71501378c00aad4f847942cdef6d">&#9670;&nbsp;</a></span>EqCompUnk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t tk::EqCompUnk = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00032">32</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

</div>
</div>
<a id="a78da814ef7132a0958c47f987e3e711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78da814ef7132a0958c47f987e3e711c">&#9670;&nbsp;</a></span>UnkEqComp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t tk::UnkEqComp = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags for selecting data layout policies. </p>

<p class="definition">Definition at line <a class="el" href="_data_8h_source.html#l00031">31</a> of file <a class="el" href="_data_8h_source.html">Data.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 23 2017 06:37:44 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
