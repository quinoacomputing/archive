<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/TeamCity-12/work/821a9fd6f64749d9/src/Inciter/Scheme.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_606df7a4664720c111e6e5b0e11c4e03.html">Inciter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Scheme.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic forwarding interface to discretization proxies.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_tags_8h_source.html">Tags.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_scheme_base_8h_source.html">SchemeBase.h</a>&quot;</code><br />
</div>
<p><a href="_inciter_2_scheme_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinciter_1_1_scheme.html">inciter::Scheme</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinciter_1_1_scheme_1_1call__setup.html">inciter::Scheme::call_setup&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinciter_1_1_scheme_1_1call__insert.html">inciter::Scheme::call_insert&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinciter_1_1_scheme_1_1call__done_inserting.html">inciter::Scheme::call_doneInserting&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinciter_1_1_scheme_1_1call__dt.html">inciter::Scheme::call_dt&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinciter_1_1_scheme_1_1call__eval.html">inciter::Scheme::call_eval&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinciter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinciter.html">inciter</a></td></tr>
<tr class="memdesc:namespaceinciter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inciter declarations and definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic forwarding interface to discretization proxies. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.</dd></dl>
<p>This file defines a generic interface to discretization proxies.</p>
<p>The purpose of this class is to hide, behind a single type, different Charm++ proxy types that model a single concept, i.e., define some common functions as Charm++ entry methods that can be used in either a broadcast and/or in a way of addressing a single array element. As a result, member functions can be invoked by client code without knowing the underlying type or any specifics to the underlying differences of the classes that model the same concept, i.e., expose the same member functions. The idea is very similar to inheritance and runtime polymorphism with base classes and virtual functions: some member functions and data are common to all types modeled (and thus are not repeated and/or copied), while some are specific. A difference is that the "base" and "child" classes are Charm++ proxies. Note that while Charm++ does support inheritance and runtime polymorphism with chare arrays, we still prefer the implementation below because it uses entirely value semantics (inside and in client code) and thus it keeps the complexity of the dispatch behind this class and does not expose it client code.</p>
<p>The advantages of this class over traditional runtime polymorphism are (1) value semantics (both internally and to client code), (2) not templated, and (3) PUPable, i.e., an instance of Scheme can be sent across the network using Charm++'s pup framework. Also, since the class only holds a couple of chare proxies, it is extremely lightweight.</p>
<p>Example usage from client code:</p>
<div class="fragment"><div class="line"><span class="comment">// Instantiate a Scheme object</span></div><div class="line"><a class="code" href="namespacetut.html#aed61cdb7ceaeb231855eede2e29f7399">Scheme</a> s( ctr::SchemeType::DG );  <span class="comment">// see Control/Inciter/Options/Scheme.h</span></div><div class="line"></div><div class="line"><span class="comment">// Call a member function entry method in broadcast fashion</span></div><div class="line">s.coord&lt; <a class="code" href="structtag_1_1bcast.html">tag::bcast</a> &gt;( ... );     <span class="comment">// equivalent to proxy.coord( ... );</span></div><div class="line"></div><div class="line"><span class="comment">// Call a member function entry method in addressing a single array</span></div><div class="line"><span class="comment">// element</span></div><div class="line">s.coord&lt; <a class="code" href="structtag_1_1elem.html">tag::elem</a> &gt;( 0, ... );   <span class="comment">// equivalent to proxy[0].coord( ... );</span></div><div class="line"></div><div class="line"><span class="comment">// Broadcast to a member function with optinoal CkEntryOptions object</span></div><div class="line">CkEntryOptions opt;</div><div class="line">s.coord&lt; <a class="code" href="structtag_1_1bcast.html">tag::bcast</a> &gt;( ..., opt );     <span class="comment">// proxy.coord( ..., opt );</span></div><div class="line"></div><div class="line"><span class="comment">// Address array element with optinoal CkEntryOptions object</span></div><div class="line">s.coord&lt; <a class="code" href="structtag_1_1elem.html">tag::elem</a> &gt;( 0, ..., opt );   <span class="comment">// proxy[0].coord( ..., opt );</span></div></div><!-- fragment --><p>Organization, implementation details, end extension of the class:</p>
<p>Scheme, via inheriting from SchemeBase, contains two Charm++ proxies: discproxy and proxy. The former contains data and functionality common to all discretizations, and this can be considered as an equivalent to a base class in the OOP sense. The latter, proxy, contains data and functionality specific to a particular discretization. When instantiated, Scheme is configured for a single specific discretization which must be selected from the list of types in SchemeBase::Proxy.</p>
<p>The underlying type of proxy is a variant, which allows storing exactly one object. A variant is a type-safe union. An instance of a variant at any given time either holds a value of one of its alternative types. Read more on std::variant or boost::variant on how they work.</p>
<p>All new member functions that comprise of the concept of the underlying proxies, i.e., the interface, must be defined in Scheme. Whereas common data, functionality, as well as the list of the proxy types that can be configured are defined in SchemeBase. Adding a new forwarding function either as a broadcast or addressing a particular chare array element can be done by simply copying an existing (similar) one and modifying what underlying function (entry method) it calls. The ones that forward to discproxy are grouped first, while the ones that forward to the specific proxy are listed as second. Using SFINAE, multiple overloads are (and can be) defined for a single function, depending on (1) whether it is a broadcast or addressing an array element, (2) whether it takes an optional (default) last argument, usually used for passing a CkEntryOptions object. You can see the Charm++-generated .decl.h file to see what (if any) default arguments a particular entry method may take.</p>
<p>Currently, forwarding functions are defined for two types entry method calls: broadcasts, i.e., proxy.fn(), and addressing a particular element, i.e., proxy[x].fn(). Another third might be useful to add in the future and that is addressing an entry method behind a section proxy. As we have not used section proxies so far, this is not yet implemented, but if necessary, it should be relatively straightforward to do.</p>
<p>Extending this class to other discretization schemes is done entirely in SchemeBase. Adding a new discretization scheme amounts to, at the minimum: (1) Adding a new type of Charm++ chare array proxy to SchemeBase::Proxy, (2) Adding a new type of Charm++ chare array element proxy to SchemeBase::ProxyElem, and (3) Adding a new branch to the if test in SchemeBase's constructor.</p>
<p>Implementation details: All forwarding calls are implemented taking a variadic parameter pack, which can take any number of arguments (including zero) and use perfect forwarding to pass the arguments to the entry method calls. This way the code remains generic, easy to modify, and the compiler automatically adjusts the generated forwarding calls if the types and/or number of the arguments to any of the entry methods change. One exception to this is those forwarding calls that deal with default arguments, allowing for passing CkEntryOptions objects. There the number of arguments are hard-coded in the SFINAE construct, but should also be straightforward to modify if necessary.</p>
<p>The functors named as call_* are used to dispatch (at compile time) entry method calls behind proxy, whose type is different depending on what specific discretization type is configured in the constructor. All common functionality in the call_* functors are lifted over to SchemeBase::Call. This helps keeping the function-call-specific code in Scheme minimal and reuses the generic part in SchemeBase.</p>
<p>Note that another way of doing the dispatch, that is now done using the call_* functors, could have been implemented using a (compile-, or runtime) associative container storing std::function objects which would store pre-bound function arguments. That would work, but there are three problems with such an approach: (1) std::function is not obvious how to pup, i.e., send across the network, (2) std::bind cannot currently be used to bind a variadic number arguments and thus the bind calls would not be very generic, and (3) a runtime associative container would take additional state. </p>

<p class="definition">Definition in file <a class="el" href="_inciter_2_scheme_8h_source.html">Scheme.h</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 20 2018 04:35:53 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
