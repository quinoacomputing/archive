
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href=https://github.com/quinoacomputing/quinoa/commit/1b6da3a>Quinoa_v0.2-3166-g1b6da3a</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script language="javascript">
      function getStyle(el,styleProp) {
        if (el.currentStyle)
          var y = el.currentStyle[styleProp];
        else if (window.getComputedStyle)
          var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
        return y;
      }
      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;
        if (el.style.display == "block") {
          el.style.display = "none";
          mark.innerHTML = "[+]";
        } else {
          el.style.display = "block";
          mark.innerHTML = "[-]";
        }
      }
      function init_expandables() {
        var elts = document.getElementsByClassName("expandable");
        for (var i = 0; i < elts.length; i++) {
          var el = elts[i];
          var clickable = el.getElementsByTagName("span")[0];
          var marker = clickable.getElementsByClassName("marker")[0];
          var content = el.getElementsByClassName("content")[0];
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.onclick = toggle;
        }
      }
      function set_class_display(c, st) {
        var elements = document.querySelectorAll('.' + c),
            len = elements.length;
        for (i = 0; i < len; i++) {
            elements[i].style.display = st;
        }
      }
      function toggle_class_visibility(id) {
        var box = document.getElementById(id);
        set_class_display(id, box.checked ? '' : 'none');
      }
    </script>
  </head>
  <body onload="init_expandables()">
      <div id="header">
        <h1>Cppcheck report - [<a href=https://github.com/quinoacomputing/quinoa/commit/1b6da3a>Quinoa_v0.2-3166-g1b6da3a</a>]: /tmp/TeamCity-14/work/821a9fd6f64749d9/src/Base/Factory.hpp </h1>
      </div>
      <div id="menu" dir="rtl">
       <p id="filename"><a href="index.html">Defects:</a> Factory.hpp</p>
<a href='10.html#line-112'> redundantAssignment 112</a>
      </div>
      <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Base/Factory.hpp</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015 J. Bakosi,</span>
<a name="line-5"></a><span class="cm">             2016-2018 Los Alamos National Security, LLC.,</span>
<a name="line-6"></a><span class="cm">             2019 Triad National Security, LLC.</span>
<a name="line-7"></a><span class="cm">             All rights reserved. See the LICENSE file for details.</span>
<a name="line-8"></a><span class="cm">  \brief     Factory utilities</span>
<a name="line-9"></a><span class="cm">  \details   Factory utilities. The functions defined in this file help</span>
<a name="line-10"></a><span class="cm">    interfacing with object factories. For a short introduction on what</span>
<a name="line-11"></a><span class="cm">    factories are good for, see</span>
<a name="line-12"></a><span class="cm">    http://www.boost.org/doc/libs/release/libs/functional/factory.</span>
<a name="line-13"></a><span class="cm">*/</span>
<a name="line-14"></a><span class="c1">// *****************************************************************************</span>
<a name="line-15"></a><span class="cp">#ifndef Factory_h</span>
<a name="line-16"></a><span class="cp">#define Factory_h</span>
<a name="line-17"></a>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<a name="line-19"></a><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<a name="line-20"></a>
<a name="line-21"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/factory.hpp&quot;</span><span class="cp"></span>
<a name="line-22"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/value_factory.hpp&quot;</span><span class="cp"></span>
<a name="line-23"></a>
<a name="line-24"></a><span class="cp">#include</span> <span class="cpf">&quot;Exception.hpp&quot;</span><span class="cp"></span>
<a name="line-25"></a>
<a name="line-26"></a><span class="k">namespace</span> <span class="n">tk</span> <span class="p">{</span>
<a name="line-27"></a>
<a name="line-28"></a><span class="c1">//! Register class into factory with given key. This is used to register a</span>
<a name="line-29"></a><span class="c1">//! derived-class object&#39;s constructor (deriving from some base class) to a</span>
<a name="line-30"></a><span class="c1">//! factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;,</span>
<a name="line-31"></a><span class="c1">//! i.e., an associative container, associating some key to a std::function</span>
<a name="line-32"></a><span class="c1">//! object holding a pointer of Child&#39;s base class constructor. The constructor</span>
<a name="line-33"></a><span class="c1">//! and its bound arguments are stored via boost::factory, which, in this</span>
<a name="line-34"></a><span class="c1">//! use-case, yields the correct function object of type Base constructor pointer</span>
<a name="line-35"></a><span class="c1">//! and thus facilitates runtime polymorphism. This function works in conjunction</span>
<a name="line-36"></a><span class="c1">//! with boost::factory, i.e., uses reference semantics (works with storing</span>
<a name="line-37"></a><span class="c1">//! pointers of objects). For a simple example on how to use this function, see</span>
<a name="line-38"></a><span class="c1">//! tests/unit/Base/Factory.h.</span>
<a name="line-39"></a><span class="c1">//! \param[in] f Factory to register to (std::map with value using reference</span>
<a name="line-40"></a><span class="c1">//!   semantics)</span>
<a name="line-41"></a><span class="c1">//! \param[in] key Key used to identify the entry in the factory</span>
<a name="line-42"></a><span class="c1">//! \param[in] args Variable number of arguments to pass to the constructor</span>
<a name="line-43"></a><span class="c1">//!   being registered. Note that the constructor arguments are only bound to</span>
<a name="line-44"></a><span class="c1">//!   the constructor and stored in the factory (an std::map with value using</span>
<a name="line-45"></a><span class="c1">//!   reference semantics). The object is not instantiated here, i.e., the</span>
<a name="line-46"></a><span class="c1">//!   constructor is not called here. The object can be instantiated by function</span>
<a name="line-47"></a><span class="c1">//!   instantiate. \see instantiate</span>
<a name="line-48"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">C</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Factory</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ConstructorArgs</span> <span class="o">&gt;</span>
<a name="line-49"></a><span class="kt">void</span> <span class="n">record</span><span class="p">(</span> <span class="n">Factory</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">ConstructorArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-50"></a>  <span class="n">f</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span>
<a name="line-51"></a>             <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">factory</span><span class="o">&lt;</span> <span class="n">C</span><span class="o">*</span> <span class="o">&gt;</span><span class="p">(),</span>
<a name="line-52"></a>                        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">ConstructorArgs</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-53"></a><span class="p">}</span>
<a name="line-54"></a>
<a name="line-55"></a><span class="c1">//! Instantiate object from factory. Factory must have a mapped_value which must</span>
<a name="line-56"></a><span class="c1">//! have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This</span>
<a name="line-57"></a><span class="c1">//! wrapper function can be used to instantiate an derived-class object from a</span>
<a name="line-58"></a><span class="c1">//! factory, repeatedly filled with wrapper function &#39;record&#39; above. The</span>
<a name="line-59"></a><span class="c1">//! factory, as described in the documentation of &#39;record&#39;, stores base class</span>
<a name="line-60"></a><span class="c1">//! pointers in an associative container, thereby facilitating runtime</span>
<a name="line-61"></a><span class="c1">//! polymorphism and a simple lookup-and-instantiate-style object creation. The</span>
<a name="line-62"></a><span class="c1">//! object instantiated is of type Child class. This function works in</span>
<a name="line-63"></a><span class="c1">//! conjunction with boost::factory, i.e., uses reference semantics (works with</span>
<a name="line-64"></a><span class="c1">//! storing pointers of objects). For a simple example on how to</span>
<a name="line-65"></a><span class="c1">//! use this function, see tests/unit//Base/Factory.h.</span>
<a name="line-66"></a><span class="c1">//! \param[in] f Factory to instantiate object from (std::map with value using</span>
<a name="line-67"></a><span class="c1">//!   reference semantics)</span>
<a name="line-68"></a><span class="c1">//! \param[in] key Key used to identify the object to instantiate from factory</span>
<a name="line-69"></a><span class="c1">//! \return std::unique_ptr pointing to the object instantiated from factory</span>
<a name="line-70"></a><span class="c1">//! \see record</span>
<a name="line-71"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Factory</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
<a name="line-72"></a>          <span class="k">class</span> <span class="nc">Obj</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_pointer</span><span class="o">&lt;</span>
<a name="line-73"></a>                        <span class="k">typename</span> <span class="n">Factory</span><span class="o">::</span><span class="n">mapped_type</span><span class="o">::</span><span class="n">result_type</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">&gt;</span>
<a name="line-74"></a><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span> <span class="n">Obj</span> <span class="o">&gt;</span> <span class="n">instantiate</span><span class="p">(</span> <span class="k">const</span> <span class="n">Factory</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-75"></a>  <span class="k">const</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">key</span> <span class="p">);</span>
<a name="line-76"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span> <span class="n">f</span> <span class="p">),</span> <span class="s">&quot;No such object registered in factory&quot;</span> <span class="p">);</span>
<a name="line-77"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span> <span class="n">Obj</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">()</span> <span class="p">);</span>
<a name="line-78"></a><span class="p">}</span>
<a name="line-79"></a>
<a name="line-80"></a><span class="c1">//! Register &quot;model&quot; class of &quot;host&quot; into factory with given key. This wrapper</span>
<a name="line-81"></a><span class="c1">//! can be used to in a similar manner to &#39;record&#39;, but uses</span>
<a name="line-82"></a><span class="c1">//! boost::value_factory to bind the model object constructor to its arguments</span>
<a name="line-83"></a><span class="c1">//! and place it in the associative container storing host class objects. The</span>
<a name="line-84"></a><span class="c1">//! container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e.,</span>
<a name="line-85"></a><span class="c1">//! associating a key to a function holding a constructor (and not its</span>
<a name="line-86"></a><span class="c1">//! pointer). Runtime polymorphism here is realized entirely within the &quot;base&quot;</span>
<a name="line-87"></a><span class="c1">//! class. See walker::DiffEq in DiffEq/DiffEq.h for an example and more</span>
<a name="line-88"></a><span class="c1">//! information on runtime polymorphism without client-side inheritance. As a</span>
<a name="line-89"></a><span class="c1">//! result, this wrapper works with factories that use value semantics, as opposed</span>
<a name="line-90"></a><span class="c1">//! to &#39;record&#39; and instantiate which work with reference semantics factories.</span>
<a name="line-91"></a><span class="c1">//! In order to differentiate between runtime polymorphic classes using</span>
<a name="line-92"></a><span class="c1">//! reference semantics, consistent with classes realizing runtime polymorphism</span>
<a name="line-93"></a><span class="c1">//! without client-side inheritance, we call Host as the &quot;Base&quot; class and Model</span>
<a name="line-94"></a><span class="c1">//! as the &quot;derived&quot; (or child) class. This wrapper function works in</span>
<a name="line-95"></a><span class="c1">//! conjunction with boost::value_factory, i.e., uses value semantics (works</span>
<a name="line-96"></a><span class="c1">//! with storing objects instead of object pointers). For a simple example on</span>
<a name="line-97"></a><span class="c1">//! how to use this function, see tests/unit//Base/Factory.h.</span>
<a name="line-98"></a><span class="c1">//! \param[in] f Factory to register to (std::map with value using value</span>
<a name="line-99"></a><span class="c1">//!   semantics)</span>
<a name="line-100"></a><span class="c1">//! \param[in] key Key used to identify the entry in the factory</span>
<a name="line-101"></a><span class="c1">//! \param[in] args Variable number of arguments to pass to the constructor</span>
<a name="line-102"></a><span class="c1">//!   being registered. Note that the constructor arguments are only bound to</span>
<a name="line-103"></a><span class="c1">//!   the constructor and stored in the factory (an std::map with value using</span>
<a name="line-104"></a><span class="c1">//!   value semantics). The object is not instantiated here, i.e., the</span>
<a name="line-105"></a><span class="c1">//!   constructor is not called here. The object can be instantiated by simply</span>
<a name="line-106"></a><span class="c1">//!   calling the function call operator () on the mapped value. For an example,</span>
<a name="line-107"></a><span class="c1">//!   RNGStack::selected() in RNG/RNGStack.C.</span>
<a name="line-108"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Host</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ModelConstructor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Factory</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
<a name="line-109"></a>          <span class="k">typename</span><span class="p">...</span> <span class="n">ModelConstrArgs</span> <span class="o">&gt;</span>
<a name="line-110"></a><span class="kt">void</span> <span class="n">recordModel</span><span class="p">(</span> <span class="n">Factory</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">ModelConstrArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-111"></a>  <span class="c1">// Bind model constructor to its arguments</span>
<a name="line-112"></a><span class="hll">  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="n">ModelConstructor</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span><span class='error2'>&lt;--- Variable 'std::bind' is reassigned a value before the old one has been used.</span>
</span><a name="line-113"></a>    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">value_factory</span><span class="o">&lt;</span> <span class="n">ModelConstructor</span> <span class="o">&gt;</span><span class="p">(),</span>
<a name="line-114"></a>               <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">ModelConstrArgs</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-115"></a>  <span class="c1">// Bind host to std::function of model constructor and place in factory</span>
<a name="line-116"></a>  <span class="n">f</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">value_factory</span><span class="o">&lt;</span> <span class="n">Host</span> <span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-117"></a><span class="p">}</span>
<a name="line-118"></a>
<a name="line-119"></a><span class="c1">//! Register model class of host into factory with given key using late binding.</span>
<a name="line-120"></a><span class="c1">//! This variant of &#39;record&#39; is very similar to &#39;recordModel&#39;, but registers a</span>
<a name="line-121"></a><span class="c1">//! model class constructor to a factory with late binding of the constructor</span>
<a name="line-122"></a><span class="c1">//! argument. Late binding allows specifying the constructor argument at the</span>
<a name="line-123"></a><span class="c1">//! time when the object is instantiated instead of at the time when it is</span>
<a name="line-124"></a><span class="c1">//! registered. This has all the benefits of using a factory and allows passing</span>
<a name="line-125"></a><span class="c1">//! information into the model object only when it is available. The late bind</span>
<a name="line-126"></a><span class="c1">//! is facilitated via std::bind instead of std::bind using a placeholder,</span>
<a name="line-127"></a><span class="c1">//! _1, which stands for the first argument (bound later, i.e., not here). The</span>
<a name="line-128"></a><span class="c1">//! value of the model constructor argument is then not used here, only its</span>
<a name="line-129"></a><span class="c1">//! type, used to perform the late binding. The binding happens to both the</span>
<a name="line-130"></a><span class="c1">//! model constructor via std::function (passed to the host constructor) as well</span>
<a name="line-131"></a><span class="c1">//! as explicitly to the host constructor. Prescribing late binding to the model</span>
<a name="line-132"></a><span class="c1">//! constructor ensures that the compiler requires the argument to the model</span>
<a name="line-133"></a><span class="c1">//! constructor, i.e., ensures that the host constructor is required to pass the</span>
<a name="line-134"></a><span class="c1">//! argument to the model constructor. Prescribing late binding to the host</span>
<a name="line-135"></a><span class="c1">//! constructor puts in the actual request that an argument (with the correct</span>
<a name="line-136"></a><span class="c1">//! type) must be passed to the host constructor at instantiate time, which then</span>
<a name="line-137"></a><span class="c1">//! will forward it to the model constructor. See also, for example,</span>
<a name="line-138"></a><span class="c1">//! walker::DiffEq&#39;s corresponding constructor. An example of client-side code</span>
<a name="line-139"></a><span class="c1">//! is in walker::DiffEqStack::registerDiffEq for registration into factory, and</span>
<a name="line-140"></a><span class="c1">//! DiffEqStack::createDiffEq for instantiation late-passing the argument.</span>
<a name="line-141"></a><span class="c1">//! \param[in] f Factory to register to (std::map with value using value</span>
<a name="line-142"></a><span class="c1">//!   semantics)</span>
<a name="line-143"></a><span class="c1">//! \param[in] key Key used to identify the entry in the factory</span>
<a name="line-144"></a><span class="c1">//! \warning Only works with a single constructor argument</span>
<a name="line-145"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Host</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ModelConstructor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Factory</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
<a name="line-146"></a>          <span class="k">typename</span> <span class="n">ModelConstrArg</span> <span class="o">&gt;</span>
<a name="line-147"></a><span class="kt">void</span> <span class="n">recordModelLate</span><span class="p">(</span> <span class="n">Factory</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">ModelConstrArg</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-148"></a>  <span class="c1">// Prescribe late binding the model constructor to its single argument</span>
<a name="line-149"></a>  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="n">ModelConstructor</span><span class="p">(</span><span class="k">const</span> <span class="n">ModelConstrArg</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span>
<a name="line-150"></a>    <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">value_factory</span><span class="o">&lt;</span> <span class="n">ModelConstructor</span> <span class="o">&gt;</span><span class="p">(),</span>
<a name="line-151"></a>               <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span> <span class="p">);</span>
<a name="line-152"></a>  <span class="c1">// Bind host to std::function of model constructor and place in factory and</span>
<a name="line-153"></a>  <span class="c1">// also explicitly bind single model constructor argument to host constructor</span>
<a name="line-154"></a>  <span class="n">f</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">value_factory</span><span class="o">&lt;</span> <span class="n">Host</span> <span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
<a name="line-155"></a>                             <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-156"></a><span class="p">}</span>
<a name="line-157"></a>
<a name="line-158"></a><span class="c1">//! Register Charm++ model class of host into factory with given key. We bind a</span>
<a name="line-159"></a><span class="c1">//! host constructor to its arguments of which the first one is a std::function</span>
<a name="line-160"></a><span class="c1">//! holding a model constructor type (modeling, i.e., used polymorhically with</span>
<a name="line-161"></a><span class="c1">//! host), followed by an optional number of others (possibly zero) with</span>
<a name="line-162"></a><span class="c1">//! arbitrary types. Note that the model constructor is a nullptr (default-</span>
<a name="line-163"></a><span class="c1">//! constructed) and only used to forward its type to the call site inside</span>
<a name="line-164"></a><span class="c1">//! std::function. The host constructor function is then placed into the</span>
<a name="line-165"></a><span class="c1">//! factory. This is because Charm++ chares do not explicitly invoke</span>
<a name="line-166"></a><span class="c1">//! constructors, only call ckNew() on their proxy, which requires all</span>
<a name="line-167"></a><span class="c1">//! constructor arguments to be present and forwarded to the actual constructor</span>
<a name="line-168"></a><span class="c1">//! that is only called at a later point in time. This can then be used by those</span>
<a name="line-169"></a><span class="c1">//! constructors of hosts that invoke the model constructors&#39; proxies&#39; ckNew()</span>
<a name="line-170"></a><span class="c1">//! and ignore the std::function. See, e.g., rngtest::Battery() and the</span>
<a name="line-171"></a><span class="c1">//! associated unit tests in tests/unit//Base/Factory.h.</span>
<a name="line-172"></a><span class="c1">//! \param[in] f Factory to register to (std::map with value using value</span>
<a name="line-173"></a><span class="c1">//!   semantics)</span>
<a name="line-174"></a><span class="c1">//! \param[in] key Key used to identify the entry in the factory</span>
<a name="line-175"></a><span class="c1">//! \param[in] args Variable number of arguments to pass to the constructor</span>
<a name="line-176"></a><span class="c1">//!   being registered.</span>
<a name="line-177"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Host</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ModelConstructor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Factory</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
<a name="line-178"></a>          <span class="k">typename</span><span class="p">...</span> <span class="n">ModelConstrArgs</span> <span class="o">&gt;</span>
<a name="line-179"></a><span class="kt">void</span> <span class="n">recordCharmModel</span><span class="p">(</span> <span class="n">Factory</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">ModelConstrArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-180"></a>  <span class="n">f</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">value_factory</span><span class="o">&lt;</span> <span class="n">Host</span> <span class="o">&gt;</span><span class="p">(),</span>
<a name="line-181"></a>                             <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="n">ModelConstructor</span><span class="p">()</span> <span class="o">&gt;</span><span class="p">(),</span> <span class="c1">// nullptr</span>
<a name="line-182"></a>                             <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">ModelConstrArgs</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...)</span> <span class="p">);</span>
<a name="line-183"></a><span class="p">}</span>
<a name="line-184"></a>
<a name="line-185"></a><span class="p">}</span> <span class="c1">// tk::</span>
<a name="line-186"></a>
<a name="line-187"></a><span class="cp">#endif </span><span class="c1">// Factory_h</span>
</pre></div>
</td></tr></table>
      </div>
      <div id="footer">
        <p>
         Cppcheck 1.87 - a tool for static C/C++ code analysis</br>
         </br>
         Internet: <a href="http://cppcheck.net">http://cppcheck.net</a></br>
         IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a></br>
        <p>
      </div>
  </body>
</html>
