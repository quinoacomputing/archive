<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/q/quinoa/src/Control/CommonGrammar.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3ff0826a6d651abbf0f532354e1ac7dc.html">Control</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CommonGrammar.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic, low-level grammar, re-used by specific grammars.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;boost/mpl/or.hpp&gt;</code><br />
<code>#include &quot;<a class="el" href="for__each_8h_source.html">NoWarning/for_each.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_if_8h_source.html">If.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_exception_8h_source.html">Exception.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_tags_8h_source.html">Tags.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_stat_ctr_8h_source.html">StatCtr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_d_f_file_8h_source.html">Options/PDFFile.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_d_f_policy_8h_source.html">Options/PDFPolicy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_d_f_centering_8h_source.html">Options/PDFCentering.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_txt_float_format_8h_source.html">Options/TxtFloatFormat.h</a>&quot;</code><br />
</div>
<p><a href="_common_grammar_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1is__keyword.html">tk::grm::is_keyword&lt; use &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time test functor verifying that type U is a keyword.  <a href="structtk_1_1grm_1_1is__keyword.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action.html">tk::grm::action&lt; Rule &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1call.html">tk::grm::call&lt; As &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1act.html">tk::grm::act&lt; rule, actions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01act_3_01rule_00_01actions_8_8_8_01_4_01_4.html">tk::grm::action&lt; act&lt; rule, actions... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1msg.html">tk::grm::msg&lt; MsgType, MsgKey &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01msg_3_01type_00_01key_01_4_01_4.html">tk::grm::action&lt; msg&lt; type, key &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error message dispatch.  <a href="structtk_1_1grm_1_1action_3_01msg_3_01type_00_01key_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_set.html">tk::grm::Set&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_set_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Set&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put value in state at position given by tags without conversion.  <a href="structtk_1_1grm_1_1action_3_01_set_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_store.html">tk::grm::Store&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_store_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Store&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put value in state at position given by tags with conversion.  <a href="structtk_1_1grm_1_1action_3_01_store_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_store__back.html">tk::grm::Store_back&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_store__back.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_store__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Store_back&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_store__back__back.html">tk::grm::Store_back_back&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_store__back__back.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_store__back__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Store_back_back&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector in state at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01_store__back__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_store__back__back__back.html">tk::grm::Store_back_back_back&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_store__back__back__back.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_store__back__back__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Store_back_back_back&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector of back of vector in state at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01_store__back__back__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_store__switch.html">tk::grm::Store_switch&lt; tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_store__switch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_store__switch_3_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Store_switch&lt; tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put true in switch in state at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01_store__switch_3_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1store__back__option.html">tk::grm::store_back_option&lt; use, Option, tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1store__back__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01store__back__option_3_01use_00_01_option_00_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; store_back_option&lt; use, Option, tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back option to vector in state at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01store__back__option_3_01use_00_01_option_00_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1store__back__back__option.html">tk::grm::store_back_back_option&lt; use, Option, tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1store__back__back__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01store__back__back__option_3_01use_00_01_option_00_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; store_back_back_option&lt; use, Option, tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back option to vector of back of vector in state at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01store__back__back__option_3_01use_00_01_option_00_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1_insert__field.html">tk::grm::Insert_field&lt; field, sel, vec, tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1_insert__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01_insert__field_3_01field_00_01sel_00_01vec_00_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; Insert_field&lt; field, sel, vec, tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and insert value to map at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01_insert__field_3_01field_00_01sel_00_01vec_00_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1insert__option.html">tk::grm::insert_option&lt; use, Option, field, sel, vec, tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1insert__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01insert__option_3_01use_00_01_option_00_01field_00_01sel_00_01vec_09587f0431f58070a414c23b4da8aca85.html">tk::grm::action&lt; insert_option&lt; use, Option, field, sel, vec, tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and insert option value to map at position given by tags.  <a href="structtk_1_1grm_1_1action_3_01insert__option_3_01use_00_01_option_00_01field_00_01sel_00_01vec_09587f0431f58070a414c23b4da8aca85.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1store__precision.html">tk::grm::store_precision&lt; prec &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1store__precision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01store__precision_3_01prec_01_4_01_4.html">tk::grm::action&lt; store_precision&lt; prec &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtk_1_1grm_1_1_set.html" title="Rule used to trigger action. ">Set</a> numeric precision for ASCII output of floating-point values.  <a href="structtk_1_1grm_1_1action_3_01store__precision_3_01prec_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1helpkw.html">tk::grm::helpkw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1helpkw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01helpkw_01_4.html">tk::grm::action&lt; helpkw &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find keyword among all keywords and if found, store the keyword and its info on which help was requested behind <a class="el" href="structtag_1_1helpkw.html">tag::helpkw</a> in Stack.  <a href="structtk_1_1grm_1_1action_3_01helpkw_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1match__depvar.html">tk::grm::match_depvar&lt; push &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1match__depvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01match__depvar_3_01push_01_4_01_4.html">tk::grm::action&lt; match_depvar&lt; push &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match depvar (dependent variable) to one of the selected ones.  <a href="structtk_1_1grm_1_1action_3_01match__depvar_3_01push_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1match__pdfname.html">tk::grm::match_pdfname</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1match__pdfname.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01match__pdfname_01_4.html">tk::grm::action&lt; match_pdfname &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match PDF name to the registered ones.  <a href="structtk_1_1grm_1_1action_3_01match__pdfname_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__store__option.html">tk::grm::check_store_option&lt; use, Option, sel, vec, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__store__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__store__option_3_01use_00_01_option_00_01sel_00_01vec_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; check_store_option&lt; use, Option, sel, vec, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put option in state at position given by tags if among the selected.  <a href="structtk_1_1grm_1_1action_3_01check__store__option_3_01use_00_01_option_00_01sel_00_01vec_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1add__depvar.html">tk::grm::add_depvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1add__depvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01add__depvar_01_4.html">tk::grm::action&lt; add_depvar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add depvar (dependent variable) to the selected ones.  <a href="structtk_1_1grm_1_1action_3_01add__depvar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1start__vector.html">tk::grm::start_vector&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1start__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01start__vector_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; start_vector&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start new vector in vector.  <a href="structtk_1_1grm_1_1action_3_01start__vector_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1start__vector__back.html">tk::grm::start_vector_back&lt; tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1start__vector__back.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01start__vector__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html">tk::grm::action&lt; start_vector_back&lt; tag, tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start new vector in back of a vector.  <a href="structtk_1_1grm_1_1action_3_01start__vector__back_3_01tag_00_01tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1push__term.html">tk::grm::push_term&lt; Moment, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1push__term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01push__term_3_01m_00_01var_01_4_01_4.html">tk::grm::action&lt; push_term&lt; m, var &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add matched value as Term into vector of vector of statistics.  <a href="structtk_1_1grm_1_1action_3_01push__term_3_01m_00_01var_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1push__sample.html">tk::grm::push_sample&lt; m &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1push__sample.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01push__sample_3_01m_01_4_01_4.html">tk::grm::action&lt; push_sample&lt; m &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add matched value as Term into vector of vector of PDFs.  <a href="structtk_1_1grm_1_1action_3_01push__sample_3_01m_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1push__binsize.html">tk::grm::push_binsize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1push__binsize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01push__binsize_01_4.html">tk::grm::action&lt; push_binsize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push matched value into vector of vector binsizes.  <a href="structtk_1_1grm_1_1action_3_01push__binsize_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1push__extents.html">tk::grm::push_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1push__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01push__extents_01_4.html">tk::grm::action&lt; push_extents &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push matched value into vector of PDF extents.  <a href="structtk_1_1grm_1_1action_3_01push__extents_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__vector.html">tk::grm::check_vector&lt; eq, param &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__vector_3_01eq_00_01param_01_4_01_4.html">tk::grm::action&lt; check_vector&lt; eq, param &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check parameter vector.  <a href="structtk_1_1grm_1_1action_3_01check__vector_3_01eq_00_01param_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__spikes.html">tk::grm::check_spikes&lt; eq, param &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__spikes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__spikes_3_01eq_00_01param_01_4_01_4.html">tk::grm::action&lt; check_spikes&lt; eq, param &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the spikes parameter vector specifications are correct.  <a href="structtk_1_1grm_1_1action_3_01check__spikes_3_01eq_00_01param_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__betapdfs.html">tk::grm::check_betapdfs&lt; eq, param &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__betapdfs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__betapdfs_3_01eq_00_01param_01_4_01_4.html">tk::grm::action&lt; check_betapdfs&lt; eq, param &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the betapdf parameter vector specifications are correct.  <a href="structtk_1_1grm_1_1action_3_01check__betapdfs_3_01eq_00_01param_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__expectation.html">tk::grm::check_expectation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__expectation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__expectation_01_4.html">tk::grm::action&lt; check_expectation &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is at least one variable in expectation.  <a href="structtk_1_1grm_1_1action_3_01check__expectation_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__binsizes.html">tk::grm::check_binsizes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__binsizes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__binsizes_01_4.html">tk::grm::action&lt; check_binsizes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the number of binsizes equal the PDF sample space variables.  <a href="structtk_1_1grm_1_1action_3_01check__binsizes_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__extents.html">tk::grm::check_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__extents_01_4.html">tk::grm::action&lt; check_extents &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the number of extents equal 2 * the PDF sample space variables.  <a href="structtk_1_1grm_1_1action_3_01check__extents_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1check__samples.html">tk::grm::check_samples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1check__samples.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01check__samples_01_4.html">tk::grm::action&lt; check_samples &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is at least one sample space variable in PDF.  <a href="structtk_1_1grm_1_1action_3_01check__samples_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1save__field.html">tk::grm::save_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule used to trigger action.  <a href="structtk_1_1grm_1_1save__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1action_3_01save__field_01_4.html">tk::grm::action&lt; save_field &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save field ID to parser's state so <a class="el" href="structtk_1_1grm_1_1push__term.html" title="Rule used to trigger action. ">push_term</a> can pick it up.  <a href="structtk_1_1grm_1_1action_3_01save__field_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1trim.html">tk::grm::trim&lt; token, erased &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 'token' until 'erased' trimming, i.e., not consuming, 'erased'.  <a href="structtk_1_1grm_1_1trim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1unknown.html">tk::grm::unknown&lt; type, key &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match unknown keyword and handle error.  <a href="structtk_1_1grm_1_1unknown.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1alias.html">tk::grm::alias&lt; keyword &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match alias cmdline keyword.  <a href="structtk_1_1grm_1_1alias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1verbose.html">tk::grm::verbose&lt; keyword &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match verbose cmdline keyword.  <a href="structtk_1_1grm_1_1verbose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1readkw.html">tk::grm::readkw&lt; token &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read keyword 'token' padded by blank at left and space at right.  <a href="structtk_1_1grm_1_1readkw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1readcmd.html">tk::grm::readcmd&lt; keyword, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read command line 'keyword' in verbose form, i.e., '&ndash;keyword'.  <a href="structtk_1_1grm_1_1readcmd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1readcmd_3_01keyword_00_01typename_01if___3_01false_00_01typename_01keyword_1_00e55a5c953a2708b6f3bafb2f26d0c9.html">tk::grm::readcmd&lt; keyword, typename if_&lt; false, typename keyword::info::alias &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read command line 'keyword' in either verbose or alias form.  <a href="structtk_1_1grm_1_1readcmd_3_01keyword_00_01typename_01if___3_01false_00_01typename_01keyword_1_00e55a5c953a2708b6f3bafb2f26d0c9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1scan.html">tk::grm::scan&lt; keyword, actions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan input padded by blank at left and space at right and if it matches 'keywords', apply 'actions'.  <a href="structtk_1_1grm_1_1scan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1scan__until.html">tk::grm::scan_until&lt; keywords, action, end &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan input padded by blank at left and space at right and if it matches 'keywords', apply 'action'.  <a href="structtk_1_1grm_1_1scan__until.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1comment.html">tk::grm::comment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse comment: start with '#' until eol.  <a href="structtk_1_1grm_1_1comment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1ignore.html">tk::grm::ignore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore comments and empty lines.  <a href="structtk_1_1grm_1_1ignore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1number.html">tk::grm::number</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a number: an optional sign followed by digits.  <a href="structtk_1_1grm_1_1number.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1block.html">tk::grm::block&lt; endkeyword, tokens &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plow through 'tokens' until 'endkeyword'.  <a href="structtk_1_1grm_1_1block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1vector.html">tk::grm::vector&lt; key, insert, endkeyword, starter, value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plow through vector of values between keywords 'key' and 'endkeyword', calling 'insert' for each if matches and allow comments between values.  <a href="structtk_1_1grm_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1quoted.html">tk::grm::quoted&lt; insert, lbound, rbound &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan string between characters 'lbound' and 'rbound' and if matches apply action 'insert'.  <a href="structtk_1_1grm_1_1quoted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1process.html">tk::grm::process&lt; keyword, insert, kw_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process 'keyword' and call its 'insert' action if matches 'kw_type'.  <a href="structtk_1_1grm_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1process__cmd.html">tk::grm::process_cmd&lt; keyword, insert, kw_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process command line 'keyword' and call its 'insert' action if matches 'kw_type'.  <a href="structtk_1_1grm_1_1process__cmd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1process__cmd__switch.html">tk::grm::process_cmd_switch&lt; keyword, tag, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process command line switch 'keyword'.  <a href="structtk_1_1grm_1_1process__cmd__switch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1read__file.html">tk::grm::read_file&lt; keywords, ign &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic file parser entry point: parse 'keywords' and 'ignore' until end of file.  <a href="structtk_1_1grm_1_1read__file.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1charmarg.html">tk::grm::charmarg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process but ignore Charm++'s charmrun arguments starting with '+'.  <a href="structtk_1_1grm_1_1charmarg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1read__string.html">tk::grm::read_string&lt; keywords &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic string parser entry point: parse 'keywords' until end of string.  <a href="structtk_1_1grm_1_1read__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1rng__option.html">tk::grm::rng_option&lt; use, keyword, option, field, sel, vec, tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">RNG</a> parameter.  <a href="structtk_1_1grm_1_1rng__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1fieldvar.html">tk::grm::fieldvar&lt; var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fieldvar: a character, denoting a variable, optionally followed by a digit  <a href="structtk_1_1grm_1_1fieldvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1term.html">tk::grm::term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">term: upper or lowercase fieldvar matched to selected depvars for stats  <a href="structtk_1_1grm_1_1term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1sample__space__var.html">tk::grm::sample_space_var&lt; c, m &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sample space variable: fieldvar matched to selected depvars  <a href="structtk_1_1grm_1_1sample__space__var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1grm_1_1samples.html">tk::grm::samples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">samples: sample space variables optionally separated by fillers  <a href="structtk_1_1grm_1_1samples.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetk"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html">tk</a></td></tr>
<tr class="memdesc:namespacetk"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit declarations and definitions for general purpose utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetk_1_1grm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html">tk::grm</a></td></tr>
<tr class="memdesc:namespacetk_1_1grm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit general purpose grammar definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5cfc0a80bcb9c742a4dd13252e8e70b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_grammar_8h.html#a5cfc0a80bcb9c742a4dd13252e8e70b2">BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</a></td></tr>
<tr class="separator:a5cfc0a80bcb9c742a4dd13252e8e70b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add19bfd3b2b79f9086bc116a851c03a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_common_grammar_8h.html#add19bfd3b2b79f9086bc116a851c03a3">BOOST_MPL_LIMIT_METAFUNCTION_ARITY</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:add19bfd3b2b79f9086bc116a851c03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a57c955efdfcb79da5346d57da1a67f9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#a57c955efdfcb79da5346d57da1a67f9d">tk::grm::ncomp_t</a> = kw::ncomp::info::expect::type</td></tr>
<tr class="separator:a57c955efdfcb79da5346d57da1a67f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaea8b8be7c61e0bfb422394a315b2b64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64">tk::grm::MsgType</a> { <br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a2524effb18ba47fd4b68e016bc4618a5">tk::grm::ERROR</a> =0, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a91b152b474fe56d25c1f3e0c60fcfdcd">tk::grm::WARNING</a>
<br />
 }<tr class="memdesc:aaea8b8be7c61e0bfb422394a315b2b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style enum indicating warning or error (used as template argument)  <a href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aaea8b8be7c61e0bfb422394a315b2b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dbe384e8ce31796b7eb5f6ac87e1a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3">tk::grm::MsgKey</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a780bc0722dd01d4a8d9869f060734be6">tk::grm::MsgKey::KEYWORD</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a0246c44408f8c23804cdad1c176961a3">tk::grm::MsgKey::MOMENT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3aa41713a63eeaa93942ab59aa854e5552">tk::grm::MsgKey::QUOTED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a298cb25408234de02baf2085803a464a">tk::grm::MsgKey::LIST</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3adc6effcb98019a63f6d5ee5624a29058">tk::grm::MsgKey::ALIAS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a10d1208b485425756fcc932229386b02">tk::grm::MsgKey::MISSING</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a89641087db7537257be3b61a5ee5c287">tk::grm::MsgKey::PREMATURE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a40aa75f8e8cfdf7b660c5620e953229f">tk::grm::MsgKey::UNSUPPORTED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ae4a0814c024a470edc9841424ccd8989">tk::grm::MsgKey::NOOPTION</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a77b3e8da86a70a357f25d04608341734">tk::grm::MsgKey::NOINIT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a15c7e870262beaa74148eb67bdd7895b">tk::grm::MsgKey::NOPROBLEM</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3af06c41f36ff3b1576af844c1e57d6a50">tk::grm::MsgKey::NOCOEFF</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ae19206cd0464bf3c4e945cb58c00ee55">tk::grm::MsgKey::NOTSELECTED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a6a240802522e95fc9e2c1d09122d8ec4">tk::grm::MsgKey::EXISTS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ab8e701c43b5336ceaf0a59fe36831f86">tk::grm::MsgKey::NODEPVAR</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3af4de0c0702a4cc7588415726715ce109">tk::grm::MsgKey::NOSUCHDEPVAR</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ab07a89e04fea61fb4a1f0d4ed7d3ae17">tk::grm::MsgKey::NOTALPHA</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ac663df4d73a5c29b8e5bdec63f5922a8">tk::grm::MsgKey::NOTERMS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3aac50cd5afc48049810d93c5a816dbe04">tk::grm::MsgKey::ODDSPIKES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a4ea172ba96e853ccada019d784cb0f9d">tk::grm::MsgKey::HEIGHTSPIKES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ac776d74d34bf27fa1ad5f3d233d84933">tk::grm::MsgKey::NODELTA</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a3454fc9df3dd05c535a99a45dd267495">tk::grm::MsgKey::NOBETA</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a4b9466042bf22f34f65e5bc33559ada3">tk::grm::MsgKey::WRONGBETAPDF</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ac727e3ca4f9464113e8bc6aa5ca6fc2e">tk::grm::MsgKey::NONCOMP</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a61cb7af456776a7f26a0cb9330b2ce55">tk::grm::MsgKey::NORNG</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a725e7394d50e3101784998ece8051240">tk::grm::MsgKey::NODT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a3a625493e5ef6e75dd78e11c77012bbe">tk::grm::MsgKey::MULDT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a2ebfecee2e107ad86ffe68012c3c3042">tk::grm::MsgKey::NOSAMPLES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a88950748e8f010f6ae950f4eb4106fa7">tk::grm::MsgKey::INVALIDSAMPLESPACE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a239ba5e1bef64feb105c9ee30345840c">tk::grm::MsgKey::MALFORMEDSAMPLE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a629799e69793c0af402637376f2a51ed">tk::grm::MsgKey::INVALIDBINSIZE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a5ef34b2e3cda3798c6f834d930e3eae4">tk::grm::MsgKey::INVALIDEXTENT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3afce88a088d8fdbd356513842c6052dc2">tk::grm::MsgKey::EXTENTLOWER</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ad591593674d66752b771b1a4599da7b3">tk::grm::MsgKey::NOBINS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a98c55b7450a6427b40bdcd0a8956c897">tk::grm::MsgKey::ZEROBINSIZE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3acc0518b6a28d1ce620a734193c7fbddb">tk::grm::MsgKey::MAXSAMPLES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a8875772cb6fcaf5acb12ce4ac3d128bd">tk::grm::MsgKey::MAXBINSIZES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a6ab6feaff45e56dba9245e62bc3186bc">tk::grm::MsgKey::MAXEXTENTS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a45f6a717344b57b3f51cd0d7fc054281">tk::grm::MsgKey::BINSIZES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3abcd1b68617759b1dfcff0403a6b5a8d1">tk::grm::MsgKey::PDF</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3aa28678ab5fdc71ced496bd889a64e779">tk::grm::MsgKey::PDFEXISTS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a9fbe53a80ac534622e981c88d28399af">tk::grm::MsgKey::BADPRECISION</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3ac97cbf643aebbfbbd708c0a42d8701f1">tk::grm::MsgKey::PRECISIONBOUNDS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a6f8eb84e55e2f1c21cb428ae5b644a6e">tk::grm::MsgKey::UNFINISHED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a5b5dca347f4ec834e04d00baf8f8a4de">tk::grm::MsgKey::VORTICAL_UNFINISHED</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a007ae8e190b2682e73db46fb00adf7e4">tk::grm::MsgKey::BC_EMPTY</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3aebcad5d28c278b92b3cd13463222f424">tk::grm::MsgKey::WRONGSIZE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a40f8e5cc1610e8e039927f31fe57a2d3">tk::grm::MsgKey::HYDROTIMESCALES</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a8d6a191cb26f86b1fb9e7e97c195bbfb">tk::grm::MsgKey::HYDROPRODUCTIONS</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3a8c970ecda90f7da2938effc047671913">tk::grm::MsgKey::CHARMARG</a>
<br />
 }<tr class="memdesc:a86dbe384e8ce31796b7eb5f6ac87e1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser error types.  <a href="namespacetk_1_1grm.html#a86dbe384e8ce31796b7eb5f6ac87e1a3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a86dbe384e8ce31796b7eb5f6ac87e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2940f66c424b4074c2388f899fa8c8de"><td class="memItemLeft" align="right" valign="top">static const std::map&lt; MsgKey, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#a2940f66c424b4074c2388f899fa8c8de">tk::grm::message</a> ({ { MsgKey::KEYWORD, &quot;Unknown keyword or keyword unrecognized in this &quot; &quot;block.&quot; }, { MsgKey::MOMENT, &quot;Unknown term in moment.&quot; }, { MsgKey::QUOTED, &quot;Must be double-quoted.&quot; }, { MsgKey::LIST, &quot;Unknown value in list.&quot; }, { MsgKey::ALIAS, &quot;Alias keyword too long. Use either a full-length keyword &quot; &quot;with double-hyphens, e.g., --keyword, or its alias, a single character, &quot; &quot;with a single hyphen, e.g., -k.&quot; }, { MsgKey::MISSING, &quot;Required field missing.&quot; }, { MsgKey::PREMATURE, &quot;Premature end of line.&quot; }, { MsgKey::UNSUPPORTED, &quot;Option not supported.&quot; }, { MsgKey::NOOPTION, &quot;Option does not exist.&quot; }, { MsgKey::NOTSELECTED, &quot;Option is not among the selected ones. The keyword &quot; &quot;here is appropriate, but in order to use this keyword in this context, &quot; &quot;the option must be selected upstream.&quot; }, { MsgKey::EXISTS, &quot;Dependent variable already used.&quot; }, { MsgKey::NOSUCHDEPVAR, &quot;Dependent variable not selected. To request a &quot; &quot;statistic or PDF involving this variable, or use this variable as a &quot; &quot;coefficients policy variable, an equation must be specified &quot; &quot;upstream in the control file assigning this variable to an &quot; &quot;equation to be integrated using the depvar keyword.&quot; }, { MsgKey::NOTALPHA, &quot;Variable not alphanumeric.&quot; }, { MsgKey::HEIGHTSPIKES, &quot;The sum of all spike heights given in the &quot; &quot;spike...end block does not add up to unity. A spike...end block &quot; &quot;must contain an even number of real numbers, where every odd one is the &quot; &quot;sample space position of a spike followed by the spike height &quot; &quot;specifying the relative probability of the spike. Since the spike &quot; &quot;heights are probabilities relative to unity, they must sum to one.&quot; }, { MsgKey::NODEPVAR, &quot;Dependent variable not specified within the block &quot; &quot;preceding this position. This is mandatory for the preceding block. Use &quot; &quot;the keyword 'depvar' to specify the dependent variable.&quot; }, { MsgKey::NONCOMP, &quot;The number of components has not been specified in the &quot; &quot;block preceding this position. This is mandatory for the preceding &quot; &quot;block. Use the keyword 'ncomp' to specify the number of components.&quot; }, { MsgKey::NORNG, &quot;The random number generator has not been specified in &quot; &quot;the block preceding this position. This is mandatory for the preceding &quot; &quot;block. Use the keyword 'rng' to specify the random number generator.&quot; }, { MsgKey::NODT, &quot;No time step calculation policy has been selected in the &quot; &quot;preceeding block. Use keyword 'dt' to set a constant or 'cfl' to set an &quot; &quot;adaptive time step size calculation policy.&quot; }, { MsgKey::MULDT, &quot;Multiple time step calculation policies has been &quot; &quot;selected in the preceeding block. Use either keyword 'dt' to set a &quot; &quot;constant or 'cfl' to set an adaptive time step size calculation policy. &quot; &quot;Setting 'cfl' and 'dt' are mutually exclusive. If both 'cfl' and 'dt' &quot; &quot;are set, 'dt' wins.&quot; }, { MsgKey::NOINIT, &quot;No initialization policy has been specified within the &quot; &quot;block preceding this position. This is mandatory for the preceding &quot; &quot;block. Use the keyword 'init' to specify an initialization policy.&quot; }, { MsgKey::NOPROBLEM, &quot;No test problem has been specified within the &quot; &quot;block preceding this position. This is mandatory for the preceding &quot; &quot;block. Use the keyword 'problem' to specify a test problem.&quot; }, { MsgKey::NOCOEFF, &quot;No coefficients policy has been specified within the &quot; &quot;block preceding this position. This is mandatory for the preceding &quot; &quot;block. Use the keyword 'coeff' to specify an coefficients policy.&quot; }, { MsgKey::NODELTA, &quot;No icdelta...end block with at least a single &quot; &quot;spike...end block has been specified within the block preceding this &quot; &quot;position. This is mandatory for the preceding block if the joint delta &quot; &quot;initpolicy is selected. Pick an initpolicy different than jointdelta &quot; &quot;(using keyword 'init') or specify at least a single spike...end block &quot; &quot;(within an icdelta...end block).&quot; }, { MsgKey::NOBETA, &quot;No beta...end block with at least a single &quot; &quot;betapdf...end block has been specified within the block preceding this &quot; &quot;position. This is mandatory for the preceding block if jointbeta &quot; &quot;initpolicy is selected. Pick an initpolicy different than jointbeta &quot; &quot;(using keyword 'init') or specify at least a single betapdf...end block &quot; &quot;(within a icbeta...end block).&quot; }, { MsgKey::ODDSPIKES, &quot;Incomplete spike...end block has been specified &quot; &quot;within the  block preceding this position. A spike...end block &quot; &quot;must contain an even number of real numbers, where every odd one is the &quot; &quot;sample space position of a spike followed by the spike height &quot; &quot;specifying the relative probability of the spike.&quot; }, { MsgKey::WRONGBETAPDF, &quot;Wrong number of beta distribution parameters. A &quot; &quot;beta distribution must be configured by exactly four real numbers in a &quot; &quot;betapdf...end block.&quot; }, { MsgKey::NOTERMS, &quot;Statistic requires at least one variable.&quot; }, { MsgKey::NOSAMPLES, &quot;PDF requires at least one sample space variable.&quot; }, { MsgKey::INVALIDSAMPLESPACE, &quot;PDF sample space specification incorrect. A &quot; &quot;non-empty list of sample space variables, must be followed by a &quot; &quot;colon, followed by a non-empty list of bin sizes (reals numbers), e.g., &quot; &quot;\x y : 0.1 0.2)\ }, { MsgKey::MALFORMEDSAMPLE, &quot;A PDF sample space variable must be a single &quot; &quot;upper or lowercase letter optionally followed by an integer. &quot; &quot;Multiple variables, specifying a multi-dimensional sample space, must &quot; &quot;be separated by white spaces.&quot; }, { MsgKey::INVALIDBINSIZE, &quot;PDF sample space bin size(s) specification &quot; &quot;incorrect. A non-empty list of sample space variables, must be followed &quot; &quot;by a colon, followed by a non-empty list of bin sizes(real numbers), &quot; &quot;e.g., \(x y :0.1 0.2)\&quot; }, { MsgKey::INVALIDEXTENT, &quot;PDF sample space extents specification &quot; &quot;incorrect. The semi-colon following the list of bin sizes, must be &quot; &quot;followed by a non-empty list of extents(real numbers), e.g., \(x y :&quot; &quot;0.1 0.2 ;0.0 1.0 0.2 0.9)\. The number of real numbers representing &quot; &quot;the sample space extents must be exactly twice the number of sample &quot; &quot;space dimensions, i.e., in this 2D example 4(2 pairs).&quot; }, { MsgKey::EXTENTLOWER, &quot;PDF sample space extents must be a pair of a &quot; &quot;smaller and a larger numerical value, in that order.&quot; }, { MsgKey::NOBINS, &quot;Need at least one sample space bin size, followed by a &quot; &quot;colon, in a PDF specification.&quot; }, { MsgKey::ZEROBINSIZE, &quot;Sample space bin size must be a real number and &quot; &quot;greater than zero.&quot; }, { MsgKey::MAXSAMPLES, &quot;The maximum number of sample space variables for a &quot; &quot;joint PDF is 3.&quot; }, { MsgKey::MAXBINSIZES, &quot;The maximum number of bins sizes for a joint PDF &quot; &quot;is 3.&quot;}, { MsgKey::MAXEXTENTS, &quot;The maximum number of optional sample space extents &quot; &quot;for a joint PDF is 3 pairs.&quot;}, { MsgKey::BINSIZES, &quot;The number of sample space variables for a PDF must &quot; &quot;equal the number of bin sizes given.&quot; }, { MsgKey::PDF, &quot;Syntax error while parsing PDF specification.&quot; }, { MsgKey::PDFEXISTS, &quot;PDF already exists. PDF identifiers must be unique.&quot;}, { MsgKey::BADPRECISION, &quot;Precision specification invalid. It should be a &quot; &quot;positive integer or the word \max\, selecting the maximum number of &quot; &quot;digits for the underyling floating point type.&quot;}, { MsgKey::PRECISIONBOUNDS, &quot;Precision specification out of bounds. It &quot; &quot;should be a positive integer between 1 and the maximum number of digits &quot; &quot;for the underyling floating point type on the machine.(Set \max\ for &quot; &quot;the maximum.)&quot;}, { MsgKey::UNFINISHED, &quot;Block started but not finished by the 'end' &quot; &quot;keyword.&quot; }, { MsgKey::VORTICAL_UNFINISHED, &quot;Specifying the vortical flow test problem &quot; &quot;requires the specification of parameters alpha, beta, and p0. The error&quot; &quot;is in the block finished above the line above.&quot; }, { MsgKey::BC_EMPTY, &quot;Error in the preceding block. Empty boundary &quot; &quot;condition specifications, e.g., 'sideset end', are not allowed.&quot; }, { MsgKey::WRONGSIZE, &quot;Error in the preceding line or block. The size of &quot; &quot;the parameter vector is incorrect.&quot; }, { MsgKey::HYDROTIMESCALES, &quot;Error in the preceding line or block. &quot; &quot;Specification of a 'hydrotimescales' vector missing.&quot; }, { MsgKey::HYDROPRODUCTIONS, &quot;Error in the preceding line or block. &quot; &quot;Specification of a 'hydroproductions' vector missing.&quot; }, { MsgKey::CHARMARG, &quot;Arguments starting with '+' are assumed to be inteded &quot; &quot;for the Charm++runtime system. Did you forget to prefix the command &quot; &quot;line with charmrun? If this warning persists even after running with &quot; &quot;charmrun, then Charm++does not understand it either. See the Charm++&quot; &quot;manual at http://charm.cs.illinois.edu/manuals/html/charm++/&quot; &quot;manual.html.&quot; } })</td></tr>
<tr class="memdesc:a2940f66c424b4074c2388f899fa8c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate parser errors to error messages.  <a href="namespacetk_1_1grm.html#a2940f66c424b4074c2388f899fa8c8de">More...</a><br /></td></tr>
<tr class="separator:a2940f66c424b4074c2388f899fa8c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49ed13578bd57b813ba6658f19dd8fc"><td class="memTemplParams" colspan="2">template&lt;class Stack , MsgType type, MsgKey key, class Input &gt; </td></tr>
<tr class="memitem:ac49ed13578bd57b813ba6658f19dd8fc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#ac49ed13578bd57b813ba6658f19dd8fc">tk::grm::Message</a> (Stack &amp;stack, const Input &amp;in)</td></tr>
<tr class="memdesc:ac49ed13578bd57b813ba6658f19dd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser error and warning message handler.  <a href="namespacetk_1_1grm.html#ac49ed13578bd57b813ba6658f19dd8fc">More...</a><br /></td></tr>
<tr class="separator:ac49ed13578bd57b813ba6658f19dd8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e2900a7098d52fcc0d875f80c48b8f"><td class="memTemplParams" colspan="2">template&lt;class Stack , template&lt; class &gt; class use, class Option , class DefaultStack , class Input , class... tags&gt; </td></tr>
<tr class="memitem:a89e2900a7098d52fcc0d875f80c48b8f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#a89e2900a7098d52fcc0d875f80c48b8f">tk::grm::store_option</a> (Stack &amp;stack, const Input &amp;in, const DefaultStack &amp;defaults)</td></tr>
<tr class="memdesc:a89e2900a7098d52fcc0d875f80c48b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put option (i.e., a <a class="el" href="classtk_1_1_toggle.html" title="Toggle is the base for an Option, doing generic searches. ">tk::Toggle</a>) in grammar state (or stack) at a position given by tags.  <a href="namespacetk_1_1grm.html#a89e2900a7098d52fcc0d875f80c48b8f">More...</a><br /></td></tr>
<tr class="separator:a89e2900a7098d52fcc0d875f80c48b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab83bd20afe2c1386bf4e95bd0e86776e"><td class="memItemLeft" align="right" valign="top">Print&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#ab83bd20afe2c1386bf4e95bd0e86776e">tk::grm::g_print</a></td></tr>
<tr class="separator:ab83bd20afe2c1386bf4e95bd0e86776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b809dbbd954026ab2bc003ec27a80f2"><td class="memItemLeft" align="right" valign="top">static ncomp_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2">tk::grm::field</a> = 0</td></tr>
<tr class="memdesc:a1b809dbbd954026ab2bc003ec27a80f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Out-of-struct storage of field ID for pushing terms for statistics.  <a href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2">More...</a><br /></td></tr>
<tr class="separator:a1b809dbbd954026ab2bc003ec27a80f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab631f9f35bdba1b71a2cff1112364971"><td class="memItemLeft" align="right" valign="top">static std::set&lt; char, <a class="el" href="structtk_1_1ctr_1_1_case_insensitive_char_less.html">tk::ctr::CaseInsensitiveCharLess</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971">tk::grm::depvars</a></td></tr>
<tr class="memdesc:ab631f9f35bdba1b71a2cff1112364971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser-lifetime storage for dependent variables selected.  <a href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971">More...</a><br /></td></tr>
<tr class="separator:ab631f9f35bdba1b71a2cff1112364971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf18699e85fe7ff02a1dfbb37d78977"><td class="memItemLeft" align="right" valign="top">static std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977">tk::grm::pdfnames</a></td></tr>
<tr class="memdesc:aadf18699e85fe7ff02a1dfbb37d78977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parser-lifetime storage for PDF names.  <a href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977">More...</a><br /></td></tr>
<tr class="separator:aadf18699e85fe7ff02a1dfbb37d78977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic, low-level grammar, re-used by specific grammars. </p>
<dl class="section author"><dt>Author</dt><dd>J. Bakosi, D. Frey </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Tue 10 Jan 2017 09:00:07 AM MST </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</dd></dl>
<p>Generic, low-level grammar. We use the Parsing Expression Grammar Template Library (PEGTL) to create the grammar and the associated parser. </p>

<p class="definition">Definition in file <a class="el" href="_common_grammar_8h_source.html">CommonGrammar.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5cfc0a80bcb9c742a4dd13252e8e70b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfc0a80bcb9c742a4dd13252e8e70b2">&#9670;&nbsp;</a></span>BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_common_grammar_8h_source.html#l00019">19</a> of file <a class="el" href="_common_grammar_8h_source.html">CommonGrammar.h</a>.</p>

</div>
</div>
<a id="add19bfd3b2b79f9086bc116a851c03a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add19bfd3b2b79f9086bc116a851c03a3">&#9670;&nbsp;</a></span>BOOST_MPL_LIMIT_METAFUNCTION_ARITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_MPL_LIMIT_METAFUNCTION_ARITY&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_common_grammar_8h_source.html#l00021">21</a> of file <a class="el" href="_common_grammar_8h_source.html">CommonGrammar.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 5 2017 05:40:16 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
