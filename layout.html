<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: Data layout design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Data layout design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="layout_req"></a>
Data layout requirements and design</h1>
<p>How should the particle properties should be stored in memory? How should the mesh field data (associated to nodes, elements, faces, etc. of a mesh) should be stored in memory? These are the single largest chunks of data a particle-, and/or mesh-based code operates on. The data layout, i.e., how the data is stored and organized in memory, determines how the data is accessed and potentially has a first-degree effect on overall performance.</p>
<h1><a class="anchor" id="layout_possibilities"></a>
Possibilities</h1>
<ol type="1">
<li><b>Unknown-major</b>, in which various physical properties, e.g., position, velocity, energy, etc., i.e., the unknowns in a solver, of a single particle or mesh fields are close to each other in memory. For example: [ x1, y1, z1, ..., x2, y2, z2, ..., x3, y3, z3, ... ] where the x* are governed by one equation (e.g., position), the y* are governed by another equation (e.g., velocity), and the z* are governed by a third equation (e.g., energy), etc. Here the first letter denotes a physical quantity, while the second is the particle number or mesh field ID. If the algorithm that advances the properties, unknowns, in time applies one equation at a time, the equations will access data by having to jump a distance that corresponds to the number of scalar physical variables per particle or mesh field. In the example, the update will have to jump as x1, x2, x3, ... are updated.</li>
<li><b>Property-major</b>, in which the same type of physical properties are close to each other in memory. For example, [ x1, x2, x3, ..., y1, y2, y3, ..., z1, z2, z3, ... ]. The legend here is the same as in unknown-major: the first letter denotes a physical quantity, while the second is the particle or mesh field number. If the algorithm that advances the properties in time applies one equation at a time, the equations will access data contiguously in memory as the properties are contiguously stored.</li>
</ol>
<h1><a class="anchor" id="layout_discussion"></a>
Discussion</h1>
<p>A property-major storage, case 2 above, seems to be the most efficient at first sight, as it stores data, as it is read and written by the equation algorithms, contiguously. However, data access is contiguous only if the particle properties (or data stored at mesh field IDs) are independent, i.e., if there is no coupling among the equations. Unfortunately, this is rarely the case, at least not for fluid dynamics. For example in a Lagrangian particle code, position is used by the velocity update, and velocity is required by the energy update. The same is true for a mesh-based solver, where the physical variables are couple, i.e., their update needs other physical variables at the same mesh field (and possibly others). Depending on the physical approximation, density (or mass) may be required for all equations. The stronger the equations are coupled the more very-far-reads are required for a given update with a property-major data layout. These far-reads are potentially almost always cache misses, as the property-major storage stores the physical variables for the same particle or mesh field very far in memory, e.g., the distance between x1 and y1 is the number of particles or mesh fields. While the unknown-major storage, case 1 above, inherently stores data non-contiguously, the distance between properties of a single particle (or a single mesh field) is relatively small, i.e., the number of properties, which may incure less cache misses as several particles (or nodes) but all of their properties could fit into cache.</p>
<p>Assuming strong coupling among the variables, the unknown-major storage will be favored, but it would be nice if the design allowed for both layouts, so depending on the type of equations the most appropriate layout could be selected. If such a design is maintanable, there is still a question wether the data layout selection should be done at compile-, or run-time.</p>
<h1><a class="anchor" id="layout_blaze"></a>
Assessment of the Blaze library that offers a similar choice</h1>
<p>Have looked at <a href="https://code.google.com/p/blaze-lib">https://code.google.com/p/blaze-lib</a> which implements row-, and column-major matrix classes based on a template argument. See, e.g., blaze-1.5/blaze/math/dense/StaticMatrix.h, which reveals that the template argument (bool) SO selects between row-, or column-major internal storage. Then SO is used at both compile-time (e.g., by the class-user, when instantiating the type of the matrix), as well as run-time (e.g., the implementation of isDefault()). Both compile-time and run-time usage of the SO template arguments are problematic:</p>
<ul>
<li>The compile-time usage duplicates a lot of code by having to provide similar implementations for the element-access operator() of StaticMatrix specialized to column-major. There is a generic implementation for SO for everthing that is agnostic of SO, and there is a specialization when SO is column-major.</li>
<li>The run-time usage also duplicates code by doing an if-test on SO in, e.g., isDefault(). Is there a better way of doing this? If there are only two types of data layout (unknown-, and property-major), code duplication should not be too much of an issue. However, the implementation of unknown-property data access must be absolutely zero run-time cost. This means the selection must be at compile-time and the element access must be absolutely invisible to the derived equation classes. In other words, there must be no re-implementation of a time-integrator for an equation just because the data access is different.</li>
</ul>
<h1><a class="anchor" id="layout_kokkos"></a>
Assessment of the Kokkos library that offers a similar choice</h1>
<p>Since the first implementation of the configurable data layout, described below, the Kokkos library, <a href="https://github.com/kokkos/kokkos,">https://github.com/kokkos/kokkos,</a> from Sandia National Labs, has been released. Kokkos appears to have all the requirements described here, and a lot more. It does have compile-time configurable data layouts, <em>views</em>, for the purpose of optimal data access on various compute devices, such as multi-core CPUs, many-core accelerators, and Graphics Processing Units. Kokkos appears to provide an excellent abstraction for data layout abstraction. However, Kokkos provides a lot more than just data layout abstraction: it can generate low level code for various devices using its configurable views. The currently available Kokkos back-ends are OpenMP, pthreads, and CUDA. Thus Kokkos provides abstractions for on-node, i.e., shared-memory, parallelism. While Kokkos has been successfully used in Charm++ code, at this point (Jan 2016) we opt for NOT adopting Kokkos' views and keep our original data layout abstractions, discussed below. The reasons:</p>
<ul>
<li>At this point we are too early in the development of Quinoa and its tools to be able to say that the current abstractions Charm++ provides are sufficient or not to strike the correct balance between performance and productivity. In particular, it could be possible that Charm++'s abstractions (using overdecomposition), which we use already, are enough. In that case, using a single abstraction for parallelism is preferable to two.</li>
<li>At this point we would really only need the compile-time configurable data layout abstractions from Kokkos and not the abstractions for loop-level shared-memory parallelism.</li>
</ul>
<p>As far I can tell, the views of an array in Kokkos provide a very similar abstraction for data layout and thus memory access what is described below.</p>
<h1><a class="anchor" id="layout_requirements"></a>
Requirements</h1>
<p>Is it possible to implement a compile-time configurable data-access policy via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes? <em>Yes</em>. See below.</p>
<p>Zero-cost is achieved via type-based compile-time polymorphism. This is controlled via a cmake variable.</p>
<p>The particle (or mesh field) data is a logically 3-dimensional array that stores the particle properties (or nodal unknowns).</p>
<p>For clarity, the discussion below will use the expression "particle" for a particle-code anad will not specifically mention nodal unknowns, stored at the nodes of a computational mesh. The former is for a particle-code, the latter is for a mesh-code. The data layout discussion is independent of whether particles or mesh field (nodes, cells, etc.) are used.</p>
<p>In principle there are a total of 6 permutations: </p><pre class="fragment">1. ParEqComp: [ particle ] [ equation ] [ component ]
2. ParCompEq: [ particle ] [ component ] [ equation ]
3. EqCompPar: [ equation ] [ component ] [ particle ]
4. EqParComp: [ equation ] [ particle ] [ component ]
5. CompEqPar: [ component ] [ equation ] [ particle ]
6. CompParEq: [ component ] [ particle ] [ equation ]
</pre><p>Of these 6 we only consider those where component follows equation. (For those layouts where equation follows component the access would be unnecessarily complicated by the potentially unequal number of components for different equations which is not known at compile-time and thus does not allow some optimizations.) This decision leaves us with the following choices: </p><pre class="fragment">1. ParEqComp: [ particle ] [ equation ] [ component ]
3. EqCompPar: [ equation ] [ component ] [ particle ]
4. EqParComp: [ equation ] [ particle ] [ component ]
</pre><p>Access is based on the 3 coordinates: particle, component, and offset. Particle is the particle ID, component denotes the given component of a vector equation, e.g., velocity has 3 components, a multi-material turbulent mix model governed by the Dirichlet SDE has K=N-1 scalars (components), and offset is determined by the relative position of the given equation compared to the other equations. Using these 3 coordinates the index calculations for the above 3 cases are: </p><pre class="fragment">1. ParEqComp: [ particle ] [ equation ] [ component ]

     baseptr + particle*nprop + offset + component,
</pre><p>where nprop is the total number of particle properties, e.g., 3 positions, 3 velocities, 5 scalars -&gt; nprop = 11. </p><pre class="fragment">3. EqCompPar: [ equation ] [ component ] [ particle ]

     baseptr + (offset+component)*npar + particle,
</pre><p>where npar is the total number of particles. </p><pre class="fragment">4. EqParComp: [ equation ] [ particle ] [ component ]

     baseptr + offset*npar + nce*particle + component,
</pre><p>where nce is the number of components for the given equation. Since this would require another function argument (besides particle, component, and offset), and it costs an integer-multiply more than the other two layouts, we dismiss this layout, and only implement the following two: </p><pre class="fragment">1. ParEqComp - Particle-major
3. EqCompPar - Equation-major
</pre><p>These options are exposed via a cmake variable and can be switched before a build.</p>
<h2>Data layout assembly </h2>
<p>This section documents the assembly code, produced by the compilers, of the implementation of the compile-time configurable particle-data-access policy discussed above. The implementation is via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes.</p>
<h1><a class="anchor" id="layout_zerocost"></a>
Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch</h1>
<p>Tags for selecting particle-, or property-major data layout policies:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> ParticleMajor = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> PropertyMajor = <span class="keyword">false</span>;</div></div><!-- fragment --><p>Implementation of data-layout wrappers:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> Major &gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="namespacetut.html#a9e431d4b374e5080860732a6b38a233a">Data</a> {</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">   <span class="comment">// Transform a compile-time bool into a type</span></div><div class="line">   <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> m &gt;</div><div class="line">   <span class="keyword">struct </span>int2type {</div><div class="line">     <span class="keyword">enum</span> { value = m };</div><div class="line">   };</div><div class="line"></div><div class="line">   <span class="comment">// Overloads for particle-, and property-major accesses</span></div><div class="line">   <span class="keyword">inline</span></div><div class="line">   <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&amp; access( <span class="keywordtype">int</span> particle, <span class="keywordtype">int</span> property, int2type&lt;ParticleMajor&gt; ) {</div><div class="line">     <span class="keywordflow">return</span> *(m_ptr + particle*m_nprop + m_offset + property);</div><div class="line">   }</div><div class="line">   <span class="keyword">inline</span></div><div class="line">   <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&amp; access( <span class="keywordtype">int</span> particle, <span class="keywordtype">int</span> property, int2type&lt;PropertyMajor&gt; ) {</div><div class="line">     <span class="comment">// This is the same for now, not callsed, irrelevant in zero-cost-test</span></div><div class="line">     <span class="keywordflow">return</span> *(m_ptr + particle*m_nprop + m_offset + property);</div><div class="line">   }</div><div class="line"></div><div class="line">   <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>* <span class="keyword">const</span> m_ptr;</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> m_nprop;</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> m_offset;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Constructor</span></div><div class="line">    <a class="code" href="namespacetut.html#a9e431d4b374e5080860732a6b38a233a">Data</a>( <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>* <span class="keyword">const</span> ptr, <span class="keywordtype">int</span> nprop, <span class="keywordtype">int</span> offset ) :</div><div class="line">      m_ptr(ptr), m_nprop(nprop), m_offset(offset) {}</div><div class="line"></div><div class="line">    <span class="comment">// Access dispatch</span></div><div class="line">    <span class="keyword">inline</span> <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>&amp; operator()( <span class="keywordtype">int</span> particle, <span class="keywordtype">int</span> property ) {</div><div class="line">      <span class="keywordflow">return</span> access( particle, property, int2type&lt;Major&gt;() );</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="layout_test"></a>
Test of zero-cost</h1>
<p>Add to Dirichlet constructor:</p>
<div class="fragment"><div class="line">ParticleProperties&lt; Layout &gt; d( particles, m_nprop, m_offset );</div><div class="line">Model::aa = d( 34, 3 );</div><div class="line">Model::bb = *(m_particles + 34*m_nprop + m_offset + 3);</div></div><!-- fragment --><p>Add to Model:</p>
<div class="fragment"><div class="line">Model {</div><div class="line">  ...</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> aa;</div><div class="line">    <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> bb;</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Add to Physics constructor after m_mix is instantiated:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; m_mix-&gt;aa &lt;&lt; m_mix-&gt;bb;</div></div><!-- fragment --><p>All the above so the optimizing compiler cannot entirely optimize the assignments of <em>aa</em> and <em>bb</em> away.</p>
<h1><a class="anchor" id="layout_debugasm"></a>
Debug assembly</h1>
<p>Generated DEBUG assembly code of the assignments of <em>aa</em> (line 42) and <em>bb</em> (line 43) in Dirichlet's constructor, with clang -g -S -mllvm &ndash;x86-asm-syntax=intel, gnu and intel generate very similar code:</p>
<div class="fragment"><div class="line">...</div><div class="line">     .loc    143 42 20  # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:42:20</div><div class="line">.Ltmp27038:</div><div class="line">     lea     RDI, QWORD PTR [RBP - 56]</div><div class="line">     mov     ESI, 34</div><div class="line">     mov     EDX, 3</div><div class="line">     call    _ZN6quinoa4DataILb1EEclEii</div><div class="line">.Ltmp27039:</div><div class="line">     mov     QWORD PTR [RBP - 176], RAX # 8-byte Spill</div><div class="line">     jmp     .LBB2550_7</div><div class="line">.LBB2550_7:</div><div class="line">     mov     RAX, QWORD PTR [RBP - 176] # 8-byte Reload</div><div class="line">     movsd   XMM0, QWORD PTR [RAX]</div><div class="line">     mov     RCX, QWORD PTR [RBP - 64] # 8-byte Reload</div><div class="line">     movsd   QWORD PTR [RCX + 8], XMM0</div><div class="line">     .loc    143 43 0    # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:43:0</div><div class="line">     mov     RDX, QWORD PTR [RCX + 32]</div><div class="line">     imul    ESI, DWORD PTR [RCX + 48], 34</div><div class="line">     movsxd  RDI, ESI</div><div class="line">     shl     RDI, 3</div><div class="line">     add     RDX, RDI</div><div class="line">     movsxd  RDI, DWORD PTR [RCX + 52]</div><div class="line">     movsd   XMM0, QWORD PTR [RDX + 8*RDI + 24]</div><div class="line">     movsd   QWORD PTR [RCX + 16], XMM0</div><div class="line">...</div></div><!-- fragment --><p>Line 42 translates to register loads and a function call into tk::ParticleProperties, while line 43 translates to some integer arithmetic of the address and loads.</p>
<h1><a class="anchor" id="layout_excerpt1"></a>
Excerpt from the Intel® 64 and IA-32 Architectures Software Developer Manual</h1>
<blockquote class="doxtable">
<p>The LEA (load effective address) instruction computes the effective address in memory (offset within a segment) of a source operand and places it in a general-purpose register. This instruction can interpret any of the processor’s addressing modes and can perform any indexing or scaling that may be needed. It is especially useful for initializing the ESI or EDI registers before the execution of string instructions or for initializing the EBX register before an XLAT instruction.</p>
<p>The MOVSXD instruction operates on 64-bit data. It sign-extends a 32-bit value to 64 bits. This instruction is not encodable in non-64-bit modes.</p>
<p>A common type of operation on packed integers is the conversion by zero- or sign-extension of packed integers into wider data types. SSE4.1 adds 12 instructions that convert from a smaller packed integer type to a larger integer type (PMOVSXBW, PMOVZXBW, PMOVSXBD, PMOVZXBD, PMOVSXWD, PMOVZXWD, PMOVSXBQ, PMOVZXBQ, PMOVSXWQ, PMOVZXWQ, PMOVSXDQ, PMOVZXDQ). The source operand is from either an XMM register or memory; the destination is an XMM register.</p>
<p>IMUL Signed multiply. The IMUL instruction multiplies two signed integer operands. The result is computed to twice the size of the source operands; however, in some cases the result is truncated to the size of the source operands.</p>
<p>SAL/SHL Shift arithmetic left/Shift logical left. The SAL (shift arithmetic left), SHL (shift logical left), SAR (shift arithmetic right), SHR (shift logical right) instructions perform an arithmetic or logical shift of the bits in a byte, word, or doubleword. The SAL and SHL instructions perform the same operation. They shift the source operand left by from 1 to 31 bit positions. Empty bit positions are cleared. The CF flag is loaded with the last bit shifted out of the operand. </p>
</blockquote>
<h1><a class="anchor" id="layout_optasm"></a>
Optimized assembly</h1>
<p>Generated RELWITHDEBINFO assembly code of the assignments of <em>aa</em> (line 42) and <em>bb</em> (line 43) in Dirichlet's constructor, with clang -O2 -g DNDEBUG -S -mllvm &ndash;x86-asm-syntax=intel, gnu and intel generate very similar optimized code:</p>
<div class="fragment"><div class="line">...</div><div class="line">     .loc    144 42 20  # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:42:20</div><div class="line">     movsd   XMM0, QWORD PTR [R14 + 8*RAX + 24]</div><div class="line">     movsd   QWORD PTR [R13 + 8], XMM0</div><div class="line">     .loc    144 43 0    # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:43:0</div><div class="line">     mov     RCX, QWORD PTR [R13 + 32]</div><div class="line">     movsd   XMM0, QWORD PTR [RCX + 8*RAX + 24]</div><div class="line">     movsd   QWORD PTR [R13 + 16], XMM0</div><div class="line">...</div></div><!-- fragment --><p>Both lines 42 and 43 translate to very similar SSE loads with pointer arithmetic, i.e., line 42 costs the same as line 43.</p>
<h1><a class="anchor" id="layout_excerpt2"></a>
Excerpt from the Intel® 64 and IA-32 Architectures Software Developer Manual</h1>
<blockquote class="doxtable">
<p>The MOVS instruction moves the string element addressed by the ESI register to the location addressed by the EDI register. The assembler recognizes three “short forms” of this instruction, which specify the size of the string to be moved: MOVSB (move byte string), MOVSW (move word string), and MOVSD (move doubleword string).</p>
<p>The MOVSD (move scalar double-precision floating-point) instruction transfers a 64-bit double-precision floating- point operand from memory to the low quadword of an XMM register or vice versa, or between XMM registers. Alignment of the memory address is not required, unless alignment checking is enabled. </p>
</blockquote>
<h2>Data layout benchmark </h2>
<p>This section documents the benchmark of the implementation of the compile-time configurable particle-data-access policy discussed above. The implementation is via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes.</p>
<h1><a class="anchor" id="layout_input"></a>
Control file used for benchmark</h1>
<p>We will integrate for the duration of a 100,000 time steps a system of 100 coupled non-linear stochastic differential equations (SDEs) whose statistically stationary solution convergese to the Dirichlet distribution and measure the wall-clock time. For more on the Dirichlet SDE, see <a class="el" href="_dirichlet_8h.html" title="Dirichlet SDE. ">src/DiffEq/Dirichlet.h</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacewalker.html">walker</a></div><div class="line"></div><div class="line">  nstep 100000  # Max number of time steps</div><div class="line">  term  140.0   # Max time</div><div class="line">  dt    0.05    # Time step size</div><div class="line">  npar  40000   # Number of particles</div><div class="line"></div><div class="line">  ttyi  100     # TTY output interval</div><div class="line"></div><div class="line">  rngs</div><div class="line">    mkl_mrg32k3a seed 0 end</div><div class="line">  end</div><div class="line"></div><div class="line">  dirichlet</div><div class="line">    ncomp 100  # = K = N-1</div><div class="line">    b     0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5</div><div class="line">    end</div><div class="line">    S     0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4</div><div class="line">    end</div><div class="line">    kappa 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3</div><div class="line">    end</div><div class="line">    rng mkl_mrg32k3a</div><div class="line">  end</div><div class="line"></div><div class="line">  statistics    # Estimate statistics</div><div class="line">    &lt;Y1&gt;        # <a class="code" href="namespacetk_1_1ctr.html#a8bb4e2fb54817366873d9c0455b47dd5">mean</a> of Y1</div><div class="line">    &lt;Y2&gt;</div><div class="line">    &lt;y1y1&gt;      # <a class="code" href="namespacetk_1_1ctr.html#a2265bca65a531ff6394a09bc48beb975">variance</a> of Y1 = &lt;(Y1-&lt;Y1&gt;)^2&gt; = &lt;y1^2&gt;</div><div class="line">    &lt;y2y2&gt;</div><div class="line">    &lt;y1y2&gt;</div><div class="line">  end</div><div class="line"></div><div class="line">end</div></div><!-- fragment --><h1><a class="anchor" id="layout_ptr"></a>
Ptr - Working with raw pointers</h1>
<p>This algorithm gets the starting raw pointer from which the given particle data is (contiguously) accessible in memory and simply adds integers to the address to access and update the 100 components specified above. The algorithm assumes a particular data layout - it only works with the particle-major storage - a logically 3-dimensional array with [ particle ] [ sde ] [ component ].</p>
<p><b>Layout-dependent algorithm:</b></p>
<div class="fragment"><div class="line"><span class="comment">//! Advance particles</span></div><div class="line"><span class="comment"></span><span class="keywordtype">void</span> advance(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> tid, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> dt)<span class="keyword"> override </span>{</div><div class="line">  <span class="comment">// Get access to particle scalars</span></div><div class="line">  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a>* y = m_particles.ptr() + p*m_nprop + m_offset;</div><div class="line"></div><div class="line">  <span class="comment">// Compute Nth scalar</span></div><div class="line">  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> yn = 1.0 - y[0];</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;m_ncomp; ++i) yn -= y[i];</div><div class="line"></div><div class="line">  <span class="comment">// Generate Gaussian random numbers with zero mean and unit variance</span></div><div class="line">  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> dW[m_ncomp];</div><div class="line">  m_rng-&gt;gaussian( tid, m_ncomp, dW );</div><div class="line"></div><div class="line">  <span class="comment">// Advance first m_ncomp (K=N-1) scalars</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_ncomp; ++i) {</div><div class="line">    <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d = m_k[i]*y[i]*yn*dt;</div><div class="line">    <span class="keywordflow">if</span> (d &gt; 0.0) d = sqrt(d); <span class="keywordflow">else</span> d = 0.0;</div><div class="line">    y[i] += 0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i])*y[i])*dt + d*dW[i];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="layout_par"></a>
Par - Access via particle-major layout policy</h1>
<p>This algorithm accesses particle data via the wrapper class, tk::ParticleProperties, in a data-layout-agnostic fashion. Access itself via this class is demonstrably "zero-cost", i.e., an optmizing compiler completely optimizes the abstraction away: see <a href="layout_assembly.html">assembly</a> for the assembly generated by 3 compilers. However, writing an SDE-advance algorithm in a data-layout-agnostic manner, requires index calculations at every particle-access compared to working with raw pointers, as described above. Thus the following tests are designed to measure only the additional index calculations that the layout-agnostic access entails.</p>
<p><b>Layout-independent algorithm:</b></p>
<div class="fragment"><div class="line"><span class="comment">//! Advance particles</span></div><div class="line"><span class="comment"></span><span class="keywordtype">void</span> advance(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> tid, <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> dt)<span class="keyword"> override </span>{</div><div class="line">  <span class="comment">// Compute Nth scalar</span></div><div class="line">  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> yn = 1.0 - m_particles(p, 0, m_offset);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;m_ncomp; ++i) yn -= m_particles(p, i, m_offset);</div><div class="line"></div><div class="line">  <span class="comment">// Generate Gaussian random numbers with zero mean and unit variance</span></div><div class="line">  <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> dW[m_ncomp];</div><div class="line">  m_rng-&gt;gaussian( tid, m_ncomp, dW );</div><div class="line"></div><div class="line">  <span class="comment">// Advance first m_ncomp (K=N-1) scalars</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_ncomp; ++i) {</div><div class="line">    <a class="code" href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575">tk::real</a> d = m_k[i] * m_particles(p, i, m_offset) * yn * dt;</div><div class="line">    <span class="keywordflow">if</span> (d &gt; 0.0) d = sqrt(d); <span class="keywordflow">else</span> d = 0.0;</div><div class="line">    m_particles(p, i, m_offset) +=</div><div class="line">      0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i]) * m_particles(p, i, m_offset) )*dt</div><div class="line">      + d*dW[i];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="layout_comparison"></a>
Comparison of the algorithms</h1>
<p>DEBUG mode is -O0 and does not optimize function calls away for all of three compilers tested. RELEASE modes is -O3 and the abstraction is completely optimized away. However, index calculations still remain compared to a layout-dependent advance algorithm.</p>
<p>Total time measured in micro-seconds, run on a Lenovo laptop with Intel Core i7, 8 compute cores: </p><table class="doxtable">
<tr>
<th align="left">Run </th><th align="right">Ptr </th><th align="right">Par </th><th align="right">Par/Ptr  </th></tr>
<tr>
<td align="left">clang/DEBUG </td><td align="right">150350236 </td><td align="right">338851735 </td><td align="right">2.2537 x slowdown </td></tr>
<tr>
<td align="left">clang/RELEASE </td><td align="right">98157742 </td><td align="right">104077139 </td><td align="right">1.0603 x slowdown </td></tr>
<tr>
<td align="left">DEBUG/RELEASE </td><td align="right">1.5317 x speedup </td><td align="right">3.2558 x speedup </td><td align="right">n/a </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="left">Run </th><th align="right">Ptr </th><th align="right">Par </th><th align="right">Par/Ptr  </th></tr>
<tr>
<td align="left">gnu/DEBUG </td><td align="right">161603164 </td><td align="right">386646353 </td><td align="right">2.3926 x slowdown </td></tr>
<tr>
<td align="left">gnu/RELEASE </td><td align="right">94747953 </td><td align="right">98187568 </td><td align="right">1.0363 x slowdown </td></tr>
<tr>
<td align="left">DEBUG/RELEASE </td><td align="right">1.7056 x speedup </td><td align="right">3.9378 x speedup </td><td align="right">n/a </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="left">Run </th><th align="right">Ptr </th><th align="right">Par </th><th align="right">Par/Ptr  </th></tr>
<tr>
<td align="left">intel/DEBUG </td><td align="right">171691440 </td><td align="right">608407412 </td><td align="right">3.5436 x slowdown </td></tr>
<tr>
<td align="left">intel/RELEASE </td><td align="right">90059133 </td><td align="right">89892665 </td><td align="right">0.99815 x speedup </td></tr>
<tr>
<td align="left">DEBUG/RELEASE </td><td align="right">1.9064 x speedup </td><td align="right">6.7682 x speedup </td><td align="right">n/a </td></tr>
</table>
<h1><a class="anchor" id="layout_discussion"></a>
Discussion</h1>
<ul>
<li>As expected, inlining has a significant effect on performance: going from DEBUG to RELEASE mode yields a significant speedup with all three compilers, see last, DEBUG/RELEASE, rows.</li>
<li>As expected, the additional index calculations required by layout-agnostic access do take a performance hit: though only 6% with clang, and 3% with gnu, see last, Par/Ptr, columns.</li>
<li>Surprisingly, the layout-agnostic access is even a tiny bit faster than the layout-dependent algorithm with the intel compiler with -O3.</li>
</ul>
<h1><a class="anchor" id="layout_conclusion"></a>
Conclusion</h1>
<p>As this is not a significant performance hit, the equation advancement algorithms and general particle data access are implemented in a data-layout-independent fashion. The data layout can be changed at compile time. Access will be abstracted (and optimized) away.</p>
<p>Note that the above discussion is independent of whether a particle-code, or a mesh-code is used. From the data layout viewpoint the particle-major and meshfield-major are equivalent and in the code, in <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">tk::Data</a>, called Unknown-major. See src/Base/Data, and its specializations in src/Base/MeshNodes.h and <a class="el" href="_particles_8h.html" title="Particles used to store particle data. ">src/Base/Particles.h</a>. The data layouts for mesh-fields and particles can be configured independently at compile time.</p>
<p>For the implementation see the <a class="el" href="classtk_1_1_data.html" title="Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch. ">tk::Data</a>.</p>
<hr/>
 <div><small> <em>Page last updated:</em> Sat 17 Sep 2016 10:26:02 AM MDT <em>Copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.</em> </small></div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 3 2017 06:24:27 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
