<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: /tmp/TeamCity-14/work/821a9fd6f64749d9/src/LinSys/Solver.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3ca9c9eb36ab3ecb75ba69910724f6da.html">LinSys</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Solver.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Charm++ chare linear system merger group to solve a linear system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;iosfwd&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &quot;Types.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_tags_8h_source.html">Tags.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_exception_8h_source.html">Exception.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_p_u_p_util_8h_source.html">PUPUtil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_fields_8h_source.html">Fields.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_matrix_8h_source.html">HypreMatrix.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_vector_8h_source.html">HypreVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hypre_solver_8h_source.html">HypreSolver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_vector_reducer_8h_source.html">VectorReducer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_hash_map_reducer_8h_source.html">HashMapReducer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_diag_reducer_8h_source.html">DiagReducer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_tagged_tuple_8h_source.html">TaggedTuple.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="solver_8decl_8h_source.html">NoWarning/solver.decl.h</a>&quot;</code><br />
<code>#include &quot;solver.def.h&quot;</code><br />
</div>
<p><a href="_solver_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_solver.html">tk::Solver&lt; WorkerProxy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetk"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html">tk</a></td></tr>
<tr class="memdesc:namespacetk"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toolkit declarations and definitions for general purpose utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_solver_8h.html#a6ec0c67374eb34a66c0f5ca4ecd7d163">CK_TEMPLATES_ONLY</a></td></tr>
<tr class="separator:a6ec0c67374eb34a66c0f5ca4ecd7d163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Charm++ chare linear system merger group to solve a linear system. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2015, J. Bakosi, 2016-2017, Los Alamos National Security, LLC.</dd></dl>
<p>Charm++ chare linear system merger group used to collect and assemble the left hand side matrix (lhs), the right hand side (rhs) vector, and the solution (unknown) vector from individual worker chares. Beside collection and assembly, the system is also solved. The solution is outsourced to hypre, an MPI-only library. Once the solution is available, the individual worker chares are updated with the new solution.</p>
<p>This class assembles and solves two linear systems, whose rhs vectors may change during time stepping. One of the two linear systems is called a high-order and the other one is the low-order linear system.</p>
<p>Characteristics of the low-order linear system: (1) the left hand side matrix is diagonal, (2) the right hand side vector is a combination of the high-order right hand side vector and another vector, assembled separately (and overlapped with that of the high-order system). This dual system solution is done here as required by the flux-corrected transport algorithm used for transport equations in inciter.</p>
<p>The implementation uses the Charm++ runtime system and is fully asynchronous, overlapping computation and communication. The algorithm utilizes the structured dagger (SDAG) Charm++ functionality. The high-level overview of the algorithm structure and how it interfaces with Charm++ is discussed in the Charm++ interface file <a class="el" href="solver_8ci.html">src/LinSys/solver.ci</a>.</p>
<h4>Call graph</h4>
<p>The following is a directed acyclic graph (DAG) that outlines the asynchronous algorithm implemented in this class The detailed discussion of the algorithm is given in the Charm++ interface file <a class="el" href="solver_8ci.html">solver.ci</a>. On the DAG orange fills denote global synchronization points that contain or eventually lead to global reductions. Dashed lines are potential shortcuts that allow jumping over some of the task-graph under some circumstances or optional code paths (taken, e.g., only in DEBUG mode). See the detailed discussion in linsysmrger.ci. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="1384" height="563"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
 <div class="fragment"><div class="line">// *****************************************************************************</div><div class="line">/*!</div><div class="line">  \file      src/LinSys/solver.ci</div><div class="line">  \copyright 2012-2015, J. Bakosi, 2016-2017, Los Alamos National Security, LLC.</div><div class="line">  \brief     Charm++ module interface file for merging a linear system</div><div class="line">  \details   Charm++ module interface file for merging a linear system. See more</div><div class="line">     in src/LinSys/Solver.h.</div><div class="line">*/</div><div class="line">// *****************************************************************************</div><div class="line"></div><div class="line">module solver {</div><div class="line"></div><div class="line">  namespace tk {</div><div class="line"></div><div class="line">    // List all possible specializations of templated chare to instantiate</div><div class="line">    // registration and delivery of code for the individual specializations</div><div class="line"></div><div class="line">    // Will specialize linear system solver for CH</div><div class="line">    chare Solver&lt; inciter::CProxy_CG &gt;;</div><div class="line"></div><div class="line">    // Solver is templated so that the same code (parameterized by the type</div><div class="line">    // given by the template argument, WorkerProxy, can be generated for</div><div class="line">    // different types of proxies. Howver, all possible specializations must be</div><div class="line">    // listed above to ensure that Charm++ generates correct code.</div><div class="line">    template&lt; class WorkerProxy &gt;</div><div class="line">    group Solver {</div><div class="line">      entry Solver( const std::vector&lt; CkCallback &gt;&amp; cb,</div><div class="line">                    const WorkerProxy&amp; worker,</div><div class="line">                    const std::map&lt; int,</div><div class="line">                      std::vector&lt; std::size_t &gt; &gt;&amp; side,</div><div class="line">                    std::size_t ncomp,</div><div class="line">                    bool feedback );</div><div class="line">      initnode void registerBCMerger();</div><div class="line">      entry void bounds( int pe, std::size_t lower, std::size_t upper );</div><div class="line">      entry void enable_wait4rhs();</div><div class="line">      entry [expedited] void addrow( int fromch,</div><div class="line">                         int frompe,</div><div class="line">                         const std::set&lt; std::size_t &gt;&amp; row );</div><div class="line">      entry void recrow();</div><div class="line">      entry [reductiontarget] void addbc( CkReductionMsg* msg );</div><div class="line">      entry [expedited] void addsol( int fromch,</div><div class="line">                         const std::map&lt; std::size_t,</div><div class="line">                                         std::vector&lt; tk::real &gt; &gt;&amp; solution );</div><div class="line">      entry [expedited] void addlhs( int fromch,</div><div class="line">        const std::map&lt; std::size_t,</div><div class="line">                        std::map&lt; std::size_t,</div><div class="line">                                  std::vector&lt; tk::real &gt; &gt; &gt;&amp; lhs );</div><div class="line">      entry [expedited] void addrhs( int fromch,</div><div class="line">                         const std::map&lt; std::size_t,</div><div class="line">                                         std::vector&lt; tk::real &gt; &gt;&amp; rhs );</div><div class="line">      entry [expedited] void addlowrhs( int fromch,</div><div class="line">                            const std::map&lt; std::size_t,</div><div class="line">                                            std::vector&lt; tk::real &gt; &gt;&amp; lorhs );</div><div class="line">      entry [expedited] void addlowlhs( int fromch,</div><div class="line">                            const std::map&lt; std::size_t,</div><div class="line">                                            std::vector&lt; tk::real &gt; &gt;&amp; lolhs );</div><div class="line">      entry void adddiag( int fromch,</div><div class="line">                          std::map&lt; std::size_t,</div><div class="line">                           std::vector&lt; std::vector&lt; tk::real &gt; &gt; &gt;&amp; solution );</div><div class="line">      entry void rowsreceived();</div><div class="line"></div><div class="line">      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/</div><div class="line">      // charm++/manual.html, Sec. &quot;Structured Control Flow: Structured Dagger&quot;.</div><div class="line"></div><div class="line">      // High-level overview of the dependency and asynchronous call structure</div><div class="line">      // ---------------------------------------------------------------------</div><div class="line">      //</div><div class="line">      // Directed Acyclic Graph (DAG):</div><div class="line">      // -----------------------------</div><div class="line">      //</div><div class="line">      // See src/LinSys/Solver.h.</div><div class="line">      //</div><div class="line">      // Interpretation of the DAG in src/LinSys/Solver.h</div><div class="line">      // ------------------------------------------------------</div><div class="line">      // Control flow is from left to right and top to bottom.</div><div class="line">      //</div><div class="line">      // We start out with all worker chares contributing their porition of the</div><div class="line">      // global row IDs that each work on. This is labelled ChRow. The worker</div><div class="line">      // chares also contribute, in parallel, their portion of the global node</div><div class="line">      // ID lists at which they can set boundary conditions, labelled, ChBCs.</div><div class="line">      // Once both row IDs and BC node lists are received on Solver, we do</div><div class="line">      // a global reduction to Transport::rowcomplete() which spawns two</div><div class="line">      // broadcasts: (1) Solver::rowsreceived(), and (2) worker::init().</div><div class="line">      //</div><div class="line">      // Solver::rowsreceived() path: The member function</div><div class="line">      // tk::Solver::rowsreceived(), labeled Ver in the task-graph,</div><div class="line">      // triggers and performs the following tasks: (1) Verification that</div><div class="line">      // ensures consistent global row IDs. This step only happens in DEBUG</div><div class="line">      // mode: VerRow is simply an Assert in member function rowsreceived). (2)</div><div class="line">      // The second step in tk::Solver::rowsreceived() initiates is</div><div class="line">      // building Hypre data from the global row indices received, labeled</div><div class="line">      // HypreRow.</div><div class="line">      //</div><div class="line">      // Worker::init() path: Once the row IDs are contributed,</div><div class="line">      // tk::Transporter::rowcomplete(), not only spaws</div><div class="line">      // tk::Solver::rowsreceived() but also issues a broadcast to the</div><div class="line">      // worker chares to start initializing their system. This is started with</div><div class="line">      // a call to the init() member function of the worker. The tasks done in</div><div class="line">      // init() include setting initial and boundary conditions, sending</div><div class="line">      // unknown/solution vectors for assembly to Solver, start computing</div><div class="line">      // the minimum time step size, outputing initial field data to file, start</div><div class="line">      // computing the left hand sides for both the high-, and low-order linear</div><div class="line">      // systems, and sending all this for linear system assembly. The</div><div class="line">      // contribution goes to those Linear System Merger group branch (one per</div><div class="line">      // CPU) the workers happen to reside on. These steps are denoted by ChSol,</div><div class="line">      // ChLhs, and ChLoLhs in the graph above, and the contributions/assembly</div><div class="line">      // is performed by the member functions charesol(), charelhs(), and</div><div class="line">      // charelolhs(), respectively.</div><div class="line">      //</div><div class="line">      // Among other tasks, worker::init(), discussed above, also start</div><div class="line">      // computing the minimum time step sizes based on all PDEs integrated.</div><div class="line">      // Once a worker has finished with that task, it sends it contribution of</div><div class="line">      // the smallest dt for computing a global minimum in Transporter::dt(),</div><div class="line">      // which then spawns a broadcast to the workers to start advancing their</div><div class="line">      // PDEs, which consists of computing the right hand sides for both the</div><div class="line">      // high-, and low-order linear systems, ChRhs, ChLoRhs. These right hand</div><div class="line">      // sides can only be comnputed if the dt is available.</div><div class="line">      //</div><div class="line">      // Once the collection of the right hand side vector, ChRhs, is done, we</div><div class="line">      // set boundary conditions on the RHS vector, RhsBC. Once the collection</div><div class="line">      // of the left hand side matrix, ChLhs, is done, we set boundary</div><div class="line">      // conditions on the LHS matrix, LhsBC.</div><div class="line">      //</div><div class="line">      // High-order solution only: Once each of the tasks, ChSol, LhsBC, and</div><div class="line">      // RhsBC, (not all at the same time but separately) are done, we continue</div><div class="line">      // by converting these data structures to a format that Hypre expects,</div><div class="line">      // done in hypresol(), hyprelhs(), and hyprerhs(), denoted by similars</div><div class="line">      // labels in the graph. These functions basically flatten the C++ data</div><div class="line">      // structures to C-style arrays and linked arrays (for the matrix). Note</div><div class="line">      // that the left and right hand sides can only begin to be converted to</div><div class="line">      // Hypre data format if the boundary conditions have also been applied on</div><div class="line">      // each.</div><div class="line">      //</div><div class="line">      // High-order solution only: Once the tasks, HypreSol, HypreLhs, HypreRhs,</div><div class="line">      // (not all at the same time but separately) are done and the Hypre data</div><div class="line">      // structure for the row IDs are complete, we continue by assigning the</div><div class="line">      // flattened data structures (more precisely, their pointers) to the Hypre</div><div class="line">      // vectors and Hypre matrix. These are denoted FillSol, FillLhs, and</div><div class="line">      // FillRhs in the DAG and correspond to the member functions sol(), lhs(),</div><div class="line">      // and rhs().</div><div class="line">      //</div><div class="line">      // High-order solution only: Once the tasks, FillSol, FillLhs, FIllRhs,</div><div class="line">      // (not all at the same time, but separately) are, we continue by calling</div><div class="line">      // the Hypre &quot;assembly&quot; routines for the solution vector, the left hand</div><div class="line">      // side matrix, and the right hand side vector. These are denoted by</div><div class="line">      // AsmSol, AsmLhs, and AsmRhs in the DAG, and performed by the member</div><div class="line">      // functions assemblesol(), assemblelhs(), and assemblerhs(),</div><div class="line">      // respectively.</div><div class="line">      //</div><div class="line">      // High-order solution only: Once the assembly of the solution (unknown)</div><div class="line">      // vector, the left hand side matrix, and the right hand side vector are</div><div class="line">      // all done (on a CPU), labels AsmSol, AsmLhs, AsmRhs, respectively, we</div><div class="line">      // call the solve() member function which solves the high-order linear</div><div class="line">      // system by calling Hypre and also updates the high-order solution, i.e.,</div><div class="line">      // propagates the new solution back to the worker chares, labeled Upd.</div><div class="line">      //</div><div class="line">      // Low-order solution only: The low-order solution is performed once the</div><div class="line">      // boundary conditions have been set on the high-order right hand side</div><div class="line">      // vector (RhsBC), the low-order rhs vector, combined with the high-order</div><div class="line">      // rhs (LoRhs) has been ready, and the low-order left hand side (LoLhs)</div><div class="line">      // are all complete. The solution of the low-order system is a simple</div><div class="line">      // back-substitution, since the system is assumed diagonal. Note also,</div><div class="line">      // that due to the way FluxCorrector::aec() computes the antidiffusive</div><div class="line">      // element contributions and the way it applies the limiter in</div><div class="line">      // FluxCorrector::lim(), there is no need to set Dirichlet boundary</div><div class="line">      // conditions on the low-order system. See more details in</div><div class="line">      // FluxCorrector::aec().</div><div class="line">      //</div><div class="line">      // A word on multiple invokation of SDAG triggers: As the commit message</div><div class="line">      // of b79ea29 explains, the &quot;triggers&quot;, such as hyprerow_complete(),</div><div class="line">      // enumerated below, at threir call site should be thought of as messages</div><div class="line">      // being put in some message queue and consumed at &#39;when&#39; clauses wherever</div><div class="line">      // they appear. If they appear in multiple when clauses, they consume</div><div class="line">      // multple messages, thus they have to be triggered multiple times. See</div><div class="line">      // also</div><div class="line">      // https://lists.cs.illinois.edu/lists/arc/charm/2016-09/msg00002.html.</div><div class="line"></div><div class="line">      entry void wait4row() {</div><div class="line">        when row_complete() serial &quot;row&quot; {</div><div class="line">          Group::contribute( m_cb.get&lt; tag::row &gt;() ); } };</div><div class="line"></div><div class="line">      entry void wait4lhsbc() {</div><div class="line">        when lhs_complete(), bc_complete_lhs() serial &quot;lhsbc&quot; { lhsbc(); } };</div><div class="line">      entry void wait4rhsbc() {</div><div class="line">        when rhs_complete(), bc_complete_rhs(), lhsbc_complete()</div><div class="line">          serial &quot;rhsbc&quot; { rhsbc(); } };</div><div class="line"></div><div class="line">      entry void wait4sol() {</div><div class="line">        when sol_complete() serial &quot;hypresol&quot; { hypresol(); } };</div><div class="line">      entry void wait4lhs() {</div><div class="line">        when lhsbc_complete() serial &quot;hyprelhs&quot; { hyprelhs(); } };</div><div class="line">      entry void wait4rhs() {</div><div class="line">        when rhsbc_complete() serial &quot;hyprerhs&quot; { hyprerhs(); } };</div><div class="line"></div><div class="line">      entry void wait4hypresol() {</div><div class="line">        when hypresol_complete(), hyprerow_complete() serial &quot;sol&quot; { sol(); } };</div><div class="line">      entry void wait4hyprelhs() {</div><div class="line">        when hyprelhs_complete(), hyprerow_complete() serial &quot;lhs&quot; { lhs(); } };</div><div class="line">      entry void wait4hyprerhs() {</div><div class="line">        when hyprerhs_complete(), hyprerow_complete() serial &quot;rhs&quot; { rhs(); } };</div><div class="line"></div><div class="line">      entry void wait4fillsol() {</div><div class="line">        when fillsol_complete() serial &quot;asmsol&quot; { assemblesol(); } };</div><div class="line">      entry void wait4filllhs() {</div><div class="line">        when filllhs_complete() serial &quot;asmlhs&quot; { assemblelhs(); } };</div><div class="line">      entry void wait4fillrhs() {</div><div class="line">        when fillrhs_complete() serial &quot;asmrhs&quot; { assemblerhs(); } };</div><div class="line"></div><div class="line">      entry void wait4asm() {</div><div class="line">        when asmsol_complete(), asmlhs_complete(), asmrhs_complete()</div><div class="line">          serial &quot;solve&quot; { solve(); } };</div><div class="line">      entry void wait4low() {</div><div class="line">        when rhsbc_complete(), lowlhs_complete(), lowrhs_complete()</div><div class="line">          serial &quot;low&quot; { lowsolve(); } };</div><div class="line"></div><div class="line">      entry void wait4solve() {</div><div class="line">        when solve_complete() serial &quot;update&quot; { updateSol(); } };</div><div class="line">      entry void wait4lowsolve() {</div><div class="line">        when lowsolve_complete() serial &quot;updatelow&quot; { updateLowSol(); } };</div><div class="line"></div><div class="line">      entry void row_complete();</div><div class="line">      entry void bc_complete_lhs();</div><div class="line">      entry void bc_complete_rhs();</div><div class="line">      entry void lhsbc_complete();</div><div class="line">      entry void rhsbc_complete();</div><div class="line">      entry void hyprerow_complete();</div><div class="line">      entry void lhs_complete();</div><div class="line">      entry void rhs_complete();</div><div class="line">      entry void sol_complete();</div><div class="line">      entry void lowrhs_complete();</div><div class="line">      entry void lowlhs_complete();</div><div class="line">      entry void hyprelhs_complete();</div><div class="line">      entry void hyprerhs_complete();</div><div class="line">      entry void hypresol_complete();</div><div class="line">      entry void filllhs_complete();</div><div class="line">      entry void fillrhs_complete();</div><div class="line">      entry void fillsol_complete();</div><div class="line">      entry void asmlhs_complete();</div><div class="line">      entry void asmrhs_complete();</div><div class="line">      entry void asmsol_complete();</div><div class="line">      entry void solve_complete();</div><div class="line">      entry void lowsolve_complete();</div><div class="line">    };</div><div class="line"></div><div class="line">  } // tk::</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="_solver_8h_source.html">Solver.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6ec0c67374eb34a66c0f5ca4ecd7d163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec0c67374eb34a66c0f5ca4ecd7d163">&#9670;&nbsp;</a></span>CK_TEMPLATES_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CK_TEMPLATES_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_solver_8h_source.html#l01413">1413</a> of file <a class="el" href="_solver_8h_source.html">Solver.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 6 2017 00:13:28 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
