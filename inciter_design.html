<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Inciter software design | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="why.html">Why</a></li>
            <li>
              <a href="build.html">Build</a>
              <ol>
                <li><a href="https://quinoacomputing.org/quinoa.github.io/index.html#mainpage_build">Quickstart</a></li>
                <li><a href="git_submodules_subtrees.html">Modules</a></li>
                <li><a href="licenses.html">Libraries</a></li>
                <li><a href="build_system.html">Internals</a></li>
              </ol>
            </li>
            <li>
              <a href="https://quinoacomputing.org/quinoa.github.io/index.html#mainpage_tools">Tools</a>
              <ol>
                <li><a href="walker_main.html">Walker</a></li>
                <li><a href="inciter_main.html">Inciter</a></li>
                <li><a href="rngtest_main.html">RNGTest</a></li>
                <li><a href="unittest_main.html">UnitTest</a></li>
                <li><a href="meshconv_main.html">MeshConv</a></li>
              </ol>
            </li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="7">
            <li>
              <a href="resources.html">Resources</a>
              <ol>
                <li><a href="https://github.com/quinoacomputing/quinoa">GitHub</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/releases">Tarballs</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/blob/master/LICENSE">License</a></li>
                <li><a href="roadmap.html">Roadmap</a></li>
                <li><a href="contributing.html">Contributing</a></li>
                <li><a href="papers.html">Publications</a></li>
                <li><a href="https://quinoa.zulipchat.com">Chat</a></li>
                <li><a href="https://quinoa.groups.io">Email list</a></li>
                <li><a href="coverage.html">Coverage</a></li>
                <li><a href="https://dev.azure.com/quinoacomputing/Quinoa">Azure</a></li>
                <li><a href="http://www.openhub.net/p/quinoacomputing">OpenHub</a></li>
                <li><a href="https://bestpractices.coreinfrastructure.org/projects/2120">Practices</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Inciter software design
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#inciter_startup">1. Startup and migration of read-only global-scope data</a>
              <ul>
                <li><a href="#inciter_startup_itself">Startup</a></li>
                <li><a href="#inciter_startup_parsing">Command line and input file parsing, global-scope data</a></li>
                <li><a href="#inciter_startup_polymorphism">Global scope data for runtime polymorphism</a></li>
                <li><a href="#inciter_startup_transporter">Create inciter&#x27;s driver, single Charm++ chare Transporter</a></li>

              </ul>
            </li>
            <li><a href="#inciter_classes">2. Important classes</a></li>
            <li>
              <a href="#inciter_setup">3. Setup</a>
              <ul>
                <li><a href="#inciter_transporter_ctor">Transporter constructor</a></li>
                <li><a href="#inciter_partitioner_ctor">Partitioner constructor</a></li>
                <li><a href="#inciter_transporter_load">Compute total load and overdecomposition</a></li>
                <li><a href="#inciter_partitioner_partition">Mesh partitioning</a></li>
                <li><a href="#inciter_refine">Optional initial mesh refinement</a></li>
                <li><a href="#inciter_reorder">Optional PE-locality mesh node reordering</a></li>
                <li><a href="#inciter_create">Creating workers</a></li>

              </ul>
            </li>
            <li><a href="#inciter_timestepping">4. Time stepping</a></li>
          </ul>
        </div>
<p>This page discusses the high-level software design and some implementation aspects of <a href="inciter_main.html" class="m-dox">Inciter</a>. The discussion roughly follows as execution happens in time, from program start to finish. On any of the Charm++ concepts below, consult the <a href="http://charm.cs.illinois.edu/manuals/html/charm++/manual.html">Charm++ manual</a>.</p><section id="inciter_startup"><h2><a href="#inciter_startup">1. Startup and migration of read-only global-scope data</a></h2><section id="inciter_startup_itself"><h3><a href="#inciter_startup_itself">Startup</a></h3><p>As all other executables in Quinoa, Inciter uses the Charm++ runtime system. Runtime execution starts in the Charm++ <code>mainmodule</code> constructor, defined in Main/Inciter.C as <code><a href="class_main.html" class="m-dox">Main</a></code>. Starting down the constructor&#x27;s initializer list, the command line is parsed, followed by creating a driver, <a href="classinciter_1_1_inciter_driver.html" class="m-dox">InciterDriver</a>, which parses the input file.</p></section><section id="inciter_startup_parsing"><h3><a href="#inciter_startup_parsing">Command line and input file parsing, global-scope data</a></h3><p>After the main chare constructor has finished, the runtime system initializes global scope data and migrates it to all other processing elements (PEs), which from that point is considered read-only.</p><p>This global-scope data are defined at the beginning of Main/Inciter.C in the same order as they appear in the companion Charm++ interface file <a href="inciter_8ci.html" class="m-dox">Main/<wbr />inciter.ci</a>. This is the order in which these data are initialized and migrated. Global scope data is limited to such read-only data. It stores data initialized during parsing the command line and the input (control) file. The command line is parsed by <a href="classinciter_1_1_cmd_line_parser.html" class="m-dox">CmdLineParser</a>&#x27;s constructor, called during the main chare&#x27;s constructor, while the input file is parsed by <a href="classinciter_1_1_input_deck_parser.html" class="m-dox">InputDeckParser</a>&#x27;s constructor, called during <a href="classinciter_1_1_inciter_driver.html" class="m-dox">InciterDriver</a>&#x27;s constructor.</p><p>Global_scope data is always prefixed by <code>g_</code>. Inciter&#x27;s global-scope data contains two input decks: the defaults (g_inputdeck_defaults) and g_inputdeck which contains all data parsed during command line and input file parsing.</p><aside class="m-note m-danger"><h4>Warning</h4><p>Note that this global-scope data is <em>assumed</em> read-only after migration but the compiler has no way of enforcing this, thus modifying it after migration is possible but will not generate an error either at compile or runtime. For more details on global scope data in Charm++, see Section <em>Read-only Data</em> in the Charm++ manual.</p></aside></section><section id="inciter_startup_polymorphism"><h3><a href="#inciter_startup_polymorphism">Global scope data for runtime polymorphism</a></h3><p>Two global scope vectors in inciter are <code>g_cgpde</code> and <code>g_dgpde</code>. These two vectors hold base classes for partial differential equations (PDE) that can be specialized to different types of derived PDEs that use continuous Galerkin finite element (FE) discretizations (<a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a>) and discontinuous Galerkin FE discretizations (<a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a>). These two vectors are global scope because they hold pointers to derived classes that enable runtime polymorphism. Runtime polymorphism enables code reuse and helps client code stay uniform and modular. Such polymorphic use of pointers (<code>std::unique_ptr</code>) are one of the rare uses of pointers throughout the code.</p><aside class="m-note m-info"><h4>Note</h4><p>While Charm++ allows migratable chares holding pointers and even supports runtime polymorphism among chare arrays, we strongly discourage the use of pointers and reference semantics, because it complicates writing safe code for such migratable objects. For more details on reference and value semantics in C++, see <a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics">https:/<wbr />/<wbr />isocpp.org/<wbr />wiki/<wbr />faq/<wbr />value-vs-ref-semantics</a>. For more details on runtime polymorphism without client-side inheritance, the style in which the &quot;base&quot; classes <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> and <a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a> are written, that leads to cleaner and safer client code, see Sean Parent&#x27;s talk on <a href="http://sean-parent.stlab.cc/papers-and-presentations/#value-semantics-and-concept-based-polymorphism">concept-based polymorphism</a>. For more details on concept-based runtime polymorphism with migratable Charm++ chare arrays using value semantics, see Inciter/Scheme.h and the talk, titled <em>Concept-based runtime polymorphism with Charm++ chare arrays using value semantics</em>, given at the <a href="http://charm.cs.illinois.edu/workshops/charmWorkshop2018/program.php">16th Annual Workshop on Charm++ and its Applications</a>.</p></aside></section><section id="inciter_startup_transporter"><h3><a href="#inciter_startup_transporter">Create inciter&#x27;s driver, single Charm++ chare Transporter</a></h3><p>Up to this point execution is serial, since there is only a single main Charm++ chare. <code><a href="classinciter_1_1_inciter_driver.html" class="m-dox">InciterDriver</a></code>&#x27;s constructor then fires up a single Charm++ chare instance of <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, called from <a href="class_main.html#aa4e0afaa96eda09358acfacfb672fe41" class="m-dox">Main::<wbr />execute()</a> after the runtime system has finished migrating all global-scope data. Note that <a href="classinciter_1_1_inciter_driver.html" class="m-dox">InciterDriver</a> is <em>not</em> a Charm++ chare, only an ordinary C++ class. <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, defined in Inciter/Transporter.C, is the main driver class of Inciter that is a Charm++ chare from which all execution happens, e.g., via broadcasts, and to which all execution ends up in, leading to <code><a href="classinciter_1_1_transporter.html#a210a63a6cb2656c5591e3fc19e8fc2c9" class="m-dox">Transporter::<wbr />finish()</a></code>, which eventually calls back to <code><a href="class_main.html#a79fa7f2b2377b41626163cd6f3e2073d" class="m-dox">Main::<wbr />finalize()</a></code>, calling <code>CkExit()</code>, signaling the runtime system to exit.</p></section></section><section id="inciter_classes"><h2><a href="#inciter_classes">2. Important classes</a></h2><p>Here are the important classes that interoperate within inciter:</p><ul><li><code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code> (single chare, driver)</li><li><code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code> (chare <em>nodegroup</em>, mesh partitioner)</li><li><code><a href="classtk_1_1_mesh_writer.html" class="m-dox">tk::<wbr />MeshWriter</a></code> (chare <em>group</em>, mesh writer, performing file output in parallel)</li><li><code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> (chare <em>array</em>, mesh refiner)</li><li><code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code> (chare <em>array</em>, performs mesh reordering)</li><li><code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> (chare <em>array</em>, generic PDE solver base class)<ul><li><code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code> (chare <em>array</em>, PDE solver child class, specialized to a continuous Galerkin finite element discretization scheme with a lumped-mass left-hand side and flux-corrected transport combined with Lax-Wendroff-like explicit time stepping scheme that is second order accurate in space and time),</li><li><code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code> (chare <em>array</em>, PDE solver child class, specialized to a discontinuous Galerkin finite element discretization scheme with a diagonal left-hand side with explicit Runge-Kutta time stepping),</li><li>... (more hydro schemes to be added in the future)</li></ul></li><li><code><a href="classinciter_1_1_dist_f_c_t.html" class="m-dox">DistFCT</a></code> (chare <em>array</em>, performs distributed-memory flux-corrected transport, if used by a specific discretization scheme, e.g., <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>)</li></ul><p><em>Chare</em> above means a single Charm++ chare. There is a single instance of this class. By design, <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code> is a single chare and is used as a driver that creates objects, used as a target of global parallel reductions, and thus global synchronization points. <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code> also does most of the printouts to screen, collects statistics, and is the end-point of execution in <code><a href="classinciter_1_1_transporter.html#a210a63a6cb2656c5591e3fc19e8fc2c9" class="m-dox">Transporter::<wbr />finish()</a></code>.</p><p><em>Group</em> above means a Charm++ chare group. A group is a processor-aware chare collection, which means that there is guaranteed to be a single instance of a group per PE which does <em>not</em> migrate. <code>MeshWriter</code> is a group because it calls the MPI-only library, ExodusII, for outputing mesh and mesh-based solution field data to files. Note that while <code>MeshWriter</code> is a group, the way we use it makes it similar to a nodegroup but with group semantics: we call its Charm++ entry method <code>MeshWriter::write()</code> from multiple array elements (from <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>) targeting ony the first PE of each logical node. This yields &quot;serializing&quot; every call per node, required for the underlying non-thread-safe NetCDF/HDF5 library calls, made by ExodusII. This way writing large solution data works in both non-SMP and SMP mode correctly and efficiently, since parallel output load is configurable separately from the number of work-units for computation.</p><p><em>Nodegroup</em> above means a Charm++ chare nodegroup. A nodegroup is a processor-aware chare collection, which means that there is guaranteed to be a single instance of a nodegroup per logical (e.g., compute) node which does <em>not</em> migrate. <code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code> is a nodegroup because it calls MPI-only libraries.</p><aside class="m-note m-info"><h4>Note</h4><p>Charm++ <code>nodegroup</code>s, are similar to groups in that they are processor-aware but instead of one per PE, nodegroups are guaranteed to be one per logical (compute) node, where a <em>compute node</em> is understood to be a logical node which may or may not be equivalent to a physical compute node (i.e., a shared-memory node), depending on how a given execution environment is configured in Charm++&#x27;s symmetric multi-processing mode (SMP) mode. (For example, a run in SMP mode can be configured with a logical node corresponding to a shared-memory compute node or to a socket within a compute node). Similar to groups, nodegroups do not migrate but there are significant differences in their parallel computing semantics in how the runtime system invokes their member functions compared to groups. In particular, while member functions of chare arrays and groups execute exclusively in a single instance, node groups allow multiple <em>non-exclusive</em> member functions to execute concurrently in a single nodegroup instance. Note that there is no difference between groups and nodegroups if Charm++ is built in non-SMP mode, which is currently the default. For more details see the Charm++ manual.</p></aside><p><em>Array</em> above means a Charm++ chare array, whose elements can migrate (if enabled) and thus they actively participate in automatic load balancing. With nonzero overdecomposition, there may be more array elements (workers) than the number of available PEs. Arrays do the bulk of the heavy lifting in a calculation, i.e., computing right-hand sides for PDE operators, and hold the bulk of unknown/solution arrays. The degree of overdecomposition can be specified by the <code>-u</code> command line argument. This argument accepts a real value between 0.0 and 1.0, inclusive. 0.0 means no overdecomposition, which corresponds to partitioning the mesh into a number of pieces equalling the number of PEs available. (<code>-u 0.0</code> yields an execution style that is most similar to how MPI codes are traditionally used, which is the default.) Nonzero overdecomposition yields larger number of mesh partitions than the available PEs. The extreme of <code>1.0</code> represents the largest degree of overdecomposition, which also results in the smallest work units. For a discussion on the effects of overdecomposition, see the page on <a href="inciter_performance.html" class="m-dox">Inciter performance</a>.</p><p><em>Bound arrays</em>: <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> and its specialized children, <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>, <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>, etc., <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>, and, if used/created, <code><a href="classinciter_1_1_dist_f_c_t.html" class="m-dox">DistFCT</a></code> are <em>bound</em> arrays. This means that the runtime system migrates its corresponding array elements together. Bound arrays facilitate modularization among workers that migrate. Since array elements that are bound always appear together on a given PE, even after migration, they can also be thought of as part of the same class, because they can access data from each other (but still respecting the C++ rules of <code>public</code>, <code>private</code>, etc). However, dividing functionality into classes, as always, helps readibility and makes reasoning about code easier.</p></section><section id="inciter_setup"><h2><a href="#inciter_setup">3. Setup</a></h2><section id="inciter_transporter_ctor"><h3><a href="#inciter_transporter_ctor">Transporter constructor</a></h3><p>Inciter&#x27;s setup starts with <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>&#x27;s constructor. After some printouts on configuration, some of the important classes are created, introduced above. In some cases, we simply call Charm++&#x27;s <code>ckNew()</code> without arguments. This means an empty Charm++ chare array is created, we get hold of its proxy, but no constructors are run yet. An example for this is <code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code>. We do empty array creation for two main reasons: (1) we don&#x27;t yet have all data that is needed to create the given class (more preparation is required but we need its proxy already), and/or (2) we need to pass specific data to each array (or group) element&#x27;s constructor, which can only be done via dynamic insertion. (Passing it via Charm++&#x27;s <code>ckNew()</code> would pass the same data to all elements to be created in a broadcast fashion, and this is not what we want most of the time.) For example, <code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code> needs part of the mesh connectivity, coordinates, etc., for which we need to have the mesh partitioned first. This also allows nicely adhering to the <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> idiom of the object oriented paradigm, which helps writing correct code.</p><p><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a> thus creates <a href="classtk_1_1_mesh_writer.html" class="m-dox">tk::<wbr />MeshWriter</a>, <a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a>, <a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a>, and <a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a>. These classes play an importart role during setup, but some are also (re-)used during time stepping.</p><aside class="m-note m-info"><h4>Note</h4><p>The classes that eventually do most of the heavy-lifting of computing operators for partial differential equations, are not yet created - not all information is available for those yet. However, their Charm++ proxies are created and encapsulated within SchemeBase. These <em>worker proxies</em>, <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>, etc., together with their &quot;base&quot; class, <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code>, are bound together so that the runtime system migrates them together during load balancing. This is because the &quot;child&quot; is designed to be able to directly access data from its base, as in usual runtime polymorphism. Such direct access of (large) data allows not having to create copies and allows reducing communication costs, while still allos modularizing code operating on the same data. For more details on <a href="classinciter_1_1_scheme.html" class="m-dox">Scheme</a>, SchemeBase, <a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a>, and its children, see Inciter/Scheme.h.</p></aside><p>In many cases, we pass a number of callbacks to chare arrays and groups when their Charm++ proxy is created with <code>ckNew()</code>. These callbacks are of type <code>CkCallback</code>. This is one technique that we use as a kind of type erasure so that these classes can interoperate with each other as well as with their host, <a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a>. This helps resolving cyclic include dependencies. These callbacks mostly denote reduction targets to <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, that are necessary synchronization points during setup. A <code>CkCallback</code> is similar to std::function or a C-style function pointer, but can also store a callback to a Charm++ chare object that happens to reside across the network, i.e., an entry method call via a proxy.</p></section><section id="inciter_partitioner_ctor"><h3><a href="#inciter_partitioner_ctor">Partitioner constructor</a></h3><p>While from <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>&#x27;s constructor we create a number of Charm++ chare arrays, most of them are empty to start with. An exception is <code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code>, whose constructor starts by reading a different chunk of the mesh in blocks as they appear in the file. We read a chunk of the mesh and associated node coordinates for all mesh cells that are in the chunk read. <code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code>&#x27;s constructor also reads/computes the triangle element connectivity associated to side sets as well as the node lists associated to side sets. Note that only the portion of all this data is read in on a nodegroup that belongs to a given chunk of the mesh. At this point this results in a simple partitioning which almost certainly <em>not</em> ideal for computing equations later, because of a large surface-area-to-volume ratio of these partitions of the computational domain, since we cannot assume that the ordering in the mesh file also corresponds to close physical-space proximity. <code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code>&#x27;s constructor finishes with a global reduction to <code><a href="classinciter_1_1_transporter.html#adeb1a31536e7f758a5ac98171705c36e" class="m-dox">Transporter::<wbr />load()</a></code>, which sums the number of elements and the number of nodes (points) in the complete problem (read in in a distributed fashion).</p></section><section id="inciter_transporter_load"><h3><a href="#inciter_transporter_load">Compute total load and overdecomposition</a></h3><p>After reading the mesh in a distributed fashion, we now know the total number of cells and points and <code><a href="classinciter_1_1_transporter.html#adeb1a31536e7f758a5ac98171705c36e" class="m-dox">Transporter::<wbr />load()</a></code> computes the total number of worker chares that will be used to partition the problem into. If there is a nonzero overdecomposition configured by the command line argument <code>-u</code>, the number of chares (partitions) may be more than the available PEs. This is computed by <a href="namespacetk.html#ae484074849c5c9532282fc9fa4e19467" class="m-dox">tk::<wbr />linearLoadDistributor()</a>. We then start mesh partitioning by issuing a broadcast to <a href="classinciter_1_1_partitioner.html#af0ed691bfaf90f34d17ae88b4042c868" class="m-dox">Partitioner::<wbr />partition()</a>.</p></section><section id="inciter_partitioner_partition"><h3><a href="#inciter_partitioner_partition">Mesh partitioning</a></h3><p><code><a href="classinciter_1_1_partitioner.html#af0ed691bfaf90f34d17ae88b4042c868" class="m-dox">Partitioner::<wbr />partition()</a></code> sets up the necessary data for calling an external mesh partitioner. Currently, various coordinate-based partitioners are hooked up from Zoltan2. This works in distributed-memory parallel fashion, and calls MPI under the hood (inside the library call). Note that the number of desired mesh partitions equals the number of Charm++ (worker) chares we want, which can be larger than the number of PEs (or compute nodes). The output of mesh partitioning is a map that assigns a chare id to each mesh cell. Next is to categorize (or group) all cells (their connectivity and node coordinates) together that are assigned to each chare by the partitioner and send them to their (owner) chare. This is started out in <code><a href="classinciter_1_1_partitioner.html#a019e7c7ac69a14815465c89ca3a04a14" class="m-dox">Partitioner::<wbr />distribute()</a></code>, and communicated, in a point-to-point fashion, to other <a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a> chares by calling the <a href="classinciter_1_1_partitioner.html#a8832423e65bf4099a724ce7e52cf222d" class="m-dox">Partitioner::<wbr />addMesh()</a> entry method. When every <a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a> object has received their assigned mesh, they issue a global <code>contribute</code> call to <code><a href="classinciter_1_1_transporter.html#a5bf1d119a4e16677bc22bfe70b23a41b" class="m-dox">Transporter::<wbr />distributed()</a></code>. When all contribute calls have arrived, communication of the different parts of the mesh has finished. This is followed by optional initial mesh refinement.</p></section><section id="inciter_refine"><h3><a href="#inciter_refine">Optional initial mesh refinement</a></h3><p><code><a href="classinciter_1_1_transporter.html#a5bf1d119a4e16677bc22bfe70b23a41b" class="m-dox">Transporter::<wbr />distributed()</a></code> issues a broadcast to <code><a href="classinciter_1_1_partitioner.html#a66ce5723b0c2062be7a16ff93fd99001" class="m-dox">Partitioner::<wbr />refine()</a></code>, which uses dynamic array insertion to create all <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> chare array elements. Note that there may be multiple <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> objects created on each <code><a href="classinciter_1_1_partitioner.html" class="m-dox">Partitioner</a></code> PE (or compute node in SMP mode). Each <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> constructor gets a chunk of the mesh (which now are smaller chunks than the chunks that were originally read from file), corresponding to the total number of chares. Not only the mesh connectivity and node coordinates, but also the boundary face connectivity and boundary node lists associated to multiple side sets are also passed to <a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a>, and only those portions of these data structures that belong to the particular <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> chare. (Boundary face connectivity is used for cell-based discretization schemes, such as <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>, while boundary node lists are used for nodal discretizations, such as <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code> to set boundary conditions.)</p><aside class="m-note m-info"><h4>Note</h4><p>As usual, dynamic insertion calls are asynchronous, i.e., the calls are really only signals to the runtime system that it is time to start calling constructors passing their correct data. Array element insertion can be controlled by custom array placement. See the Charm++ manual.</p></aside><p><code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code>&#x27;s constructor evaluates user configuration and decides if initial mesh refinement is to be performed or not. If not, execution is simply skipped ahead to <a href="classinciter_1_1_refiner.html#a0d0ff8b2304530e296d2caa51e295565" class="m-dox">Refiner::<wbr />endt0ref()</a>. If initial refinement is configured, we descend into <a href="classinciter_1_1_refiner.html#a0e07eff9c41be67c8bfc411759d8d0db" class="m-dox">Refiner::<wbr />t0ref()</a>.</p><p>There are two ways <a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a> is used:</p><ol><li>Mesh refinement before time stepping (t&lt;0), <code>t0ref</code>, and</li><li>Mesh refinement during time stepping (t&gt;0), <code>dtref</code>.</li></ol><p>Initial mesh refinement consists of potentially multiple steps of different refinement types, e.g., <code>uniform</code>, <code>ic</code>, <code>coordref</code>, which respectively stand for uniform refinement, i.e., split each tetrahedron into 8 new ones, initial-conditions-based, i.e., non-uniform refinement based on estimating the error in the initial conditions on a given initial mesh, and coordinate-based, which allows specifying planes and simple extents in 3 dimensional space and allows tagging edges for refinement between two extremes. Additionally the user can also tag edges manually, creating a list of pairs of global node ids.</p><p>Refiner::eval() evaluates, at the end of each initial refinement step, if a next initial refinement step is to be performed. In the last step, execution continues to <a href="classinciter_1_1_refiner.html#a0d0ff8b2304530e296d2caa51e295565" class="m-dox">Refiner::<wbr />endt0ref()</a>, which creates <a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a>.</p><p><a href="classinciter_1_1_refiner.html#a0d0ff8b2304530e296d2caa51e295565" class="m-dox">Refiner::<wbr />endt0ref()</a> not only creates the <code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code> array chares but also reports back to <a href="classinciter_1_1_transporter.html#a2bd71ba6e98a47829e67345b74718f4e" class="m-dox">Transporter::<wbr />refined()</a>, signaling the end of the initial mesh refinement. In this reduction target the final number of mesh cells and nodes are also aggregated across the whole problem.</p></section><section id="inciter_reorder"><h3><a href="#inciter_reorder">Optional PE-locality mesh node reordering</a></h3><p><code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code> takes a chunk of the mesh, together with its physical boundary face and node data structures, and sets up a symmetric node communication map, <a href="classinciter_1_1_sorter.html#aedca7109debb8d030fbd46d38090c268" class="m-dox">Sorter::<wbr />m_msum</a>, which stores the global node IDs of chare boundaries associated to chare IDs on each chare. This map is symmetric in a sense that if two chares share a node after partitioning, the same node ID will be stored on each chare assigned to the other chare ID. This map is used for point-point communication during time stepping. This map is used by node-centered (CG) schemes, as well as a starting point for setting up face and ghost communication data structures for cell-centered <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>.</p><p><code><a href="classinciter_1_1_sorter.html" class="m-dox">Sorter</a></code> performs optional PE-locality mesh node reordering in parallel. This reordering is optional and is off by default. The reordering assigns new global mesh node IDs that roughly increase with chare ID.</p><p>Whether node reordering is to be performed or not is evaluated in <a href="classinciter_1_1_sorter.html#a40f2a51e600250cf48857b6d815ab13b" class="m-dox">Sorter::<wbr />start()</a>. If reordering is done, it starts in <a href="classinciter_1_1_sorter.html#ae2a1cb405d957571f0f2fea901809bae" class="m-dox">Sorter::<wbr />mask()</a>. If reordering is not done, we skip to <a href="classinciter_1_1_sorter.html#ad0a3090d1bf2b96b03e4a2251231adcc" class="m-dox">Sorter::<wbr />createDiscWorkers()</a>, which starts creating the worker chares, that will eventually perform the heavy lifting during time stepping: computing the PDE operators during time integration.</p></section><section id="inciter_create"><h3><a href="#inciter_create">Creating workers</a></h3><p>The worker Charm++ chare array elements, that store the mesh and associated data structures and compute PDE operators during time stepping, are organized into a single-level base-child relationship for code reuse and runtime polymorphism. However, both the base-child relationship and runtime polymorphism are slightly differently implemented compared to what would be familiar with inheritance in standard object-oriented programming (OOP).</p><p>There is a single base class, <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code>, that encapsulates data and member functions that are generic to all mesh-based discretization schemes. It stores the mesh, connectivity, node coordinates, etc. As <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> is a chare array, its elements are distributed across the whole problem on all available compute nodes and PEs, and can also migrate for load balancing. In the OOP sense, derived (or child) classes are the classes that implement a particular discretization scheme, e.g., <a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a> or <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>.</p><aside class="m-note m-info"><h4>Note</h4><p>For more details on runtime polymorphism with migratable Charm++ chare arrays using value semantics, see Inciter/Scheme.h and the talk, titled <em>Concept-based runtime polymorphism with Charm++ chare arrays using value semantics</em>, given at the <a href="http://charm.cs.illinois.edu/workshops/charmWorkshop2018/program.php">16th Annual Workshop on Charm++ and its Applications</a>.</p></aside><p><a href="classinciter_1_1_sorter.html#ad0a3090d1bf2b96b03e4a2251231adcc" class="m-dox">Sorter::<wbr />createDiscWorkers()</a> starts creating the <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> chares. This is done via the usual Charm++ dynamic array insertion passing the mesh chunk and associated data structures to their constructors. Eventually, this is followed by creating the child workers in <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a>.</p><p>Execution from the <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> constructor follows to <a href="classinciter_1_1_transporter.html#a12dfec8cc35ac4f6939950e29020e343" class="m-dox">Transporter::<wbr />disccreated()</a> which fires up <code><a href="classinciter_1_1_discretization.html#a9d7bd561b8e5fb137be128f0fea731b1" class="m-dox">Discretization::<wbr />vol()</a></code>, which computes nodal volumes as well as the total volume of the complete problem, which ends up in <code><a href="classinciter_1_1_transporter.html#a9c3c4e44feaeb11f6872ec99d97d39a4" class="m-dox">Transporter::<wbr />totalvol()</a></code>. Volume calculations are followed by computing various statistics on the mesh cell sizes, including min/max edge lengths, and histograms, which are useful diagnostics to estimate load imbalance.</p><aside class="m-note m-info"><h4>Note</h4><p>The mesh statistics computed by <a href="classinciter_1_1_discretization.html#a817a77766aed0dd2d38b7a12c63a82c4" class="m-dox">Discretization::<wbr />stat()</a> are simple diagnostics and feedback for the user and the developer and are <em>not</em> used by the runtime system for load balancing.</p></aside><p>The various mesh statistics aggregate and arrive independently in reduction target member functions of <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>, <code>minstat()</code>, <code>maxstat()</code>, <code>sumstat()</code>, and <code>pdfstat()</code>. When all of these are complete (see <a href="transporter_8ci.html" class="m-dox">src/<wbr />Inciter/<wbr />transporter.ci</a> how this condition is told the runtime system using a DAG) ,<a href="classinciter_1_1_transporter.html#a98951a365f21d85d82d49313a2f0fa5c" class="m-dox">Transporter::<wbr />stat()</a> is called in which execution continues by creating the child (or derived) workers in <a href="classinciter_1_1_sorter.html#afdf45d3adb35902c5120c1ab5c849779" class="m-dox">Sorter::<wbr />createWorkers()</a>. As usual, the children are also created by dynamic array insertion.</p><aside class="m-note m-danger"><h4>Warning</h4><p>Since the child classes <code><a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a></code>, <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>, etc., access (potentially large) data from <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> via raw pointers (from Charm++ proxies), base and child are always migrated together, using Charm++&#x27;s <em>bound arrays</em> feature. <code><a href="classinciter_1_1_refiner.html" class="m-dox">Refiner</a></code> and <code><a href="classinciter_1_1_dist_f_c_t.html" class="m-dox">DistFCT</a></code> are also bound to <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code> and the children. See also src/Inciter/SchemeBase.h and the discussion in src/Inciter/Scheme.h.</p></aside><p>After the child constructors have started, one way or another, they are expected to call <a href="classinciter_1_1_transporter.html#a5a29629d824a461d0ed76a457970df82" class="m-dox">Transporter::<wbr />comfinal()</a>, which signals the end of setting up any (additional) communication maps needed by the specific discretization schemes. After this the child classes are called again via their member function <code>setup()</code>. All specific discretization schemes, &quot;deriving from&quot; <code><a href="classinciter_1_1_discretization.html" class="m-dox">Discretization</a></code>, are expected to define certain member functions, such as <code>setup()</code>, which do scheme-specific setup and is eventually expected to call <code>dt()</code>, which starts time stepping (by computing the size of the next time step). <code>dt()</code> is also the member function that is called again and again starting a new time step during time stepping.</p></section></section><section id="inciter_timestepping"><h2><a href="#inciter_timestepping">4. Time stepping</a></h2><p>After all the above, time stepping starts. Time stepping is and may be done very differently by the different types of discretizations but they are all expected to define a few member functions that are common so they can interoperate with their host, <code><a href="classinciter_1_1_transporter.html" class="m-dox">Transporter</a></code>. These are Charm++ entry methods and must also have the same function signature (as in a derived class in OOP). Since the set of these function may change, the best way to find out what is required is to compare the Charm++ interface (<code>.ci</code>) files for the specific discretization schemes, e.g., <a href="classinciter_1_1_diag_c_g.html" class="m-dox">DiagCG</a>, <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, etc., and look for entry methods that are defined by all child schemes.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.org/quinoa.github.io+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.org/quinoa.github.io+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="http://quinoacomputing.org/quinoa.github.io/">Quinoa project</a>. Copyright Â© J. Bakosi 2012&ndash;2015, Los Alamos National Security, LLC, 2016&ndash;2018, <a href="https://www.triadns.org/">Triad National Security, LLC,</a> 2019-2021. Generated on Tuesday, Nov 23, 2021 based on <a href="https://github.com/quinoacomputing/quinoa/commit/7dc367005">7dc367005</a> by <a href="http://doxygen.org/">Doxygen</a> and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/">GitHub</a>, <a href="https://groups.io/g/quinoa">Email</a> or <a href="https://quinoa.zulipchat.com">Chat</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>